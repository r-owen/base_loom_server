{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Loom Server A loom server allows you to control a computer-controlled loom from a web browser on a phone, tablet or computer. Click an image to see a gallery of screen shots. Features include: Direct support for three types of weaving pattern files: WIF (.wif), Fiberworks (.dtx), and WeavePoint (.wpo). Support for weaving and threading. Settings to accommodate your preferences. Preliminary support for multiple languages (the translation files need work; contributions welcome). Runs on all major operating systems. The software is free and uses the generous MIT license. I maintain software to control Toika and S\u00e9guin looms. The base package base_loom_server does most of the work, so it is easy to support other looms . This document explains how to use these loom servers. The first step is to install the software. Once you have done that, read on: Connect to the Loom Server Connect to the loom server using any modern web browser (e.g. on a phone, tablet, or laptop). The address will be \"http:// hostname .local:8000\" where hostname is the host name of the loom server computer, as determined in Installing . If you are running the web browser and web server on the same computer, you can skip the hostname and connect to \"http://localhost:8000\". Select the Mode The server has three modes, which are listed at the top of the web page: Weaving is used to weave fabric; this is by far the most common mode. Threading helps you thread the loom, by lifting shafts for groups of threads. Settings allows you specify settings that apply to all weaving pattern files. Click on the word to select that mode. The bold word shows the current mode. The links above give detailed instructions for each mode. But before you dive into that, read the next section about pattern files: In addition, the \"?\" link on the same line as the mode tabs opens documentation in a new browser tab. Upload and Select Pattern Files Before you can weave or thread, you must upload one or more pattern files to the loom server. The server accepts WIF (.wif), Fiberworks (.dtx), and WeavePoint (.wpo) files. There are two ways to upload files: Push the \"Upload\" button. Drag and drop the files onto the web page (making sure the web page is gray before dropping them). Once you have uploaded patterns, you can select one using the menu labeled \"Pattern\" (next to the \"Upload\" button). The loom server remembers the 25 most recent patterns that you have uploaded, and this information is saved on disk, so should not be lost in a power failure. The saved information includes the most recent pick (weaving) and the most recent warp thread group (threading). This allows you to switch between different patterns while weaving something. However, if you upload a new pattern with the same file name as a saved pattern, the new pattern overwrites the old and the pick and warp thread group information is reset. So please be careful. To clear out the pattern menu (which may become cluttered over time), select \"Clear Recents\", the last item in the pattern menu. This clears out information for all patterns except the current pattern. Multiple Connections The server only allows one web browser to connect, and the most recent connection wins. This prevents a mystery connection from hogging the loom. If the connection is dropped on the device you want to use for weaving, simply reload the page to regain the connection. Reset the Loom Connection Every time you connected to the web server or reload the page, the server refreshes its connection to the loom (by disconnecting and immediately reconnecting). So if the server is reporting a problem with its connection to the loom, and it is not due to the loom losing power, or a disconnected or bad USB cable, you might try reloading the page. If the loom seems confused, try turning off the loom, waiting a few seconds, then turning it on again. Then reload the web page, to force the web server to make a new connection to the loom.","title":"Home"},{"location":"#loom-server","text":"A loom server allows you to control a computer-controlled loom from a web browser on a phone, tablet or computer. Click an image to see a gallery of screen shots. Features include: Direct support for three types of weaving pattern files: WIF (.wif), Fiberworks (.dtx), and WeavePoint (.wpo). Support for weaving and threading. Settings to accommodate your preferences. Preliminary support for multiple languages (the translation files need work; contributions welcome). Runs on all major operating systems. The software is free and uses the generous MIT license. I maintain software to control Toika and S\u00e9guin looms. The base package base_loom_server does most of the work, so it is easy to support other looms . This document explains how to use these loom servers. The first step is to install the software. Once you have done that, read on:","title":"Loom Server"},{"location":"#connect-to-the-loom-server","text":"Connect to the loom server using any modern web browser (e.g. on a phone, tablet, or laptop). The address will be \"http:// hostname .local:8000\" where hostname is the host name of the loom server computer, as determined in Installing . If you are running the web browser and web server on the same computer, you can skip the hostname and connect to \"http://localhost:8000\".","title":"Connect to the Loom Server"},{"location":"#select-the-mode","text":"The server has three modes, which are listed at the top of the web page: Weaving is used to weave fabric; this is by far the most common mode. Threading helps you thread the loom, by lifting shafts for groups of threads. Settings allows you specify settings that apply to all weaving pattern files. Click on the word to select that mode. The bold word shows the current mode. The links above give detailed instructions for each mode. But before you dive into that, read the next section about pattern files: In addition, the \"?\" link on the same line as the mode tabs opens documentation in a new browser tab.","title":"Select the Mode"},{"location":"#upload-and-select-pattern-files","text":"Before you can weave or thread, you must upload one or more pattern files to the loom server. The server accepts WIF (.wif), Fiberworks (.dtx), and WeavePoint (.wpo) files. There are two ways to upload files: Push the \"Upload\" button. Drag and drop the files onto the web page (making sure the web page is gray before dropping them). Once you have uploaded patterns, you can select one using the menu labeled \"Pattern\" (next to the \"Upload\" button). The loom server remembers the 25 most recent patterns that you have uploaded, and this information is saved on disk, so should not be lost in a power failure. The saved information includes the most recent pick (weaving) and the most recent warp thread group (threading). This allows you to switch between different patterns while weaving something. However, if you upload a new pattern with the same file name as a saved pattern, the new pattern overwrites the old and the pick and warp thread group information is reset. So please be careful. To clear out the pattern menu (which may become cluttered over time), select \"Clear Recents\", the last item in the pattern menu. This clears out information for all patterns except the current pattern.","title":"Upload and Select Pattern Files"},{"location":"#multiple-connections","text":"The server only allows one web browser to connect, and the most recent connection wins. This prevents a mystery connection from hogging the loom. If the connection is dropped on the device you want to use for weaving, simply reload the page to regain the connection.","title":"Multiple Connections"},{"location":"#reset-the-loom-connection","text":"Every time you connected to the web server or reload the page, the server refreshes its connection to the loom (by disconnecting and immediately reconnecting). So if the server is reporting a problem with its connection to the loom, and it is not due to the loom losing power, or a disconnected or bad USB cable, you might try reloading the page. If the loom seems confused, try turning off the loom, waiting a few seconds, then turning it on again. Then reload the web page, to force the web server to make a new connection to the loom.","title":"Reset the Loom Connection"},{"location":"coding/","text":"Coding Installing Source Code Install Python as explained in Installing . Download the source code from github , or make a fork and git clone that. Inside the directory, do the following: Make \"editable installation\" of the package. An editable installation runs from the source code, so changes you make to the source are used when you run or test the code, without the need to reinstall the package: pip install -e .'[dev]' where the single quotes around [dev] are required in zsh, but not in bash. '[dev]' installs development-related packages such as pytest (see the file pyproject.toml for the full list). Activate the pre-commit hooks: pre-commit install Run unit tests to test your installation: pytest You may run an example loom server with: run_example_loom <num_shafts> mock Please only specify the mock serial port; connecting it to a real loom will not work ( ExampleMockLoom is loosely based on a S\u00e9guin loom, but is not compatible). run_example_loom <num_shafts> mock also accepts these command-line arguments: * `--reset-db` Reset the pattern database. Try this if you think the database is corrupted. * `--verbose` Print more diagnostic information. Note that the example loom server uses the same pattern database as seguin_loom_server and toika_loom_server . In mock mode the web page shows a few extra controls for debugging. Warning: the web server's automatic reload feature, which reloads Python code whenever you save changes, does not work with this software. Instead you have to kill the web server by typing control-C several times, until you get a terminal prompt, then run the server again. This may be a bug in uvicorn; see this discussion for more information. Writing a Loom Server Install the base_loom_server package either using pip, or from source (as described above). Source makes it easier to look through the code. Write a subclass of BaseMockLoom that emulates your loom. Two examples are ExampleMockLoom in this package and MockLoom in toika_loom_server . For simplicity and future compatibility, try to avoid overriding the constructor. Instead, perform loom-specific initialization by overriding the __post_init__ method (which is normally a no-op in BaseMockLoom , so you need not call super().__post_init__ ). Write a subclass of BaseLoomServer that talks to the loom. Two examples are ExampleLoomServer in this package and LoomServer in toika_loom_server . For simplicity and future compatibility, try to avoid overriding the constructor. Instead, perform loom-specific initialization by overriding the __post_init__ method (which is a no-op in BaseLoomServer , so you need not call super().__post_init__ ). Write a main.py like the one in base_loom_server , to run your loom server. Copy tests/test_mock_loom.py and modify it to suit your mock loom. The unit tests for your loom server should be able to use testutils.BaseTestLoomServer , as tests/test_loom_server.py does. Write a pyproject.toml like the one for toika_loom_server .","title":"Coding"},{"location":"coding/#coding","text":"","title":"Coding"},{"location":"coding/#installing-source-code","text":"Install Python as explained in Installing . Download the source code from github , or make a fork and git clone that. Inside the directory, do the following: Make \"editable installation\" of the package. An editable installation runs from the source code, so changes you make to the source are used when you run or test the code, without the need to reinstall the package: pip install -e .'[dev]' where the single quotes around [dev] are required in zsh, but not in bash. '[dev]' installs development-related packages such as pytest (see the file pyproject.toml for the full list). Activate the pre-commit hooks: pre-commit install Run unit tests to test your installation: pytest You may run an example loom server with: run_example_loom <num_shafts> mock Please only specify the mock serial port; connecting it to a real loom will not work ( ExampleMockLoom is loosely based on a S\u00e9guin loom, but is not compatible). run_example_loom <num_shafts> mock also accepts these command-line arguments: * `--reset-db` Reset the pattern database. Try this if you think the database is corrupted. * `--verbose` Print more diagnostic information. Note that the example loom server uses the same pattern database as seguin_loom_server and toika_loom_server . In mock mode the web page shows a few extra controls for debugging. Warning: the web server's automatic reload feature, which reloads Python code whenever you save changes, does not work with this software. Instead you have to kill the web server by typing control-C several times, until you get a terminal prompt, then run the server again. This may be a bug in uvicorn; see this discussion for more information.","title":"Installing Source Code"},{"location":"coding/#writing-a-loom-server","text":"Install the base_loom_server package either using pip, or from source (as described above). Source makes it easier to look through the code. Write a subclass of BaseMockLoom that emulates your loom. Two examples are ExampleMockLoom in this package and MockLoom in toika_loom_server . For simplicity and future compatibility, try to avoid overriding the constructor. Instead, perform loom-specific initialization by overriding the __post_init__ method (which is normally a no-op in BaseMockLoom , so you need not call super().__post_init__ ). Write a subclass of BaseLoomServer that talks to the loom. Two examples are ExampleLoomServer in this package and LoomServer in toika_loom_server . For simplicity and future compatibility, try to avoid overriding the constructor. Instead, perform loom-specific initialization by overriding the __post_init__ method (which is a no-op in BaseLoomServer , so you need not call super().__post_init__ ). Write a main.py like the one in base_loom_server , to run your loom server. Copy tests/test_mock_loom.py and modify it to suit your mock loom. The unit tests for your loom server should be able to use testutils.BaseTestLoomServer , as tests/test_loom_server.py does. Write a pyproject.toml like the one for toika_loom_server .","title":"Writing a Loom Server"},{"location":"installing/","text":"Installing This page gives instructions for installing a loom driver such as such as seguin_loom_server or toika_loom_server that is based on base_loom_server . See Coding if you want to work on base_loom_server or use it to develop a new loom driver. Pick your Computer Decide which computer you will use to run the loom server. Any macOS, Windows, or linux computer will work, and a laptop is a fine choice, especially as you can run your web browser on the same machine that runs the server. The software uses minimal resources, so an old, slow computer is fine. A Raspberry Pi (I suggest model 4 or better) will work, but will be a bit slow when uploading patterns. A used Mac Mini is a great choice if you have a spare keyboard and monitor to get it set up. Install Python 3.11 or later. The link has installers for common operating systems. If you have a Raspberry Pi and the version of Python is too old, try sudo apt update followed by sodu apt upgrade python3 . If that doesn't work, you may need to build Python from source or install a newer version of the Raspberry Pi operating system. If you are a Python programmer and know what a virtual environment is, I suggest you set up a virtual environment for the loom server. Otherwise don't bother. Determine your computer's host name. In a terminal run: hostname Determine the name of the port that your computer is using to connect to the loom. The first step is to make sure the loom is not connected (unplug the USB cable or turn off the loom). The next step depends on the operating system: On macOS or linux: Run this terminal command to see which USB ports are already in use, if any: ls /dev | grep -i \"tty.*usb.*\" Connect your computer to the loom with a USB cable, turn on the loom, and wait a few seconds to let it connect. Run the same command again. There should be one new entry, which is the name of the port connected to the loom. If not, wait a bit longer and try again. On Windows this may work: Open \"Device Manager\" Expand the \"Universal Serial Bus controllers\" section. Connect your computer to the loom with a USB cable, turn on the loom, and wait a few seconds to let it connect. Check for the new connection by clicking \"Action\" > \"Scan for hardware changes\". Install the loom server software. From here on I will assume you are installing toika_loom_server . For seguin_loom_server replace \"toika\" with \"seguin\". On Raspberry Pi, it is convenient to install with sudo to avoid having to hunt for the loom server executable in ~/.local/bin : sudo python -m pip install toika_loom_server On other operating systems you can probably skip sudo , and Windows does not support sudo : python -m pip install toika_loom_server In either case, watch pip's output. Near the end it should tell you where it installed run_toika_loom . Find the installed loom server executable: On macOS, Raspberry Pi (if you installed with sudo ) and most unix you can probably run the executable directly: run_toika_loom <num_shafts> mock where is the number of shafts you wish the mock loom to have. If that does not work, look at pip's output to see where it was installed. On Raspberry Pi if you did not install with sudo then it is probably here (if not, look at pip's output): ~/.local/bin/run_toika_loom <num_shafts> mock On Windows the executable will probably be buried in the Scripts subdirectory of your python installation. Again, pip's output should tell you where. If the path to the executable is long or hard to remember, consider adding the directory containing the executable to your \"PATH\", or in the case of macOS or unix, making an alias (a short word that will run the command). On macOS and unix you do this by editing a shell configuration file, which you can read about online. Here are instructions for Windows 10 . Test the loom server with the mock port: Once you have found and started the server, as above, make sure you can connect to it. Point your web browser to https://hostname.local/8000 where hostname is the host name you determined above (if the hostname ends with \".local\", don't duplicate that). Try a few things: Load one or a few weaving pattern files (which will still be there when you run with the real loom). When using the mock loom there are extra debug controls shown at the bottom of the page. One of those is a button that lets you advance to the next pick. Try that. Try changing weave direction. Try the threading panel. If you plan to weave any of the patterns you uploaded, go to the beginning before you disconnect, because the pattern database remembers where you left off weaving and threading. Run the loom server. Once you know how to run the loom server, run it with the real USB port for your loom. On macOS or unix: run_toika_loom <num_shafts> <usb_port_name> or, if it is not on the PATH: <path-to-executable>/run_toika_loom <num_shafts> <usb_port_name> On Windows: run_toika_loom.exe <num_shafts> <usb_port_name> or, if it is not on the PATH: <path-to-executable>/run_toika_loom.exe <num_shafts> <usb_port_name> is the number of shafts your loom has. This is used in two ways: Pattern files that have too many shafts are rejected. The data format used by Toika ES dobby heads varies depending on the number of shafts. If you specify the wrong value, the loom will not work correctly. The run command accepts additional options to specify the loom name, server port, etc. One option of note: --reset-db : clear all save weaving patterns. Only use this when you want a fresh start. To run more than one loom server on the same computer, specify loom-specific values for each of the following options: --db-path : path of the pattern database --port : server port For a full list of options, run the command with option --help . To upgrade to a newer version of one or more packages: python -m pip install --upgrade dtx_to_wif base_loom_server toika_loom_server (omit any packages you do not wish to upgrade). You can also specify specific versions; seee pip's documentation for details.","title":"Installing"},{"location":"installing/#installing","text":"This page gives instructions for installing a loom driver such as such as seguin_loom_server or toika_loom_server that is based on base_loom_server . See Coding if you want to work on base_loom_server or use it to develop a new loom driver. Pick your Computer Decide which computer you will use to run the loom server. Any macOS, Windows, or linux computer will work, and a laptop is a fine choice, especially as you can run your web browser on the same machine that runs the server. The software uses minimal resources, so an old, slow computer is fine. A Raspberry Pi (I suggest model 4 or better) will work, but will be a bit slow when uploading patterns. A used Mac Mini is a great choice if you have a spare keyboard and monitor to get it set up. Install Python 3.11 or later. The link has installers for common operating systems. If you have a Raspberry Pi and the version of Python is too old, try sudo apt update followed by sodu apt upgrade python3 . If that doesn't work, you may need to build Python from source or install a newer version of the Raspberry Pi operating system. If you are a Python programmer and know what a virtual environment is, I suggest you set up a virtual environment for the loom server. Otherwise don't bother. Determine your computer's host name. In a terminal run: hostname Determine the name of the port that your computer is using to connect to the loom. The first step is to make sure the loom is not connected (unplug the USB cable or turn off the loom). The next step depends on the operating system: On macOS or linux: Run this terminal command to see which USB ports are already in use, if any: ls /dev | grep -i \"tty.*usb.*\" Connect your computer to the loom with a USB cable, turn on the loom, and wait a few seconds to let it connect. Run the same command again. There should be one new entry, which is the name of the port connected to the loom. If not, wait a bit longer and try again. On Windows this may work: Open \"Device Manager\" Expand the \"Universal Serial Bus controllers\" section. Connect your computer to the loom with a USB cable, turn on the loom, and wait a few seconds to let it connect. Check for the new connection by clicking \"Action\" > \"Scan for hardware changes\". Install the loom server software. From here on I will assume you are installing toika_loom_server . For seguin_loom_server replace \"toika\" with \"seguin\". On Raspberry Pi, it is convenient to install with sudo to avoid having to hunt for the loom server executable in ~/.local/bin : sudo python -m pip install toika_loom_server On other operating systems you can probably skip sudo , and Windows does not support sudo : python -m pip install toika_loom_server In either case, watch pip's output. Near the end it should tell you where it installed run_toika_loom . Find the installed loom server executable: On macOS, Raspberry Pi (if you installed with sudo ) and most unix you can probably run the executable directly: run_toika_loom <num_shafts> mock where is the number of shafts you wish the mock loom to have. If that does not work, look at pip's output to see where it was installed. On Raspberry Pi if you did not install with sudo then it is probably here (if not, look at pip's output): ~/.local/bin/run_toika_loom <num_shafts> mock On Windows the executable will probably be buried in the Scripts subdirectory of your python installation. Again, pip's output should tell you where. If the path to the executable is long or hard to remember, consider adding the directory containing the executable to your \"PATH\", or in the case of macOS or unix, making an alias (a short word that will run the command). On macOS and unix you do this by editing a shell configuration file, which you can read about online. Here are instructions for Windows 10 . Test the loom server with the mock port: Once you have found and started the server, as above, make sure you can connect to it. Point your web browser to https://hostname.local/8000 where hostname is the host name you determined above (if the hostname ends with \".local\", don't duplicate that). Try a few things: Load one or a few weaving pattern files (which will still be there when you run with the real loom). When using the mock loom there are extra debug controls shown at the bottom of the page. One of those is a button that lets you advance to the next pick. Try that. Try changing weave direction. Try the threading panel. If you plan to weave any of the patterns you uploaded, go to the beginning before you disconnect, because the pattern database remembers where you left off weaving and threading. Run the loom server. Once you know how to run the loom server, run it with the real USB port for your loom. On macOS or unix: run_toika_loom <num_shafts> <usb_port_name> or, if it is not on the PATH: <path-to-executable>/run_toika_loom <num_shafts> <usb_port_name> On Windows: run_toika_loom.exe <num_shafts> <usb_port_name> or, if it is not on the PATH: <path-to-executable>/run_toika_loom.exe <num_shafts> <usb_port_name> is the number of shafts your loom has. This is used in two ways: Pattern files that have too many shafts are rejected. The data format used by Toika ES dobby heads varies depending on the number of shafts. If you specify the wrong value, the loom will not work correctly. The run command accepts additional options to specify the loom name, server port, etc. One option of note: --reset-db : clear all save weaving patterns. Only use this when you want a fresh start. To run more than one loom server on the same computer, specify loom-specific values for each of the following options: --db-path : path of the pattern database --port : server port For a full list of options, run the command with option --help . To upgrade to a newer version of one or more packages: python -m pip install --upgrade dtx_to_wif base_loom_server toika_loom_server (omit any packages you do not wish to upgrade). You can also specify specific versions; seee pip's documentation for details.","title":"Installing"},{"location":"settings/","text":"Settings The Settings allows you to specify settings that apply to all weaving patterns. Settings are automatically saved, and should survive rebooting the loom server. Settings include: Language : which language to use. A language is listed as \"preliminary\" (in that language) if the translation is not well vetted. As of June, 2025 there are only two translations, both preliminary. Your help to improve existing translations or provide new ones would be much appreciated. Read Translations for more information. Note that changing languages reloads the page, but this should be fast and harmless. Loom name : the name of the loom, as it appears in the display. Use any name you like; it is just for display. Direction control : specify how to change direction (weaving or unweaving, threading or unthreading). See Weave Direction for more information. This setting is not shown for S\u00e9guin looms and others that support changing direction from both software and a button on the loom. Warp end 1 : specify whether to display warp end 1 on the right or left in the Weaving and Threading pattern displays. However, this is as seen from the front of the loom . If you specify threading front-to-back, the threading pattern is displayed as seen from the back of the loom, so end 1 will be on the opposite side than what you specify here. Threading : specify whether you prefer to thread right-to-left or left-to-right, and front-to-back or back-to-front. Specifying front-to-back simply changes the Threading pattern display to appear as if you are sitting behind the castle: shaft 1 is displayed at the top and warp end 1 is displayed on the opposite side of that specified in \"Warp end 1`\". Default threading group size : specify the threading group size for newly uploaded patterns. This setting has no effect on any pattern files that are already loaded; use the \"Group size\" control in the Threading panel to change those.","title":"Settings"},{"location":"settings/#settings","text":"The Settings allows you to specify settings that apply to all weaving patterns. Settings are automatically saved, and should survive rebooting the loom server. Settings include: Language : which language to use. A language is listed as \"preliminary\" (in that language) if the translation is not well vetted. As of June, 2025 there are only two translations, both preliminary. Your help to improve existing translations or provide new ones would be much appreciated. Read Translations for more information. Note that changing languages reloads the page, but this should be fast and harmless. Loom name : the name of the loom, as it appears in the display. Use any name you like; it is just for display. Direction control : specify how to change direction (weaving or unweaving, threading or unthreading). See Weave Direction for more information. This setting is not shown for S\u00e9guin looms and others that support changing direction from both software and a button on the loom. Warp end 1 : specify whether to display warp end 1 on the right or left in the Weaving and Threading pattern displays. However, this is as seen from the front of the loom . If you specify threading front-to-back, the threading pattern is displayed as seen from the back of the loom, so end 1 will be on the opposite side than what you specify here. Threading : specify whether you prefer to thread right-to-left or left-to-right, and front-to-back or back-to-front. Specifying front-to-back simply changes the Threading pattern display to appear as if you are sitting behind the castle: shaft 1 is displayed at the top and warp end 1 is displayed on the opposite side of that specified in \"Warp end 1`\". Default threading group size : specify the threading group size for newly uploaded patterns. This setting has no effect on any pattern files that are already loaded; use the \"Group size\" control in the Threading panel to change those.","title":"Settings"},{"location":"threading/","text":"Threading The threading mode helps you correctly thread warp strings through the heddles. Every time you press the pedal, the loom will raise the next group of shafts and a display will show you which threads belong on which shaft. This page assumes you have done all the basics : Connected your web browser to the loom server Uploaded at least one pattern, and selected a pattern from the pattern menu Selected the Threading mode. Threading Direction The Settings panel contains two settings specific to threading: Thread from right-to-left or left-to-right. Thread from back-to-front or front-to-back, which this only affects the display. Front-to-back mode rotates the pattern 180 degrees, as if seen from the back of the loom: shaft 1 is at the bottom, and warp end 1 is at the other edge than specified by the \"Warp end 1 on\" setting . Threading Display Threading is displayed as a picture that shows a group of threads (vertical colored bars) and the shaft they go through (numbers that interrupt the colored bars). It also shows warp end numbers above some threads. If \"Separate repeats?\" is checked you will see a gap between unthreaded repeats. See Repeating for more information. Special cases that may only be supported by WIF files: Ends that are only threaded on shaft 0 (meaning not threaded through heddles on any shaft) are displayed without a shaft number. Ends that are threaded through heddles on more than one shaft are only shown threaded on the lowest-numbered shaft (ignoring non-existent shaft 0). Threading Direction See Weave Direction for information on changing between threading and unthreading. If you are using a Toika loom, you must specify whether Software or the Loom controls threading direction in Settings . If you thread front-to-back, consider specifying Software, because it may be difficult to reach the REVERSE button on the dobby head from behind the castle. Jumping You can jump to a different group of warp ends, specified by the smaller warp end number. For example if the group size is 4 and you jump to end 21, the new ends will be 21, 22, 23, 24, and 25 (or fewer, if the warp has fewer than 25 threads), regardless of the threading direction. Jumping is a two-step process: first you request the jump, then you advance to it by pressing the loom's pedal. (Two steps are necessary because most looms will not accept an unsolicited command to raise shafts.) In detail: Enter the desired warp end number in the box to the right of \"Jump to end\". The box will turn pink and the Jump button will be enabled. Press the \"return\" keyboard key or click the \"Jump\" button on the web page to send the requested jump to the server. You will see several changes: The jump input box will have a white background and the jump button will be disabled. The pattern display will show the new thread group, with a dotted box around it. Advance to the next group by pressing the loom's pedal. Until you advance to the next group, you may request a different jump (in case you got it wrong the first time) or cancel the jump. To cancel the jump you may do any of the following: Press the \"Reset\" button to the right of \"Jump\". Reload the page. Select a new pattern. Group Size The \"Group size\" menu selects how many warp ends are in a group, All shafts for a group are raised at once. You can change the group size whenever you like; the change takes effect for the next thread group (next time you push the pedal to advance). Repeating The software will automatically repeat threading if you thread beyond the end. However, like Weaving , the transition depends on the \"Separate repeats?\" checkbox: \"On\" (checked): you must advance twice when you reach an end, before the next set of shafts is raised. The first advance will lower all shafts, as a signal that you have finished threading or unthreading one pattern repeat. That is the \"separator\". \"Off\" (unchecked): there is no indication that you have reached the end of threading. The next advance will start the next repeat of threading or unthreading. The default value of \"Separate repeats?\" is checked (on) if the pattern has more than 20 warp threads, unchecked (off) otherwise. The idea is that frequent separator \"picks\" are annoying for short threading sequences, but having a separator \"pick\" is useful for long sequences. Note that the value of the Weaving and Threading \"Separate repeats?\" checkboxes are independent of each other, and may also be different for different patterns. They are saved in the pattern database.","title":"Threading"},{"location":"threading/#threading","text":"The threading mode helps you correctly thread warp strings through the heddles. Every time you press the pedal, the loom will raise the next group of shafts and a display will show you which threads belong on which shaft. This page assumes you have done all the basics : Connected your web browser to the loom server Uploaded at least one pattern, and selected a pattern from the pattern menu Selected the Threading mode.","title":"Threading"},{"location":"threading/#threading-direction","text":"The Settings panel contains two settings specific to threading: Thread from right-to-left or left-to-right. Thread from back-to-front or front-to-back, which this only affects the display. Front-to-back mode rotates the pattern 180 degrees, as if seen from the back of the loom: shaft 1 is at the bottom, and warp end 1 is at the other edge than specified by the \"Warp end 1 on\" setting .","title":"Threading Direction"},{"location":"threading/#threading-display","text":"Threading is displayed as a picture that shows a group of threads (vertical colored bars) and the shaft they go through (numbers that interrupt the colored bars). It also shows warp end numbers above some threads. If \"Separate repeats?\" is checked you will see a gap between unthreaded repeats. See Repeating for more information. Special cases that may only be supported by WIF files: Ends that are only threaded on shaft 0 (meaning not threaded through heddles on any shaft) are displayed without a shaft number. Ends that are threaded through heddles on more than one shaft are only shown threaded on the lowest-numbered shaft (ignoring non-existent shaft 0).","title":"Threading Display"},{"location":"threading/#threading-direction_1","text":"See Weave Direction for information on changing between threading and unthreading. If you are using a Toika loom, you must specify whether Software or the Loom controls threading direction in Settings . If you thread front-to-back, consider specifying Software, because it may be difficult to reach the REVERSE button on the dobby head from behind the castle.","title":"Threading Direction"},{"location":"threading/#jumping","text":"You can jump to a different group of warp ends, specified by the smaller warp end number. For example if the group size is 4 and you jump to end 21, the new ends will be 21, 22, 23, 24, and 25 (or fewer, if the warp has fewer than 25 threads), regardless of the threading direction. Jumping is a two-step process: first you request the jump, then you advance to it by pressing the loom's pedal. (Two steps are necessary because most looms will not accept an unsolicited command to raise shafts.) In detail: Enter the desired warp end number in the box to the right of \"Jump to end\". The box will turn pink and the Jump button will be enabled. Press the \"return\" keyboard key or click the \"Jump\" button on the web page to send the requested jump to the server. You will see several changes: The jump input box will have a white background and the jump button will be disabled. The pattern display will show the new thread group, with a dotted box around it. Advance to the next group by pressing the loom's pedal. Until you advance to the next group, you may request a different jump (in case you got it wrong the first time) or cancel the jump. To cancel the jump you may do any of the following: Press the \"Reset\" button to the right of \"Jump\". Reload the page. Select a new pattern.","title":"Jumping"},{"location":"threading/#group-size","text":"The \"Group size\" menu selects how many warp ends are in a group, All shafts for a group are raised at once. You can change the group size whenever you like; the change takes effect for the next thread group (next time you push the pedal to advance).","title":"Group Size"},{"location":"threading/#repeating","text":"The software will automatically repeat threading if you thread beyond the end. However, like Weaving , the transition depends on the \"Separate repeats?\" checkbox: \"On\" (checked): you must advance twice when you reach an end, before the next set of shafts is raised. The first advance will lower all shafts, as a signal that you have finished threading or unthreading one pattern repeat. That is the \"separator\". \"Off\" (unchecked): there is no indication that you have reached the end of threading. The next advance will start the next repeat of threading or unthreading. The default value of \"Separate repeats?\" is checked (on) if the pattern has more than 20 warp threads, unchecked (off) otherwise. The idea is that frequent separator \"picks\" are annoying for short threading sequences, but having a separator \"pick\" is useful for long sequences. Note that the value of the Weaving and Threading \"Separate repeats?\" checkboxes are independent of each other, and may also be different for different patterns. They are saved in the pattern database.","title":"Repeating"},{"location":"translations/","text":"Translations base_loom_server supports foreign language translations (for the web display, but not this documentation). At present only a few translations are available, and none have been properly vetted. Help from others to improve the existing translations and add new ones would be most welcome. Weaving terminology is somewhat obscure, so translation tools may miss important subtleties. Each language is supported by a separate json file in src/locales . The name of each translation file is the native name of the language, for example Fran\u00e7ais.json . The file src/locales/default.json lists all the words and phrases for which translations are wanted. the values are context, which are purely intended to help the translator understand the word or phrase; they are ignored by the software. In addition to those entries there are a few metadata keys . The keys in the translation files are the same as in default.json , but the values are the translated word or phrase. One way to start is to copy src/locales/default.json to the new language file, then replace each context string with the translated string. To add or change translation files, fork the project on github. If you are not confident of your translations, please append \" (preliminary)\", suitably translated, to the name. For example: \"Franc\u0327ais (pre\u0301liminaire).json\". An incomplete file is better than none. Missing entries will be shown in English. Metadata Keys There are several optional keys that provide metadata: _direction : whether the language is read left-to-right (value ltr , the default) or right-to-left (value rtl ). _extends : the name of another language file of which this is a variant, without the \".json\" suffix. If you specify _extends then you need only specify the items that differ from the file named in _extends . For example file Qu\u00e9b\u00e9cois.json could specify \"_extends\"=\"Fran\u00e7ais\" . _language_code : the ISO 639-1 language code for the language, e.g. fr for Fran\u00e7ais . Here is one list . This may help text-to-speech software. If omitted the value is \"en\".","title":"Translations"},{"location":"translations/#translations","text":"base_loom_server supports foreign language translations (for the web display, but not this documentation). At present only a few translations are available, and none have been properly vetted. Help from others to improve the existing translations and add new ones would be most welcome. Weaving terminology is somewhat obscure, so translation tools may miss important subtleties. Each language is supported by a separate json file in src/locales . The name of each translation file is the native name of the language, for example Fran\u00e7ais.json . The file src/locales/default.json lists all the words and phrases for which translations are wanted. the values are context, which are purely intended to help the translator understand the word or phrase; they are ignored by the software. In addition to those entries there are a few metadata keys . The keys in the translation files are the same as in default.json , but the values are the translated word or phrase. One way to start is to copy src/locales/default.json to the new language file, then replace each context string with the translated string. To add or change translation files, fork the project on github. If you are not confident of your translations, please append \" (preliminary)\", suitably translated, to the name. For example: \"Franc\u0327ais (pre\u0301liminaire).json\". An incomplete file is better than none. Missing entries will be shown in English.","title":"Translations"},{"location":"translations/#metadata-keys","text":"There are several optional keys that provide metadata: _direction : whether the language is read left-to-right (value ltr , the default) or right-to-left (value rtl ). _extends : the name of another language file of which this is a variant, without the \".json\" suffix. If you specify _extends then you need only specify the items that differ from the file named in _extends . For example file Qu\u00e9b\u00e9cois.json could specify \"_extends\"=\"Fran\u00e7ais\" . _language_code : the ISO 639-1 language code for the language, e.g. fr for Fran\u00e7ais . Here is one list . This may help text-to-speech software. If omitted the value is \"en\".","title":"Metadata Keys"},{"location":"version_history/","text":"Version History 0.27 Changes for maintainers and authors of loom-specific packages: Refactor testutils: Client is a normal class, instead of a dataclass, and the free functions that took a Client as the first argument are now methods that class. Unit tests that use internal details of testutils may need some changes, but not if the code simply uses BaseTestLoomServer to test the loom server. Some functions now require named arguments for most or all arguments. This especially applies to methods with boolean arguments and/or many arguments. Improve mypy configuration to make it pickier and to allow it to be run with mypy . . Switch to ruff for checking and formatting. 0.26.1 2025-07-06 Add screen shots to the documentation. Add a \"Hide\" button to the debug controls that are shown when using a mock loom. This makes it easier to see what the display will look like with a real loom. Refresh the display to restore the debug controls. Changes for maintainers and authors of loom-specific packages: Change the type hint for BaseLoomServer.__aenter__ and BaseMockLoom.__aenter__ to typing.Self . This makes it easier to write an async context manager that returns a subclass, since you can now specify the actual subclass returned. 0.26 2025-07-05 Add a Language setting to the Settings panel. Properly support right-to-left languages. Increased the size of checkboxes. Changes for maintainers and authors of loom-specific packages: Warning: most loom-specific packages will need trivial changes, including toika_loom_server and seguin_loom_server . BaseLoomServer and subclasses no longer have the translation_dict constructor argument. As a result, loom-specific packages that override the constructor must be updated. You can simply delete that one constructor argument, but it is better to replace the entire constructor override with an override of the new __post_init__ method, as per the next item. Added __post__init__ methods to both BaseLoomServer and BaseMockLoom . These methods take no arguments and return None. They are intended to eliminate the need to override the constructor, which eliminates the duplication of constructor arguments, making it less likely that future changes will be needed as base_loom_server evolves. For example toika_loom_server 's LoomServer and MockLoom classes use this method to check that the number of shafts is a multiple of 8 (as required by Toika's API). Changed the language translation files as follows (see Translations for details): Each file name is the native name of the language, rather than the language code. Added a few metadata entries. 0.25 2025-07-02 Add a help link. Threading display improvements: Show threaded ends darker than unthreaded ends. Show repeats, if there is room. Fix two links in the documentation. 0.24 2025-06-26 Prohibit weaving or threading beyond the beginning of the pattern. Eliminate the faint ghost display of picks < 0 in the Weaving panel. It is no longer as useful and was potentially confusing. Bug fix: threading direction did not take the new end1_on_right setting into account. Bug fix: status messages were not displayed. Changes for maintainers and authors of loom-specific packages: Added a command-line script check_translation_files to check the completeness of language translation files. BaseLoomServer.handle_next_pick_request now returns a boolean indicating whether or not a new shed was sent to the loom. Loom-specific software for looms that do not report shaft state (e.g. Toika) should use this to decide whether or not to report the shaft state. 0.23.1 2025-06-25 Fix display of setting \"warp end 1\"; it was not updated based on the reported value. 0.23 2025-06-23 Add a setting to show warp end 1 on the right or left. 0.22 2025-06-20 Display shaft state graphically. Improve display when changing orientation between portrait and landscape. 0.21.3 2025-06-18 Bug fix: if the loom controlled direction, and the direction was forward, text for the direction buttons was gray, instead of black. 0.21.2 2025-06-17 Bug fixes for uploading patterns: The Upload button had no effect if used to upload the same file twice. When uploading a file whose name matched the current file, the old version was still displayed. After drag-and-drop, restore the correct background color. 0.20.1 2025-06-17 Fix a bug in the Settings panel triggered by the server being pickier about data types. 0.20.0 2025-06-17 Improve the Weaving pattern display: Show pattern over the entire height, showing pattern repeats, if needed, to fill the space. Woven parts (in the bottom half) will be dark. Rows with negative pick numbers are shown very lightly, as a hint as to the overall pattern. If \"Separate repeats\" is checked, show gaps in the unwoven part in the top half (but not the woven part below). You can see the effect by jumping ahead far enough that the end of a repeat is shown in the top half, then checking and unchecking the \"Separate repeats\" box. Provide context in the translation file \"default.json\" to aid translators. Make settings handling more robust and add unit tests for it. 0.19.4 2025-06-11 Bug fixes in Threading: End numbers were not shown when displaying end 0. When a jump is pending, the \"Jump to end\" input box now shows the total end number (the same value you typed in), rather than the end number within the current pattern repeat. Change the threading display to show total end numbers along the top, rather than end numbers within the current pattern repeat. Further improve the display of the tab bar at the top of the window. Improve the display of popup menus, such as the Pattern menu. Improve the display of text input areas, such as \"Jump to pick\". For most controls with labels, you can now click on the label to activate the control. This is especially helpful for the \"Separate repeats?\" checkboxes. Specify the language in the HTML. This will be English, unless a translation file is present for the current locale. Fix some HTML errors (though few, if any, were visible). 0.19.3 2025-06-07 Improve the display of the tab bar at the top of the window. 0.19.2 2025-06-07 Improve the display of direction controls. 0.19.1 2025-06-04 Add missing translation strings. 0.19.0 2025-06-3 Add a new Settings panel which allows you to specify loom name, direction control, and new threading settings. Enhance threading support by adding settings for: Thread right-to-left or left-to-right. Thread back-to-front or front-to-back. The defalt threading group size for newly loaded patterns. Automatically reset the pattern database if it changes in an incompatible way. Store the pattern database and new settings file in your home directory, instead of a temporary directory, so that the files will survive a reboot. Breaking change : remove command-line arguments \"name\" and \"direction-control\". Use the new Settings panel, instead. 0.18.3 2025-05-25 Expand unit tests. 0.18.2 2025-05-03 Add API documentation. 0.18.1 2025-04-28 Show the correct threading group size when you connect. 0.18.0 2025-04-28 Improve the threading display: Center the current group, even for patterns with short threading repeats. For ends not threaded on any shaft just show the thread without a shaft number. Formerly a truncated 0 was shown. Showing a whole 0 is possible, but likely more confusing. Remove a source of flicker by only updating the visible pattern. 0.17.0 2025-04-27 Try to prevent an unwanted stale next-pick request when the loom server connects to the loom (which is when a user connects to the server). Do this by purging the read buffer. 0.16.0 2025-04-25 Display total picks in Weaving and total ends in Threading. Also jump to total picks in Weaving and total ends in Threading. 0.15.0 2025-04-19 Save threading group size with each pattern. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database. Add a version history to the documentation. 0.14.0 2025-04-18 Display improvements: Avoid scroll bars, if possible. Make font size vary somewhat with window size. Avoid the search bar and tab controls at the bottom of the iPhone. In Threading move Group size to the right of Direction, to save space. 0.13.0 2025-04-18 Display improvements: Resize the weaving and threading pattern display to fill available space. Move the direction control and (for weaving) pick color, for easier access. 0.12.1 2025-04-14 Small display improvements. 0.12.0 2025-04-03 Support WeavePoint .wpo files. Improve the display of white threads. 0.11.0 2025-04-02 Add a preliminary Finnish translation. Fix a few issues with the installation instructions (especially those related to finding the loom's USB port on unix and macOS). Thanks to Kalle Pihlajasaari for the translation and the doc bug reports. 0.10.0 2025-03-18 Add a Separate repeats checkbox to Weaving and Threading to control whether to include a separator pick (all shafts down) between repeats of weaving or threading. The weaving and threading values are independent of each other, and are saved per pattern in the database. The intial value for weaving/threading is \"on\" if the number of picks/ends > 20, else \"off\". The idea being that the extra advance is helpful for long sequenced, but annoying for short sequences. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database. 0.9.1 2025-03-18 Display loom name and # shafts. Improve error handling if a pattern file cannot be parsed. 0.9.0 2025-03-14 Add required command-line argument num_shafts. This is needed in order for toika_loom_server to work correctly. 0.8.1 2025-03-05 Improve the fix for the Windows encoding issue. 0.8.0 2025-03-05 Work around an encoding issue on Windows. 0.7.1 2026-02-21 Fix a bug in the first threading group when threading high to low. Improve the threading display. 0.7.0 2025-02-21 Add support for unterminated loom I/O. This is needed for Toika looms. 0.6.0 2025-02-17 Improve support for Toika looms, and others that do not report direction. Improve server unit tests. 0.5.2 2025-02-21 Update URLS in pyproject.toml. 0.5.1 2025-02-16 Add mkdocs-based documentation. 0.5.0 2025-02-16 Add support for threading. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database. 0.4.0 2025-02-13 Fix a bug that showed up with 32 or more shafts: JavaScript bitwise operations were failing for large values of shaft_word (due to a notorious misfeature of JavaScript). 0.3.0 2025-02-08 Add threading fields to the pattern database. This is preliminary work to add a user interface to assist in threading the loom. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database. 0.2.1 2025-02-06 Improve dependencies to properly bring in uvicorn. Improve the README to suggest that developers install with '[dev]'. 0.2 2025-02-05 Fix a display bug: patterns at pick 0 could not be displayed, due to an undefined variable. 0.1 2025-02-03 Initial prerelease.","title":"Version History"},{"location":"version_history/#version-history","text":"","title":"Version History"},{"location":"version_history/#027","text":"Changes for maintainers and authors of loom-specific packages: Refactor testutils: Client is a normal class, instead of a dataclass, and the free functions that took a Client as the first argument are now methods that class. Unit tests that use internal details of testutils may need some changes, but not if the code simply uses BaseTestLoomServer to test the loom server. Some functions now require named arguments for most or all arguments. This especially applies to methods with boolean arguments and/or many arguments. Improve mypy configuration to make it pickier and to allow it to be run with mypy . . Switch to ruff for checking and formatting.","title":"0.27"},{"location":"version_history/#0261-2025-07-06","text":"Add screen shots to the documentation. Add a \"Hide\" button to the debug controls that are shown when using a mock loom. This makes it easier to see what the display will look like with a real loom. Refresh the display to restore the debug controls. Changes for maintainers and authors of loom-specific packages: Change the type hint for BaseLoomServer.__aenter__ and BaseMockLoom.__aenter__ to typing.Self . This makes it easier to write an async context manager that returns a subclass, since you can now specify the actual subclass returned.","title":"0.26.1 2025-07-06"},{"location":"version_history/#026-2025-07-05","text":"Add a Language setting to the Settings panel. Properly support right-to-left languages. Increased the size of checkboxes. Changes for maintainers and authors of loom-specific packages: Warning: most loom-specific packages will need trivial changes, including toika_loom_server and seguin_loom_server . BaseLoomServer and subclasses no longer have the translation_dict constructor argument. As a result, loom-specific packages that override the constructor must be updated. You can simply delete that one constructor argument, but it is better to replace the entire constructor override with an override of the new __post_init__ method, as per the next item. Added __post__init__ methods to both BaseLoomServer and BaseMockLoom . These methods take no arguments and return None. They are intended to eliminate the need to override the constructor, which eliminates the duplication of constructor arguments, making it less likely that future changes will be needed as base_loom_server evolves. For example toika_loom_server 's LoomServer and MockLoom classes use this method to check that the number of shafts is a multiple of 8 (as required by Toika's API). Changed the language translation files as follows (see Translations for details): Each file name is the native name of the language, rather than the language code. Added a few metadata entries.","title":"0.26 2025-07-05"},{"location":"version_history/#025-2025-07-02","text":"Add a help link. Threading display improvements: Show threaded ends darker than unthreaded ends. Show repeats, if there is room. Fix two links in the documentation.","title":"0.25 2025-07-02"},{"location":"version_history/#024-2025-06-26","text":"Prohibit weaving or threading beyond the beginning of the pattern. Eliminate the faint ghost display of picks < 0 in the Weaving panel. It is no longer as useful and was potentially confusing. Bug fix: threading direction did not take the new end1_on_right setting into account. Bug fix: status messages were not displayed. Changes for maintainers and authors of loom-specific packages: Added a command-line script check_translation_files to check the completeness of language translation files. BaseLoomServer.handle_next_pick_request now returns a boolean indicating whether or not a new shed was sent to the loom. Loom-specific software for looms that do not report shaft state (e.g. Toika) should use this to decide whether or not to report the shaft state.","title":"0.24 2025-06-26"},{"location":"version_history/#0231-2025-06-25","text":"Fix display of setting \"warp end 1\"; it was not updated based on the reported value.","title":"0.23.1 2025-06-25"},{"location":"version_history/#023-2025-06-23","text":"Add a setting to show warp end 1 on the right or left.","title":"0.23 2025-06-23"},{"location":"version_history/#022-2025-06-20","text":"Display shaft state graphically. Improve display when changing orientation between portrait and landscape.","title":"0.22 2025-06-20"},{"location":"version_history/#0213-2025-06-18","text":"Bug fix: if the loom controlled direction, and the direction was forward, text for the direction buttons was gray, instead of black.","title":"0.21.3 2025-06-18"},{"location":"version_history/#0212-2025-06-17","text":"Bug fixes for uploading patterns: The Upload button had no effect if used to upload the same file twice. When uploading a file whose name matched the current file, the old version was still displayed. After drag-and-drop, restore the correct background color.","title":"0.21.2 2025-06-17"},{"location":"version_history/#0201-2025-06-17","text":"Fix a bug in the Settings panel triggered by the server being pickier about data types.","title":"0.20.1 2025-06-17"},{"location":"version_history/#0200-2025-06-17","text":"Improve the Weaving pattern display: Show pattern over the entire height, showing pattern repeats, if needed, to fill the space. Woven parts (in the bottom half) will be dark. Rows with negative pick numbers are shown very lightly, as a hint as to the overall pattern. If \"Separate repeats\" is checked, show gaps in the unwoven part in the top half (but not the woven part below). You can see the effect by jumping ahead far enough that the end of a repeat is shown in the top half, then checking and unchecking the \"Separate repeats\" box. Provide context in the translation file \"default.json\" to aid translators. Make settings handling more robust and add unit tests for it.","title":"0.20.0 2025-06-17"},{"location":"version_history/#0194-2025-06-11","text":"Bug fixes in Threading: End numbers were not shown when displaying end 0. When a jump is pending, the \"Jump to end\" input box now shows the total end number (the same value you typed in), rather than the end number within the current pattern repeat. Change the threading display to show total end numbers along the top, rather than end numbers within the current pattern repeat. Further improve the display of the tab bar at the top of the window. Improve the display of popup menus, such as the Pattern menu. Improve the display of text input areas, such as \"Jump to pick\". For most controls with labels, you can now click on the label to activate the control. This is especially helpful for the \"Separate repeats?\" checkboxes. Specify the language in the HTML. This will be English, unless a translation file is present for the current locale. Fix some HTML errors (though few, if any, were visible).","title":"0.19.4 2025-06-11"},{"location":"version_history/#0193-2025-06-07","text":"Improve the display of the tab bar at the top of the window.","title":"0.19.3 2025-06-07"},{"location":"version_history/#0192-2025-06-07","text":"Improve the display of direction controls.","title":"0.19.2 2025-06-07"},{"location":"version_history/#0191-2025-06-04","text":"Add missing translation strings.","title":"0.19.1 2025-06-04"},{"location":"version_history/#0190-2025-06-3","text":"Add a new Settings panel which allows you to specify loom name, direction control, and new threading settings. Enhance threading support by adding settings for: Thread right-to-left or left-to-right. Thread back-to-front or front-to-back. The defalt threading group size for newly loaded patterns. Automatically reset the pattern database if it changes in an incompatible way. Store the pattern database and new settings file in your home directory, instead of a temporary directory, so that the files will survive a reboot. Breaking change : remove command-line arguments \"name\" and \"direction-control\". Use the new Settings panel, instead.","title":"0.19.0 2025-06-3"},{"location":"version_history/#0183-2025-05-25","text":"Expand unit tests.","title":"0.18.3 2025-05-25"},{"location":"version_history/#0182-2025-05-03","text":"Add API documentation.","title":"0.18.2 2025-05-03"},{"location":"version_history/#0181-2025-04-28","text":"Show the correct threading group size when you connect.","title":"0.18.1 2025-04-28"},{"location":"version_history/#0180-2025-04-28","text":"Improve the threading display: Center the current group, even for patterns with short threading repeats. For ends not threaded on any shaft just show the thread without a shaft number. Formerly a truncated 0 was shown. Showing a whole 0 is possible, but likely more confusing. Remove a source of flicker by only updating the visible pattern.","title":"0.18.0 2025-04-28"},{"location":"version_history/#0170-2025-04-27","text":"Try to prevent an unwanted stale next-pick request when the loom server connects to the loom (which is when a user connects to the server). Do this by purging the read buffer.","title":"0.17.0 2025-04-27"},{"location":"version_history/#0160-2025-04-25","text":"Display total picks in Weaving and total ends in Threading. Also jump to total picks in Weaving and total ends in Threading.","title":"0.16.0 2025-04-25"},{"location":"version_history/#0150-2025-04-19","text":"Save threading group size with each pattern. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database. Add a version history to the documentation.","title":"0.15.0 2025-04-19"},{"location":"version_history/#0140-2025-04-18","text":"Display improvements: Avoid scroll bars, if possible. Make font size vary somewhat with window size. Avoid the search bar and tab controls at the bottom of the iPhone. In Threading move Group size to the right of Direction, to save space.","title":"0.14.0 2025-04-18"},{"location":"version_history/#0130-2025-04-18","text":"Display improvements: Resize the weaving and threading pattern display to fill available space. Move the direction control and (for weaving) pick color, for easier access.","title":"0.13.0 2025-04-18"},{"location":"version_history/#0121-2025-04-14","text":"Small display improvements.","title":"0.12.1 2025-04-14"},{"location":"version_history/#0120-2025-04-03","text":"Support WeavePoint .wpo files. Improve the display of white threads.","title":"0.12.0 2025-04-03"},{"location":"version_history/#0110-2025-04-02","text":"Add a preliminary Finnish translation. Fix a few issues with the installation instructions (especially those related to finding the loom's USB port on unix and macOS). Thanks to Kalle Pihlajasaari for the translation and the doc bug reports.","title":"0.11.0 2025-04-02"},{"location":"version_history/#0100-2025-03-18","text":"Add a Separate repeats checkbox to Weaving and Threading to control whether to include a separator pick (all shafts down) between repeats of weaving or threading. The weaving and threading values are independent of each other, and are saved per pattern in the database. The intial value for weaving/threading is \"on\" if the number of picks/ends > 20, else \"off\". The idea being that the extra advance is helpful for long sequenced, but annoying for short sequences. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database.","title":"0.10.0 2025-03-18"},{"location":"version_history/#091-2025-03-18","text":"Display loom name and # shafts. Improve error handling if a pattern file cannot be parsed.","title":"0.9.1 2025-03-18"},{"location":"version_history/#090-2025-03-14","text":"Add required command-line argument num_shafts. This is needed in order for toika_loom_server to work correctly.","title":"0.9.0 2025-03-14"},{"location":"version_history/#081-2025-03-05","text":"Improve the fix for the Windows encoding issue.","title":"0.8.1 2025-03-05"},{"location":"version_history/#080-2025-03-05","text":"Work around an encoding issue on Windows.","title":"0.8.0 2025-03-05"},{"location":"version_history/#071-2026-02-21","text":"Fix a bug in the first threading group when threading high to low. Improve the threading display.","title":"0.7.1 2026-02-21"},{"location":"version_history/#070-2025-02-21","text":"Add support for unterminated loom I/O. This is needed for Toika looms.","title":"0.7.0 2025-02-21"},{"location":"version_history/#060-2025-02-17","text":"Improve support for Toika looms, and others that do not report direction. Improve server unit tests.","title":"0.6.0 2025-02-17"},{"location":"version_history/#052-2025-02-21","text":"Update URLS in pyproject.toml.","title":"0.5.2 2025-02-21"},{"location":"version_history/#051-2025-02-16","text":"Add mkdocs-based documentation.","title":"0.5.1 2025-02-16"},{"location":"version_history/#050-2025-02-16","text":"Add support for threading. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database.","title":"0.5.0 2025-02-16"},{"location":"version_history/#040-2025-02-13","text":"Fix a bug that showed up with 32 or more shafts: JavaScript bitwise operations were failing for large values of shaft_word (due to a notorious misfeature of JavaScript).","title":"0.4.0 2025-02-13"},{"location":"version_history/#030-2025-02-08","text":"Add threading fields to the pattern database. This is preliminary work to add a user interface to assist in threading the loom. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database.","title":"0.3.0 2025-02-08"},{"location":"version_history/#021-2025-02-06","text":"Improve dependencies to properly bring in uvicorn. Improve the README to suggest that developers install with '[dev]'.","title":"0.2.1 2025-02-06"},{"location":"version_history/#02-2025-02-05","text":"Fix a display bug: patterns at pick 0 could not be displayed, due to an undefined variable.","title":"0.2 2025-02-05"},{"location":"version_history/#01-2025-02-03","text":"Initial prerelease.","title":"0.1 2025-02-03"},{"location":"weaving/","text":"Weaving This page assumes you have done all the basics : Connected your web browser to the loom server Uploaded at least one pattern, and selected a pattern from the pattern menu Selected the Weaving mode. Pattern Display The pattern is displayed as a picture that shows woven fabric in the bottom half, and potential future fabric, somewhat grayed out, in the top half. The unwoven fabric will include a gap between each pattern repeat if \"Separate repeats?\" is checked. See Repeating for more information. A setting allows you to specify whether warp end 1 is shown at the right or left. Note that the display is naive; it shows all threads as the same thickness, and does not display multi-layer patterns, such as doubleweave, correctly. Weave Direction The Weaving \"Direction\" button shows \"Weave\" (in black) or \"Unweave\" (in red). Threading also has a direction button that shows \"Thread\" (in black) or \"Unthread\" (in red), prefixed by an arrow showing the direction of the next group of warp ends. How you change direction depends on the loom: S\u00e9guin looms allow you to change direction by pressing the direction button in web browser display, or pressing the UNW button on the dobby unit. Both work equally well; use whichever you prefer. Toika looms can be operated in one of two ways, specified by Direction control in the Settings panel: Software : push the direction button (Weave/Unweave if weaving, Thread/Unthread if threading) in the web browser display to change direction. The physical REVERSE button on the dobby head is ignored. Loom : press the physical REVERSE button on the dobby head to change direction. Warning: the displayed direction does not update until you command the next pick! This is because Toika looms only report direction when requesting a pick. For other looms, see the loom-specific documentation with the software package. Pick Color The long colored rectangle to the right of Pick shows the color of the current pick (blank for pick 0), or, if you have specified a pick to jump to, then it is the color of that pending pick. Jumping You can jump to a different pick. Jumping is a two-step process: first you request the jump, then you advance to it by pressing the loom's pedal. (Two steps are necessary because most looms will not accept an unsolicited command to raise shafts.) In detail: Enter the desired pick in the box on the \"Jump to pick\" line. The box will turn pink and the Jump button will be enabled. Press the \"return\" keyboard key or click the \"Jump\" button on the web page to send the requested jump to the server. You will see several changes: The jump input box will have a white background and the jump button will be disabled. The pattern display will show the jump-to pick in the center row, with a dotted box around it. Advance to the next pick by pressing the loom's pedal. Until you advance to the next pick, you may request a different jump (in case you got it wrong the first time) or cancel it. To cancel the jump you may do any of the following: Press the \"Reset\" button to the right of \"Jump\". Reload the page. Select a new pattern. Repeating The software will automatically repeat patterns if you weave or unweave beyond the end. The exact behavior is controlled by the \"Separate repeats?\" checkbox: \"On\" (checked): you must advance twice when you reach an end, before the next set of shafts is raised. The first advance will lower all shafts, as a signal that you have finished weaving or unweaving one pattern repeat. That is the \"separator\". This will be displayed as a blank row in the center of the pattern display, and also between repeats in the display of unwoven fabric above the center. \"Off\" (unchecked): there is no indication that you have reached the end of the pattern. The next pick will be pick 1 of the pattern, if weaving, or the last pick, if unweaving. The default value of \"Separate repeats?\" is checked (on) if the pattern has more than 20 picks, unchecked (off) otherwise. The idea is that frequent separator picks are annoying for short patterns, but having a separator pick is useful for long patterns. Threading has a checkbox with the same name that does the same basic thing. However, the value of the Weaving and Threading \"Separate repeats?\" checkboxes are independent of each other, and may also be different for different patterns. They are saved in the pattern database.","title":"Weaving"},{"location":"weaving/#weaving","text":"This page assumes you have done all the basics : Connected your web browser to the loom server Uploaded at least one pattern, and selected a pattern from the pattern menu Selected the Weaving mode.","title":"Weaving"},{"location":"weaving/#pattern-display","text":"The pattern is displayed as a picture that shows woven fabric in the bottom half, and potential future fabric, somewhat grayed out, in the top half. The unwoven fabric will include a gap between each pattern repeat if \"Separate repeats?\" is checked. See Repeating for more information. A setting allows you to specify whether warp end 1 is shown at the right or left. Note that the display is naive; it shows all threads as the same thickness, and does not display multi-layer patterns, such as doubleweave, correctly.","title":"Pattern Display"},{"location":"weaving/#weave-direction","text":"The Weaving \"Direction\" button shows \"Weave\" (in black) or \"Unweave\" (in red). Threading also has a direction button that shows \"Thread\" (in black) or \"Unthread\" (in red), prefixed by an arrow showing the direction of the next group of warp ends. How you change direction depends on the loom: S\u00e9guin looms allow you to change direction by pressing the direction button in web browser display, or pressing the UNW button on the dobby unit. Both work equally well; use whichever you prefer. Toika looms can be operated in one of two ways, specified by Direction control in the Settings panel: Software : push the direction button (Weave/Unweave if weaving, Thread/Unthread if threading) in the web browser display to change direction. The physical REVERSE button on the dobby head is ignored. Loom : press the physical REVERSE button on the dobby head to change direction. Warning: the displayed direction does not update until you command the next pick! This is because Toika looms only report direction when requesting a pick. For other looms, see the loom-specific documentation with the software package.","title":"Weave Direction"},{"location":"weaving/#pick-color","text":"The long colored rectangle to the right of Pick shows the color of the current pick (blank for pick 0), or, if you have specified a pick to jump to, then it is the color of that pending pick.","title":"Pick Color"},{"location":"weaving/#jumping","text":"You can jump to a different pick. Jumping is a two-step process: first you request the jump, then you advance to it by pressing the loom's pedal. (Two steps are necessary because most looms will not accept an unsolicited command to raise shafts.) In detail: Enter the desired pick in the box on the \"Jump to pick\" line. The box will turn pink and the Jump button will be enabled. Press the \"return\" keyboard key or click the \"Jump\" button on the web page to send the requested jump to the server. You will see several changes: The jump input box will have a white background and the jump button will be disabled. The pattern display will show the jump-to pick in the center row, with a dotted box around it. Advance to the next pick by pressing the loom's pedal. Until you advance to the next pick, you may request a different jump (in case you got it wrong the first time) or cancel it. To cancel the jump you may do any of the following: Press the \"Reset\" button to the right of \"Jump\". Reload the page. Select a new pattern.","title":"Jumping"},{"location":"weaving/#repeating","text":"The software will automatically repeat patterns if you weave or unweave beyond the end. The exact behavior is controlled by the \"Separate repeats?\" checkbox: \"On\" (checked): you must advance twice when you reach an end, before the next set of shafts is raised. The first advance will lower all shafts, as a signal that you have finished weaving or unweaving one pattern repeat. That is the \"separator\". This will be displayed as a blank row in the center of the pattern display, and also between repeats in the display of unwoven fabric above the center. \"Off\" (unchecked): there is no indication that you have reached the end of the pattern. The next pick will be pick 1 of the pattern, if weaving, or the last pick, if unweaving. The default value of \"Separate repeats?\" is checked (on) if the pattern has more than 20 picks, unchecked (off) otherwise. The idea is that frequent separator picks are annoying for short patterns, but having a separator pick is useful for long patterns. Threading has a checkbox with the same name that does the same basic thing. However, the value of the Weaving and Threading \"Separate repeats?\" checkboxes are independent of each other, and may also be different for different patterns. They are saved in the pattern database.","title":"Repeating"},{"location":"api/base_loom_server/","text":"base_loom_server source package base_loom_server Modules base_loom_server.app_runner base_loom_server.base_loom_server base_loom_server.base_mock_loom base_loom_server.check_translation_files base_loom_server.client_replies base_loom_server.constants base_loom_server.enums base_loom_server.example_loom_server base_loom_server.example_mock_loom base_loom_server.main base_loom_server.mock_streams base_loom_server.pattern_database base_loom_server.reduced_pattern base_loom_server.testutils base_loom_server.translations base_loom_server.utils base_loom_server.version","title":"base_loom_server"},{"location":"src/base_loom_server/","text":"base_loom_server docs package base_loom_server","title":"base_loom_server"},{"location":"api/base_loom_server/app_runner/","text":"base_loom_server.app_runner source module base_loom_server.app_runner Classes AppRunner \u2014 Run the loom server application. source class AppRunner ( app : FastAPI , server_class : type[ BaseLoomServer ] , favicon : bytes , app_package_name : str ) Run the loom server application. This contains the web server's endpoints, the lifespan context manager, and a method to create the argument parser. In order to use this you must create an instance on import (i.e. at the module level), typically in `main.py'. If you defer creation, the web server will not see the endpoints! See main.py for an example. Parameters app : FastAPI \u2014 The application, generated with app = FastAPI() server_class : type[ BaseLoomServer ] \u2014 The loom server class (not an instance, but the class itself). favicon : bytes \u2014 A 32x32 or so favicon. No favicon if empty. app_package_name : str \u2014 The name of the python package for your loom server, e.g. \"toika_loom_server\". This is used by the run method, as an argument to uvicorn.run . Methods create_argument_parser \u2014 Create the argument parser. lifespan \u2014 Lifespan context manager for fastAPI. get \u2014 Endpoint to get the main page. get_favicon \u2014 Endpoint to get the favicon. websocket_endpoint \u2014 Websocket endpoint. run \u2014 Parse command-line arguments and run the web server. source method AppRunner . create_argument_parser ( ) \u2192 argparse . ArgumentParser Create the argument parser. Subclasses may override this to add more options. source async method AppRunner . lifespan ( self , app : FastAPI ) \u2192 AsyncGenerator [None, FastAPI ] Lifespan context manager for fastAPI. Load the translation dict and create the sole instance of the loom server class. That loom server instance persists for the entire time the web server is running. This is because the loom server speaks to one loom and serves at most one user. source async method AppRunner . get ( self ) \u2192 HTMLResponse Endpoint to get the main page. source async method AppRunner . get_favicon ( self ) \u2192 Response Endpoint to get the favicon. source async method AppRunner . websocket_endpoint ( self , websocket : WebSocket ) \u2192 None Websocket endpoint. source method AppRunner . run ( ) \u2192 None Parse command-line arguments and run the web server.","title":"base_loom_server.app_runner"},{"location":"src/base_loom_server/app_runner/","text":"base_loom_server.app_runner docs module base_loom_server.app_runner 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 import argparse import importlib.resources import json import logging import pathlib from collections.abc import AsyncGenerator from contextlib import asynccontextmanager from typing import ClassVar import uvicorn from fastapi import APIRouter , FastAPI , WebSocket from fastapi.responses import HTMLResponse , Response from .base_loom_server import DEFAULT_DATABASE_PATH , BaseLoomServer from .constants import LOG_NAME from .enums import DirectionControlEnum PKG_FILES = importlib . resources . files ( \"base_loom_server\" ) class AppRunner : docs \"\"\"Run the loom server application. This contains the web server's endpoints, the lifespan context manager, and a method to create the argument parser. In order to use this you *must* create an instance on import (i.e. at the module level), typically in `main.py'. If you defer creation, the web server will not see the endpoints! See ``main.py`` for an example. Args: app: The application, generated with ``app = FastAPI()`` server_class: The loom server class (not an instance, but the class itself). favicon: A 32x32 or so favicon. No favicon if empty. app_package_name: The name of the python package for your loom server, e.g. \"toika_loom_server\". This is used by the `run` method, as an argument to `uvicorn.run`. \"\"\" DirectionControlMap : ClassVar = { item . name . lower (): item for item in DirectionControlEnum } def __init__ ( self , app : FastAPI , server_class : type [ BaseLoomServer ], favicon : bytes , app_package_name : str , ) -> None : self . log = logging . getLogger ( LOG_NAME ) self . server_class = server_class self . favicon = favicon self . app_package_name = app_package_name self . loom_server : BaseLoomServer | None = None # Assign enpoints to the app. # The only reason we need a router is to set the lifespan # but once we have it we may as well use it to add endpoints as well router = APIRouter ( lifespan = self . lifespan ) # Normally one would use decorators to specify endpoints # but that doesn't work well with methods. router . add_api_route ( \"/\" , self . get , methods = [ \"GET\" ]) if self . favicon : router . add_api_route ( \"/favicon.ico\" , self . get_favicon , methods = [ \"GET\" ], include_in_schema = False , ) router . add_websocket_route ( \"/ws\" , self . websocket_endpoint ) app . include_router ( router ) def create_argument_parser ( self ) -> argparse . ArgumentParser : docs \"\"\"Create the argument parser. Subclasses may override this to add more options. \"\"\" parser = argparse . ArgumentParser () parser . add_argument ( \"num_shafts\" , type = int , help = \"The number of shafts the loom has.\" ) parser . add_argument ( \"serial_port\" , help = \"Serial port connected to the loom, \" \"typically of the form /dev/tty... \" \"Specify 'mock' to run a mock (simulated) loom\" , ) parser . add_argument ( \"-r\" , \"--reset-db\" , action = \"store_true\" , help = \"Reset the pattern database, erasing all patterns.\" , ) parser . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , help = \"Log extra diagnostic information.\" , ) parser . add_argument ( \"--db-path\" , default = DEFAULT_DATABASE_PATH , type = pathlib . Path , help = \"Path for the pattern database. \" \"Specify this if you plan to run more than one loom server on this computer.\" , ) parser . add_argument ( \"--host\" , default = \"0.0.0.0\" , help = \"Server host. 0.0.0.0 is standard. Don't change this unless you know what you are doing.\" , ) parser . add_argument ( \"--port\" , type = int , default = 8000 , help = \"Server port. Specify this if you wish to run more than one web server on this computer.\" , ) parser . add_argument ( \"--log-level\" , choices = ( \"critical\" , \"error\" , \"warning\" , \"info\" , \"debug\" , \"trace\" ), default = \"info\" , help = \"Logging level.\" , ) return parser @asynccontextmanager docs async def lifespan ( self , app : FastAPI ) -> AsyncGenerator [ None , FastAPI ]: \"\"\"Lifespan context manager for fastAPI. Load the translation dict and create the sole instance of the loom server class. That loom server instance persists for the entire time the web server is running. This is because the loom server speaks to one loom and serves at most one user. \"\"\" parser = self . create_argument_parser () args = parser . parse_args () for uvicorn_arg in ( \"host\" , \"port\" , \"log_level\" ): if getattr ( args , uvicorn_arg , None ) is not None : delattr ( args , uvicorn_arg ) async with self . server_class ( ** vars ( args )) as self . loom_server : # Store the server as state for unit tests app . state . loom_server = self . loom_server yield async def get ( self ) -> HTMLResponse : docs \"\"\"Endpoint to get the main page.\"\"\" assert self . loom_server is not None # make mypy happy display_html = PKG_FILES . joinpath ( \"display.html\" ) . read_text ( encoding = \"utf_8\" ) display_css = PKG_FILES . joinpath ( \"display.css\" ) . read_text ( encoding = \"utf_8\" ) display_js = PKG_FILES . joinpath ( \"display.js\" ) . read_text ( encoding = \"utf_8\" ) js_translation_str = json . dumps ( self . loom_server . translation_dict , indent = 4 ) display_js = display_js . replace ( \"{ translation_dict }\" , js_translation_str ) display_html = display_html . format ( display_css = display_css , display_js = display_js , help_url = self . loom_server . help_url , ** self . loom_server . translation_dict , ) return HTMLResponse ( display_html ) async def get_favicon ( self ) -> Response : docs \"\"\"Endpoint to get the favicon.\"\"\" return Response ( content = self . favicon , media_type = \"image/x-icon\" ) async def websocket_endpoint ( self , websocket : WebSocket ) -> None : docs \"\"\"Websocket endpoint.\"\"\" assert self . loom_server is not None await self . loom_server . run_client ( websocket = websocket ) def run ( self ) -> None : docs \"\"\"Parse command-line arguments and run the web server.\"\"\" # Handle the help argument and also catch parsing errors right away arg_parser = self . create_argument_parser () args = arg_parser . parse_args () uvicorn . run ( self . app_package_name , host = args . host , port = args . port , log_level = args . log_level , reload = False , )","title":"base_loom_server.app_runner"},{"location":"api/base_loom_server/base_loom_server/","text":"base_loom_server.base_loom_server source module base_loom_server.base_loom_server Classes BaseLoomServer \u2014 Base class for a web server that controls a dobby loom. CloseCode \u2014 WebSocket close codes. CommandError source class BaseLoomServer ( * , num_shafts : int , serial_port : str , reset_db : bool , verbose : bool , db_path : pathlib . Path | None = None ) Base class for a web server that controls a dobby loom. Subclasses should not only provide implementations for the abstract methods, but should also override the class constants, as appropriate. Parameters num_shafts : int \u2014 The number of shafts the loom has. serial_port : str \u2014 The name of the serial port, e.g. \"/dev/tty0\". If the name is \"mock\" then use a mock loom. reset_db : bool \u2014 If True, delete the old database and create a new one. verbose : bool \u2014 If True, log diagnostic information. db_path : pathlib . Path | None \u2014 Path to the pattern database. Specify None for the default path. Unit tests specify a non-None value, to avoid stomping on the real database. Attributes enable_software_direction : bool \u2014 Is software direction control enabled? thread_low_to_high : bool \u2014 Return True if threading (or unthreading) is currently low to high. loom_connected : bool \u2014 Return True if connected to the loom. Methods handle_loom_reply \u2014 Process one reply from the loom. write_shafts_to_loom \u2014 Write the shaft word to the loom. start \u2014 Run asynchronous startup tasks. close \u2014 Disconnect from client and loom and stop all tasks. add_pattern \u2014 Add a pattern to pattern database. close_websocket \u2014 Close a websocket using best effort and a short timeout. get_initial_loom_state \u2014 Obtain the loom state. connect_to_loom \u2014 Connect to the loom. run_client \u2014 Run a client connection, closing any existing connection. disconnect_client \u2014 Disconnect the current client, if any. disconnect_from_loom \u2014 Disconnect the loom. A no-op if already disconnected. basic_read_loom \u2014 Read one reply from the loom. clear_jump_end \u2014 Clear self.jump_end and report value if changed or force_output. clear_jump_pick \u2014 Clear self.jump_pick and report value if changed or force_output. clear_jumps \u2014 Clear all jumps and report values if changed or force_output. cmd_clear_pattern_names \u2014 Handle the clear_pattern_names command. cmd_direction \u2014 Handle the direction command: set direction. cmd_jump_to_end \u2014 Handle the jump_to_end command. cmd_jump_to_pick \u2014 Handle the jump_to_pick command. cmd_mode \u2014 Handle the mode command: set the mode. cmd_select_pattern \u2014 Handle the select_pattern command. cmd_separate_threading_repeats \u2014 Handle the separate_threading_repeats command. cmd_separate_weaving_repeats \u2014 Handle the separate_weaving_repeats command. cmd_settings \u2014 Handle the settings command: set one or more settings. cmd_thread_group_size \u2014 Handle the thread_group_size command. cmd_oobcommand \u2014 Handle the oob_command command. cmd_upload \u2014 Handle the upload command. get_threading_shaft_word \u2014 Get the current threading shaft word. handle_next_pick_request \u2014 Handle next pick request from loom. increment_pick_number \u2014 Increment pick_number in the current direction. increment_end_number \u2014 Increment end_number0 in the current direction. load_settings \u2014 Read the settings file, if it exists. read_client_loop \u2014 Read and process commands from the client. read_loom_loop \u2014 Read and process replies from the loom. report_command_done \u2014 Report completion of a command. report_command_problem \u2014 Report a CommandProblem to the client. report_current_pattern \u2014 Report pattern to the client. report_initial_server_state \u2014 Report server state. report_loom_connection_state \u2014 Report LoomConnectionState to the client. report_pattern_names \u2014 Report PatternNames to the client. report_current_pick_number \u2014 Report CurrentPickNumber to the client. report_current_end_numbers \u2014 Report CurrentEndNumber to the client. report_jump_end \u2014 Report JumpEndNumber to the client. report_jump_pick \u2014 Report JumpPickNumber to the client. report_shaft_state \u2014 Report ShaftState to the client. report_mode \u2014 Report the current mode to the client. report_separate_threading_repeats \u2014 Report SeparateThreadingRepeats. report_separate_weaving_repeats \u2014 Report SeparateWeavingRepeats. report_settings \u2014 Report Settings. report_status_message \u2014 Report a status message to the client. report_thread_group_size \u2014 Report ThreadGroupSize. report_language_names \u2014 Report LanguageNames. report_direction \u2014 Report Direction. reset_database \u2014 Reset the pattern database (write a new one). save_settings \u2014 Save the settings file. select_pattern \u2014 Select the specified pattern. t \u2014 Translate a phrase, if possible. write_to_client \u2014 Send a reply to the client. write_to_loom \u2014 Send data to the loom. source async method BaseLoomServer . handle_loom_reply ( self , reply_bytes : bytes ) \u2192 None Process one reply from the loom. Raises NotImplementedError source async method BaseLoomServer . write_shafts_to_loom ( self , shaft_word : int ) \u2192 None Write the shaft word to the loom. Raises NotImplementedError source property BaseLoomServer . enable_software_direction : bool Is software direction control enabled? source property BaseLoomServer . thread_low_to_high : bool Return True if threading (or unthreading) is currently low to high. Takes into account settings and self.direction_forward. source property BaseLoomServer . loom_connected : bool Return True if connected to the loom. source async method BaseLoomServer . start ( self ) \u2192 None Run asynchronous startup tasks. Initialize the pattern database and connect to the loom. source async method BaseLoomServer . close ( self , * , stop_read_loom : bool = True , stop_read_client : bool = True ) \u2192 None Disconnect from client and loom and stop all tasks. source async method BaseLoomServer . add_pattern ( self , pattern : ReducedPattern ) \u2192 None Add a pattern to pattern database. Also purge the MAX_PATTERNS oldest entries (excluding the current pattern, if any) and report the new list of pattern names to the client. source async method BaseLoomServer . close_websocket ( self , ws : WebSocket , code : CloseCode = CloseCode . NORMAL , reason : str = '' ) \u2192 None Close a websocket using best effort and a short timeout. source async method BaseLoomServer . get_initial_loom_state ( self ) \u2192 None Obtain the loom state. Called just after the server connects to the loom. Usually a no-op, because a well designed loom automatically reports its own state when software connects to it. source async method BaseLoomServer . connect_to_loom ( self ) \u2192 None Connect to the loom. If already connected to loom, disconnect first, since connecting again may indicate that something is wrong. source async method BaseLoomServer . run_client ( self , websocket : WebSocket ) \u2192 None Run a client connection, closing any existing connection. Also open a connection to the loom, if that was closed. Parameters websocket : WebSocket \u2014 Connection to the client. source async method BaseLoomServer . disconnect_client ( self ) \u2192 None Disconnect the current client, if any. source async method BaseLoomServer . disconnect_from_loom ( self ) \u2192 None Disconnect the loom. A no-op if already disconnected. source async method BaseLoomServer . basic_read_loom ( self ) \u2192 bytes Read one reply from the loom. Perform no error checking, except that self.loom_reader exists. source async method BaseLoomServer . clear_jump_end ( self , * , force_output : bool = False ) \u2192 None Clear self.jump_end and report value if changed or force_output. Parameters force_output : bool \u2014 If true, report JumpEndNumber , even if it has not changed. source async method BaseLoomServer . clear_jump_pick ( self , * , force_output : bool = False ) \u2192 None Clear self.jump_pick and report value if changed or force_output. Parameters force_output : bool \u2014 If true, report JumpPickNumber , even if it has not changed. source async method BaseLoomServer . clear_jumps ( self , * , force_output : bool = False ) \u2192 None Clear all jumps and report values if changed or force_output. source async method BaseLoomServer . cmd_clear_pattern_names ( self , command : SimpleNamespace ) \u2192 None Handle the clear_pattern_names command. Clear all patterns except the current pattern. source async method BaseLoomServer . cmd_direction ( self , command : SimpleNamespace ) \u2192 None Handle the direction command: set direction. source async method BaseLoomServer . cmd_jump_to_end ( self , command : SimpleNamespace ) \u2192 None Handle the jump_to_end command. Raises CommandError source async method BaseLoomServer . cmd_jump_to_pick ( self , command : SimpleNamespace ) \u2192 None Handle the jump_to_pick command. Raises CommandError source async method BaseLoomServer . cmd_mode ( self , command : SimpleNamespace ) \u2192 None Handle the mode command: set the mode. source async method BaseLoomServer . cmd_select_pattern ( self , command : SimpleNamespace ) \u2192 None Handle the select_pattern command. source async method BaseLoomServer . cmd_separate_threading_repeats ( self , command : SimpleNamespace ) \u2192 None Handle the separate_threading_repeats command. source async method BaseLoomServer . cmd_separate_weaving_repeats ( self , command : SimpleNamespace ) \u2192 None Handle the separate_weaving_repeats command. source async method BaseLoomServer . cmd_settings ( self , command : SimpleNamespace ) \u2192 None Handle the settings command: set one or more settings. Raises CommandError source async method BaseLoomServer . cmd_thread_group_size ( self , command : SimpleNamespace ) \u2192 None Handle the thread_group_size command. source async method BaseLoomServer . cmd_oobcommand ( self , command : SimpleNamespace ) \u2192 None Handle the oob_command command. Send an out-of-band command to the mock loom. Ignored with a logged warning if the loom is not the mock loom. source async method BaseLoomServer . cmd_upload ( self , command : SimpleNamespace ) \u2192 None Handle the upload command. Raises CommandError source method BaseLoomServer . get_threading_shaft_word ( ) \u2192 int Get the current threading shaft word. source async method BaseLoomServer . handle_next_pick_request ( self ) \u2192 bool Handle next pick request from loom. Call this from handle_loom_reply. Figure out the next pick, send it to the loom, and report the current pick or end numbers to the client (if we were not at the beginning of the work). Returns did_advance \u2014 True if the loom was sent the next set of shafts. False if in Setting mode, or no current pattern, or attemped to go beyond the start of the pattern. Raises RuntimeError source method BaseLoomServer . increment_pick_number ( ) \u2192 int Increment pick_number in the current direction. Increment pick_repeat_number as well, if appropriate. Return the new pick number. This will be 0 if pick_repeat_number changed, or if unweaving and pick_repeat_number would be decremented to 0. source method BaseLoomServer . increment_end_number ( ) \u2192 None Increment end_number0 in the current direction. source method BaseLoomServer . load_settings ( ) \u2192 None Read the settings file, if it exists. Usable entries will replace the values in self.settings (which must already be set to a valid value). Unusable entries will be ignored, with a logged warning. source async method BaseLoomServer . read_client_loop ( self ) \u2192 None Read and process commands from the client. source async method BaseLoomServer . read_loom_loop ( self ) \u2192 None Read and process replies from the loom. Raises RuntimeError source async method BaseLoomServer . report_command_done ( self , * , cmd_type : str , success : bool , message : str = '' ) \u2192 None Report completion of a command. source async method BaseLoomServer . report_command_problem ( self , message : str , severity : MessageSeverityEnum ) \u2192 None Report a CommandProblem to the client. source async method BaseLoomServer . report_current_pattern ( self ) \u2192 None Report pattern to the client. source async method BaseLoomServer . report_initial_server_state ( self ) \u2192 None Report server state. Called just after a client connects to the server. source async method BaseLoomServer . report_loom_connection_state ( self , reason : str = '' ) \u2192 None Report LoomConnectionState to the client. source async method BaseLoomServer . report_pattern_names ( self ) \u2192 None Report PatternNames to the client. source async method BaseLoomServer . report_current_pick_number ( self ) \u2192 None Report CurrentPickNumber to the client. Also update pick information in the database. source async method BaseLoomServer . report_current_end_numbers ( self ) \u2192 None Report CurrentEndNumber to the client. Also update threading information the database. source async method BaseLoomServer . report_jump_end ( self ) \u2192 None Report JumpEndNumber to the client. source async method BaseLoomServer . report_jump_pick ( self ) \u2192 None Report JumpPickNumber to the client. source async method BaseLoomServer . report_shaft_state ( self ) \u2192 None Report ShaftState to the client. source async method BaseLoomServer . report_mode ( self ) \u2192 None Report the current mode to the client. source async method BaseLoomServer . report_separate_threading_repeats ( self ) \u2192 None Report SeparateThreadingRepeats. source async method BaseLoomServer . report_separate_weaving_repeats ( self ) \u2192 None Report SeparateWeavingRepeats. source async method BaseLoomServer . report_settings ( self ) \u2192 None Report Settings. source async method BaseLoomServer . report_status_message ( self , message : str , severity : MessageSeverityEnum ) \u2192 None Report a status message to the client. source async method BaseLoomServer . report_thread_group_size ( self ) \u2192 None Report ThreadGroupSize. source async method BaseLoomServer . report_language_names ( self ) \u2192 None Report LanguageNames. source async method BaseLoomServer . report_direction ( self ) \u2192 None Report Direction. source method BaseLoomServer . reset_database ( ) \u2192 None Reset the pattern database (write a new one). source method BaseLoomServer . save_settings ( ) \u2192 None Save the settings file. source async method BaseLoomServer . select_pattern ( self , name : str ) \u2192 None Select the specified pattern. Raises CommandError source method BaseLoomServer . t ( phrase : str ) \u2192 str Translate a phrase, if possible. source async method BaseLoomServer . write_to_client ( self , reply : Any ) \u2192 None Send a reply to the client. Parameters reply : Any \u2014 The reply to write, as a dataclass. It should have a \"type\" field whose value is a string. source async method BaseLoomServer . write_to_loom ( self , data : bytes | bytearray | str ) \u2192 None Send data to the loom. Parameters data : bytes | bytearray | str \u2014 The data to send, without a terminator. (This method will append the terminator). Raises RuntimeError source enum CloseCode ( * args , ** kwds ) Bases : enum . IntEnum WebSocket close codes. A small subset of https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4 Attributes NORMAL GOING_AWAY ERROR source class CommandError ( ) Bases : Exception","title":"base_loom_server.base_loom_server"},{"location":"src/base_loom_server/base_loom_server/","text":"base_loom_server.base_loom_server docs module base_loom_server.base_loom_server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 from __future__ import annotations __all__ = [ \"BaseLoomServer\" , \"DEFAULT_DATABASE_PATH\" , \"MOCK_PORT_NAME\" ] import abc import asyncio import copy import dataclasses import enum import importlib.resources import json import logging import pathlib from types import SimpleNamespace , TracebackType from typing import TYPE_CHECKING , Any , Self from dtx_to_wif import read_pattern_data from fastapi import WebSocket , WebSocketDisconnect from fastapi.websockets import WebSocketState from serial_asyncio import open_serial_connection # type: ignore[import-untyped] from . import client_replies from .constants import LOG_NAME from .enums import DirectionControlEnum , MessageSeverityEnum , ModeEnum , ShaftStateEnum from .pattern_database import PatternDatabase from .reduced_pattern import ReducedPattern , reduced_pattern_from_pattern_data from .translations import get_language_names , get_translation_dict from .utils import compute_num_within_and_repeats , compute_total_num if TYPE_CHECKING : from .base_mock_loom import BaseMockLoom from .mock_streams import StreamReaderType , StreamWriterType # The maximum number of patterns that can be in the history MAX_PATTERNS = 25 DEFAULT_DATABASE_PATH = pathlib . Path . home () / \"loom_server_database.sqlite\" SETTINGS_FILE_NAME = \"loom_server_settings.json\" MAX_THREAD_GROUP_SIZE = 10 # Maximum weaving pattern data to log MAX_LOG_PATTERN_LEN = 100 MOCK_PORT_NAME = \"mock\" PKG_FILES = importlib . resources . files ( \"base_loom_server\" ) LOCALE_FILES = PKG_FILES . joinpath ( \"locales\" ) class CloseCode ( enum . IntEnum ): docs \"\"\"WebSocket close codes. A small subset of https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4 \"\"\" NORMAL = 1000 GOING_AWAY = 1001 ERROR = 1011 class CommandError ( Exception ): docs pass class BaseLoomServer : docs \"\"\"Base class for a web server that controls a dobby loom. Subclasses should not only provide implementations for the abstract methods, but should also override the class constants, as appropriate. Args: num_shafts: The number of shafts the loom has. serial_port: The name of the serial port, e.g. \"/dev/tty0\". If the name is \"mock\" then use a mock loom. reset_db: If True, delete the old database and create a new one. verbose: If True, log diagnostic information. db_path: Path to the pattern database. Specify None for the default path. Unit tests specify a non-None value, to avoid stomping on the real database. \"\"\" # Subclasses should override these, as necesary. # Definitely overide `default_name` and `mock_loom_type`. baud_rate = 9600 default_name = \"base\" help_url = \"https://r-owen.github.io/base_loom_server/\" loom_reports_direction = True loom_reports_motion = True mock_loom_type : type [ BaseMockLoom ] | None = None supports_full_direction_control = True def __init__ ( self , * , num_shafts : int , serial_port : str , reset_db : bool , verbose : bool , db_path : pathlib . Path | None = None , ) -> None : if self . mock_loom_type is None : raise RuntimeError ( \"Subclasses must set class variable 'mock_loom_type'\" ) self . terminator = self . mock_loom_type . terminator self . log = logging . getLogger ( LOG_NAME ) if verbose : self . log . info ( f \" { self } ( { serial_port =!r} , { reset_db =!r} , { verbose =!r} , { db_path =!r} )\" ) self . serial_port = serial_port self . verbose = verbose self . loom_info = client_replies . LoomInfo ( num_shafts = num_shafts , serial_port = serial_port , is_mock = serial_port == MOCK_PORT_NAME , ) self . db_path : pathlib . Path = DEFAULT_DATABASE_PATH if db_path is None else db_path if reset_db : self . log . info ( f \"Resetting database { self . db_path } by request\" ) self . reset_database () try : self . pattern_db = PatternDatabase ( self . db_path ) except Exception as e : self . log . warning ( f \"Resetting database { self . db_path } because open failed: { e !r} \" ) self . reset_database () # Compute initial value for direction_control. # This value will be overridden by the settings file, if it exists. if self . supports_full_direction_control : direction_control = DirectionControlEnum . FULL elif self . loom_reports_direction : # We have to pick something for the initial default, # and it may as well be the loom. direction_control = DirectionControlEnum . LOOM else : # This value is required for unit tests, which want immediate # notification when the direction changes. direction_control = DirectionControlEnum . SOFTWARE self . settings = client_replies . Settings ( loom_name = self . default_name , language = \"English\" , direction_control = direction_control , end1_on_right = True , thread_group_size = 4 , thread_right_to_left = True , thread_back_to_front = True , ) self . settings_path = self . db_path . parent / SETTINGS_FILE_NAME self . translation_dict = get_translation_dict ( language = self . settings . language , logger = self . log ) self . load_settings () self . save_settings () self . websocket : WebSocket | None = None self . loom_connecting : bool = False self . loom_disconnecting : bool = False self . client_connected : bool = False self . shaft_state : ShaftStateEnum = ( ShaftStateEnum . UNKNOWN if self . loom_reports_motion else ShaftStateEnum . DONE ) self . shaft_word : int = 0 self . mock_loom : BaseMockLoom | None = None self . loom_reader : StreamReaderType | None = None self . loom_writer : StreamWriterType | None = None self . read_client_task : asyncio . Future = asyncio . Future () self . read_loom_task : asyncio . Future = asyncio . Future () self . done_task : asyncio . Future = asyncio . Future () self . current_pattern : ReducedPattern | None = None self . jump_pick = client_replies . JumpPickNumber () self . jump_end = client_replies . JumpEndNumber () self . mode = ModeEnum . WEAVE self . direction_forward : bool = True self . __post_init__ () @abc . abstractmethod async def handle_loom_reply ( self , reply_bytes : bytes ) -> None : docs \"\"\"Process one reply from the loom.\"\"\" raise NotImplementedError @abc . abstractmethod async def write_shafts_to_loom ( self , shaft_word : int ) -> None : docs \"\"\"Write the shaft word to the loom.\"\"\" raise NotImplementedError @property def enable_software_direction ( self ) -> bool : docs \"\"\"Is software direction control enabled?\"\"\" return self . settings . direction_control in { DirectionControlEnum . FULL , DirectionControlEnum . SOFTWARE , } @property def thread_low_to_high ( self ) -> bool : docs \"\"\"Return True if threading (or unthreading) is currently low to high. Takes into account settings and self.direction_forward. \"\"\" low_to_high = self . settings . thread_back_to_front == self . settings . thread_right_to_left if not self . settings . end1_on_right : low_to_high = not low_to_high if not self . direction_forward : low_to_high = not low_to_high return low_to_high def __post_init__ ( self ) -> None : \"\"\"Subclases may override this method, preferably instead of overriding the constructor. Called at the end of the constructor. By default this is a no-op so subclases need not call `super().__post_init__()` \"\"\" @property def loom_connected ( self ) -> bool : docs \"\"\"Return True if connected to the loom.\"\"\" return not ( self . loom_writer is None or self . loom_reader is None or self . loom_writer . is_closing () or self . loom_reader . at_eof () ) async def start ( self ) -> None : docs \"\"\"Run asynchronous startup tasks. Initialize the pattern database and connect to the loom. \"\"\" await self . pattern_db . init () if not await self . pattern_db . check_schema (): self . log . warning ( f \"Resetting database { self . db_path } because the schema is outdated\" ) self . reset_database () await self . clear_jumps () # Restore current pattern, if any names = await self . pattern_db . get_pattern_names () if len ( names ) > 0 : await self . select_pattern ( names [ - 1 ]) await self . connect_to_loom () docs async def close ( self , * , stop_read_loom : bool = True , stop_read_client : bool = True ) -> None : \"\"\"Disconnect from client and loom and stop all tasks.\"\"\" if self . loom_writer is not None : if stop_read_loom : self . read_loom_task . cancel () if stop_read_client : self . read_client_task . cancel () self . loom_writer . close () if self . mock_loom is not None : await self . mock_loom . close () if not self . done_task . done (): self . done_task . set_result ( None ) async def add_pattern ( self , pattern : ReducedPattern ) -> None : docs \"\"\"Add a pattern to pattern database. Also purge the MAX_PATTERNS oldest entries (excluding the current pattern, if any) and report the new list of pattern names to the client. \"\"\" await self . pattern_db . add_pattern ( pattern = pattern , max_entries = MAX_PATTERNS ) await self . report_pattern_names () async def close_websocket ( docs self , ws : WebSocket , code : CloseCode = CloseCode . NORMAL , reason : str = \"\" ) -> None : \"\"\"Close a websocket using best effort and a short timeout.\"\"\" if ws . client_state == WebSocketState . DISCONNECTED : return try : async with asyncio . timeout ( 0.1 ): await ws . close ( code , reason ) except Exception as e : self . log . warning ( f \" { self } : failed to close websocket: { e !r} \" ) async def get_initial_loom_state ( self ) -> None : docs \"\"\"Obtain the loom state. Called just after the server connects to the loom. Usually a no-op, because a well designed loom automatically reports its own state when software connects to it. \"\"\" async def connect_to_loom ( self ) -> None : docs \"\"\"Connect to the loom. If already connected to loom, disconnect first, since connecting again may indicate that something is wrong. \"\"\" if self . loom_connected : await self . disconnect_from_loom () try : self . loom_connecting = True await self . report_loom_connection_state () if self . loom_info . is_mock : assert self . mock_loom_type is not None # make mypy happy self . mock_loom = self . mock_loom_type ( num_shafts = self . loom_info . num_shafts , verbose = self . verbose ) assert self . mock_loom is not None # make mypy happy self . loom_reader , self . loom_writer = await self . mock_loom . open_client_connection () else : self . loom_reader , self . loom_writer = await open_serial_connection ( url = self . loom_info . serial_port , baudrate = self . baud_rate ) # try to purge input buffer transport = getattr ( self . loom_writer , \"transport\" , None ) if transport is None : self . log . warning ( f \" { self } : Could not flush read buffer; no transport found\" ) else : serial_instance = getattr ( transport , \"_serial\" , None ) if serial_instance is None : self . log . warning ( f \" { self } : Could not flush read buffer; no serial instance found in transport\" ) elif serial_instance . in_waiting > 0 : serial_instance . reset_input_buffer () self . log . info ( f \" { self } : Read buffer flushed\" ) else : self . log . info ( f \" { self } : Read buffer did not need to be flushed; it was empty\" ) self . loom_connecting = False await self . report_loom_connection_state () await self . get_initial_loom_state () except Exception as e : self . loom_connecting = False await self . report_loom_connection_state ( reason = str ( e )) raise finally : self . loom_connecting = False self . read_loom_task = asyncio . create_task ( self . read_loom_loop ()) async def run_client ( self , websocket : WebSocket ) -> None : docs \"\"\"Run a client connection, closing any existing connection. Also open a connection to the loom, if that was closed. Args: websocket: Connection to the client. \"\"\" if self . client_connected : self . log . info ( f \" { self } : a client was already connected; closing that connection\" ) await self . disconnect_client () await websocket . accept () self . websocket = websocket self . read_client_task = asyncio . create_task ( self . read_client_loop ()) if not self . loom_connected : try : await self . connect_to_loom () except Exception : # Note: connect_to_loom already reported the # (lack of) connection state, including the reason. # But log it here. self . log . exception ( f \" { self } : failed to reconnect to the loom\" ) await self . done_task async def disconnect_client ( self ) -> None : docs \"\"\"Disconnect the current client, if any.\"\"\" self . read_client_task . cancel () websocket = self . websocket self . websocket = None if websocket is not None : await self . close_websocket ( websocket , code = CloseCode . GOING_AWAY , reason = self . t ( \"another client took control\" ), ) async def disconnect_from_loom ( self ) -> None : docs \"\"\"Disconnect the loom. A no-op if already disconnected.\"\"\" if not self . loom_connected : return self . loom_disconnecting = True await self . report_loom_connection_state () try : if self . loom_writer is not None : self . loom_writer . close () self . loom_reader = None self . loom_writer = None self . mock_loom = None finally : self . loom_disconnecting = False await self . report_loom_connection_state () async def basic_read_loom ( self ) -> bytes : docs \"\"\"Read one reply from the loom. Perform no error checking, except that self.loom_reader exists. \"\"\" assert self . loom_reader is not None return await self . loom_reader . readuntil ( self . terminator ) docs async def clear_jump_end ( self , * , force_output : bool = False ) -> None : \"\"\"Clear self.jump_end and report value if changed or force_output. Args: force_output: If true, report `JumpEndNumber`, even if it has not changed. \"\"\" null_jump_end = client_replies . JumpEndNumber () do_report = force_output or self . jump_end != null_jump_end self . jump_end = null_jump_end if do_report : await self . report_jump_end () docs async def clear_jump_pick ( self , * , force_output : bool = False ) -> None : \"\"\"Clear self.jump_pick and report value if changed or force_output. Args: force_output: If true, report `JumpPickNumber`, even if it has not changed. \"\"\" null_jump_pick = client_replies . JumpPickNumber () do_report = force_output or self . jump_pick != null_jump_pick self . jump_pick = null_jump_pick if do_report : await self . report_jump_pick () async def clear_jumps ( self , * , force_output : bool = False ) -> None : docs \"\"\"Clear all jumps and report values if changed or force_output.\"\"\" await self . clear_jump_end ( force_output = force_output ) await self . clear_jump_pick ( force_output = force_output ) async def cmd_clear_pattern_names ( docs self , command : SimpleNamespace , # noqa: ARG002 ) -> None : \"\"\"Handle the clear_pattern_names command. Clear all patterns except the current pattern. \"\"\" # Clear the pattern database # Then add the current pattern (if any) await self . pattern_db . clear_database () if self . current_pattern is not None : await self . add_pattern ( self . current_pattern ) else : await self . report_pattern_names () async def cmd_direction ( self , command : SimpleNamespace ) -> None : docs \"\"\"Handle the direction command: set direction.\"\"\" self . direction_forward = command . forward await self . report_direction () async def cmd_jump_to_end ( self , command : SimpleNamespace ) -> None : docs \"\"\"Handle the jump_to_end command.\"\"\" if self . current_pattern is None : raise CommandError ( self . t ( \"cannot jump to an end\" ) + \": \" + self . t ( \"no pattern\" )) if command . total_end_number0 is None : self . jump_end = client_replies . JumpEndNumber () else : if command . total_end_number0 < 0 : raise CommandError ( self . t ( \"Number must be\" ) + \" >= 0\" ) end_number0 , end_repeat_number = compute_num_within_and_repeats ( total_num = command . total_end_number0 , repeat_len = self . current_pattern . num_ends , ) end_number1 = self . current_pattern . compute_end_number1 ( end_number0 = end_number0 ) total_end_number1 = compute_total_num ( num_within = end_number1 , repeat_number = end_repeat_number , repeat_len = self . current_pattern . num_ends , ) self . jump_end = client_replies . JumpEndNumber ( total_end_number0 = command . total_end_number0 , total_end_number1 = total_end_number1 , end_number0 = end_number0 , end_number1 = end_number1 , end_repeat_number = end_repeat_number , ) await self . report_jump_end () async def cmd_jump_to_pick ( self , command : SimpleNamespace ) -> None : docs \"\"\"Handle the jump_to_pick command.\"\"\" if self . current_pattern is None : raise CommandError ( self . t ( \"cannot jump to a pick\" ) + \": \" + self . t ( \"no pattern\" )) if command . total_pick_number is None : self . jump_pick = client_replies . JumpPickNumber () else : if command . total_pick_number < 0 : raise CommandError ( self . t ( \"Number must be\" ) + \" >= 0\" ) pick_number , pick_repeat_number = compute_num_within_and_repeats ( total_num = command . total_pick_number , repeat_len = self . current_pattern . num_picks , ) self . jump_pick = client_replies . JumpPickNumber ( total_pick_number = command . total_pick_number , pick_number = pick_number , pick_repeat_number = pick_repeat_number , ) await self . report_jump_pick () async def cmd_mode ( self , command : SimpleNamespace ) -> None : docs \"\"\"Handle the mode command: set the mode.\"\"\" self . mode = ModeEnum ( command . mode ) await self . report_mode () docs async def cmd_select_pattern ( self , command : SimpleNamespace ) -> None : \"\"\"Handle the select_pattern command.\"\"\" name = command . name await self . select_pattern ( name ) await self . clear_jumps () docs async def cmd_separate_threading_repeats ( self , command : SimpleNamespace ) -> None : \"\"\"Handle the separate_threading_repeats command.\"\"\" if self . current_pattern is None : return await self . pattern_db . update_separate_threading_repeats ( pattern_name = self . current_pattern . name , separate_threading_repeats = command . separate , ) self . current_pattern . separate_threading_repeats = command . separate await self . report_separate_threading_repeats () docs async def cmd_separate_weaving_repeats ( self , command : SimpleNamespace ) -> None : \"\"\"Handle the separate_weaving_repeats command.\"\"\" if self . current_pattern is None : return await self . pattern_db . update_separate_weaving_repeats ( pattern_name = self . current_pattern . name , separate_weaving_repeats = command . separate , ) self . current_pattern . separate_weaving_repeats = command . separate await self . report_separate_weaving_repeats () async def cmd_settings ( self , command : SimpleNamespace ) -> None : docs \"\"\"Handle the settings command: set one or more settings.\"\"\" bad_keys : list [ str ] = [] new_settings = copy . copy ( self . settings ) # Use raw_value to avoid warnings about overwriting a loop variable. for key , raw_value in vars ( command ) . items (): value = raw_value # Check values if key == \"type\" : continue if key == \"direction_control\" : value = DirectionControlEnum ( value ) if self . supports_full_direction_control : if value is not DirectionControlEnum . FULL : raise CommandError ( f \"invalid { key } = { value !r} : loom supports full direction control\" ) elif value is DirectionControlEnum . FULL : raise CommandError ( f \"invalid { key } = { value !r} : loom doesn't support full direction control\" ) elif key == \"language\" : if value != self . settings . language : try : self . translation_dict = get_translation_dict ( language = value , logger = self . log ) except Exception as e : raise CommandError ( f \"Failed to load language { value !r} : { e !r} \" ) from e else : expected_type = dict ( loom_name = str , end1_on_right = bool , thread_group_size = int , thread_right_to_left = bool , thread_back_to_front = bool , ) . get ( key ) if expected_type is None : bad_keys . append ( key ) continue if not isinstance ( value , expected_type ): raise CommandError ( f \"invalid { key } = { value !r} : must be type { expected_type } \" ) if key == \"thread_group_size\" : assert isinstance ( value , int ) # Make mypy happy if value < 1 or value > MAX_THREAD_GROUP_SIZE : raise CommandError ( f \"invalid { key } = { value !r} : must be in range [1, { MAX_THREAD_GROUP_SIZE } ]\" ) setattr ( new_settings , key , value ) if bad_keys : raise CommandError ( f \"Invalid settings names { bad_keys } \" ) self . settings = new_settings await self . report_settings () self . save_settings () docs async def cmd_thread_group_size ( self , command : SimpleNamespace ) -> None : \"\"\"Handle the thread_group_size command.\"\"\" if self . current_pattern is None : return await self . pattern_db . update_thread_group_size ( pattern_name = self . current_pattern . name , thread_group_size = command . group_size , ) self . current_pattern . thread_group_size = command . group_size await self . report_thread_group_size () async def cmd_oobcommand ( self , command : SimpleNamespace ) -> None : docs \"\"\"Handle the oob_command command. Send an out-of-band command to the mock loom. Ignored with a logged warning if the loom is not the mock loom. \"\"\" if self . mock_loom is not None : await self . mock_loom . oob_command ( command . command ) else : self . log . warning ( f \"Ignoring oob command { command . command !r} : no mock loom\" ) async def cmd_upload ( self , command : SimpleNamespace ) -> None : docs \"\"\"Handle the upload command.\"\"\" suffix = command . name [ - 4 :] if self . verbose : cmd_data = command . data if len ( cmd_data ) > MAX_LOG_PATTERN_LEN : cmd_data = cmd_data [ 0 : MAX_LOG_PATTERN_LEN ] + \"...\" self . log . info ( f \" { self } : read weaving pattern { command . name !r} : data= { cmd_data !r} \" , ) pattern_data = read_pattern_data ( command . data , suffix = suffix , name = command . name ) pattern = reduced_pattern_from_pattern_data ( name = command . name , data = pattern_data ) # Check that the pattern does not require too many shafts. # max_shaft_num needs +1 because pattern.threading is 0-based. max_shaft_num = max ( pattern . threading ) + 1 if max_shaft_num > self . loom_info . num_shafts : raise CommandError ( f \"Pattern { command . name !r} max shaft { max_shaft_num } > { self . loom_info . num_shafts } \" ) pattern . thread_group_size = self . settings . thread_group_size await self . add_pattern ( pattern ) def get_threading_shaft_word ( self ) -> int : docs \"\"\"Get the current threading shaft word.\"\"\" if self . current_pattern is None : return 0 return self . current_pattern . get_threading_shaft_word () async def handle_next_pick_request ( self ) -> bool : docs \"\"\"Handle next pick request from loom. Call this from handle_loom_reply. Figure out the next pick, send it to the loom, and report the current pick or end numbers to the client (if we were not at the beginning of the work). Returns: did_advance: True if the loom was sent the next set of shafts. False if in Setting mode, or no current pattern, or attemped to go beyond the start of the pattern. \"\"\" if not self . current_pattern : return False did_advance = False match self . mode : case ModeEnum . WEAVE : # Command a new pick, if there is one. if self . jump_pick . pick_number is not None : self . current_pattern . set_current_pick_number ( self . jump_pick . pick_number ) else : try : self . increment_pick_number () except IndexError : await self . write_to_client ( client_replies . StatusMessage ( message = self . t ( \"At start of weaving\" ), severity = MessageSeverityEnum . ERROR , ) ) return False if self . jump_pick . pick_repeat_number is not None : self . current_pattern . pick_repeat_number = self . jump_pick . pick_repeat_number pick = self . current_pattern . get_current_pick () await self . write_shafts_to_loom ( pick . shaft_word ) await self . clear_jumps () await self . report_current_pick_number () did_advance = True case ModeEnum . THREAD : # Advance to the next thread group, if there is one if self . jump_end . end_number0 is not None : self . current_pattern . set_current_end_number ( end_number0 = self . jump_end . end_number0 , end_number1 = self . jump_end . end_number1 , end_repeat_number = self . jump_end . end_repeat_number , ) else : try : self . increment_end_number () except IndexError : await self . write_to_client ( client_replies . StatusMessage ( message = self . t ( \"At start of threading\" ), severity = MessageSeverityEnum . ERROR , ) ) return False shaft_word = self . get_threading_shaft_word () await self . write_shafts_to_loom ( shaft_word ) await self . clear_jumps () await self . report_current_end_numbers () did_advance = True case ModeEnum . SETTINGS : self . log . warning ( \"Next pick ignored in SETTINGS mode\" ) case _ : raise RuntimeError ( f \"Invalid mode= { self . mode !r} .\" ) return did_advance def increment_pick_number ( self ) -> int : docs \"\"\"Increment pick_number in the current direction. Increment pick_repeat_number as well, if appropriate. Return the new pick number. This will be 0 if pick_repeat_number changed, or if unweaving and pick_repeat_number would be decremented to 0. \"\"\" if self . current_pattern is None : return 0 return self . current_pattern . increment_pick_number ( direction_forward = self . direction_forward ) def increment_end_number ( self ) -> None : docs \"\"\"Increment end_number0 in the current direction.\"\"\" if self . current_pattern is None : return self . current_pattern . increment_end_number ( thread_low_to_high = self . thread_low_to_high ) def load_settings ( self ) -> None : docs \"\"\"Read the settings file, if it exists. Usable entries will replace the values in `self.settings` (which must already be set to a valid value). Unusable entries will be ignored, with a logged warning. \"\"\" if not self . settings_path . exists (): self . log . info ( f \"Settings file { self . settings_path } does not exist\" ) return try : with self . settings_path . open ( \"r\" ) as f : settings_dict = json . load ( f ) except Exception as e : self . log . warning ( f \"Deleting settings file { self . settings_path } because it could not be read as json: { e !r} \" ) self . settings_path . unlink () return # Use raw_value to avoid warnings about overwriting a loop variable. for key , raw_value in settings_dict . items (): value = raw_value if key == \"type\" : continue default_value = getattr ( self . settings , key , None ) if default_value is None : self . log . warning ( f \"Ignoring setting { key } = { value !r} : uknown key\" ) continue if key == \"direction_control\" : try : value = DirectionControlEnum ( value ) except Exception : self . log . warning ( f \"Ignoring setting { key } = { value !r} : invalid enum value\" ) continue if self . supports_full_direction_control : if value is not DirectionControlEnum . FULL : self . log . warning ( f \"Ingoring setting { key } = { value !r} : loom supports full direction control\" ) continue elif value is DirectionControlEnum . FULL : self . log . warning ( f \"Ignoring setting { key } = { value !r} : loom doesn't support full direction control\" ) continue elif key == \"language\" : try : self . translation_dict = get_translation_dict ( language = value , logger = self . log ) except Exception as e : self . log . error ( f \"Failed to load translation dict { value !r} : { e !r} \" ) continue if not isinstance ( value , type ( default_value )): self . log . warning ( f \"Ignoring setting { key } = { value !r} : invalid value\" ) continue if key == \"thread_group_size\" and ( value < 1 or value > MAX_THREAD_GROUP_SIZE ): self . log . warning ( f \"Ignoring setting { key } = { value !r} : not in range [1, { MAX_THREAD_GROUP_SIZE } \" ) continue setattr ( self . settings , key , value ) async def read_client_loop ( self ) -> None : docs \"\"\"Read and process commands from the client.\"\"\" # report loom connection state # and (if connected) request loom status try : self . client_connected = True await self . report_initial_server_state () if not self . loom_connected : await self . connect_to_loom () while self . client_connected : assert self . websocket is not None try : data = await self . websocket . receive_json () except json . JSONDecodeError : self . log . info ( f \" { self } : ignoring invalid command: not json-encoded\" ) # Parse the command try : cmd_type = data . get ( \"type\" ) if cmd_type is None : await self . report_command_problem ( message = f \"Invalid command; no 'type' field: { data !r} \" , severity = MessageSeverityEnum . WARNING , ) continue command = SimpleNamespace ( ** data ) if self . verbose : msg_summary = str ( command ) if command . type == \"upload\" and len ( msg_summary ) > MAX_LOG_PATTERN_LEN : msg_summary = msg_summary [ 0 : MAX_LOG_PATTERN_LEN ] + \"...\" self . log . info ( f \" { self } : read command { msg_summary } \" ) cmd_handler = getattr ( self , f \"cmd_ { cmd_type } \" , None ) except Exception as e : message = f \"command { data } failed: { e !r} \" self . log . exception ( f \" { self } : { message } \" ) await self . report_command_done ( cmd_type = cmd_type , success = False , message = message ) # Execute the command try : if cmd_handler is None : await self . report_command_done ( cmd_type = cmd_type , success = False , message = f \"Invalid command; unknown type { cmd_type !r} \" , ) continue await cmd_handler ( command ) await self . report_command_done ( cmd_type = cmd_type , success = True ) except CommandError as e : await self . report_command_done ( cmd_type = cmd_type , success = False , message = str ( e )) except Exception as e : message = f \"command { command } unexpectedly failed: { e !r} \" self . log . exception ( f \" { self } : { message } \" ) await self . report_command_done ( cmd_type = cmd_type , success = False , message = message ) except asyncio . CancelledError : return except WebSocketDisconnect : self . log . info ( f \" { self } : client disconnected\" ) return except Exception as e : self . log . exception ( f \" { self } : bug: client read looop failed\" ) await self . report_command_problem ( message = \"Client read loop failed; try refreshing\" , severity = MessageSeverityEnum . ERROR , ) self . client_connected = False if self . websocket is not None : await self . close_websocket ( self . websocket , code = CloseCode . ERROR , reason = repr ( e )) async def read_loom_loop ( self ) -> None : docs \"\"\"Read and process replies from the loom.\"\"\" try : if self . loom_reader is None : raise RuntimeError ( \"No loom reader\" ) # noqa: TRY301 await self . get_initial_loom_state () while True : reply_bytes = await self . basic_read_loom () if self . verbose : self . log . info ( f \" { self } : read loom reply: { reply_bytes !r} \" ) if not reply_bytes : self . log . warning ( \"Reader closed; quit read_loom_loop\" ) return await self . handle_loom_reply ( reply_bytes ) except asyncio . CancelledError : pass except Exception as e : message = f \"Server stopped listening to the loom: { e !r} \" self . log . exception ( f \" { self } : { message } \" ) await self . report_command_problem ( message = message , severity = MessageSeverityEnum . ERROR , ) await self . disconnect_from_loom () docs async def report_command_done ( self , * , cmd_type : str , success : bool , message : str = \"\" ) -> None : \"\"\"Report completion of a command.\"\"\" reply = client_replies . CommandDone ( cmd_type = cmd_type , success = success , message = message ) await self . write_to_client ( reply ) docs async def report_command_problem ( self , message : str , severity : MessageSeverityEnum ) -> None : \"\"\"Report a CommandProblem to the client.\"\"\" reply = client_replies . CommandProblem ( message = message , severity = severity ) await self . write_to_client ( reply ) async def report_current_pattern ( self ) -> None : docs \"\"\"Report pattern to the client.\"\"\" if self . current_pattern is not None : await self . write_to_client ( self . current_pattern ) async def report_initial_server_state ( self ) -> None : docs \"\"\"Report server state. Called just after a client connects to the server. \"\"\" await self . report_loom_connection_state () await self . write_to_client ( self . loom_info ) await self . report_language_names () await self . report_settings () await self . report_mode () await self . report_pattern_names () await self . report_direction () await self . clear_jumps ( force_output = True ) await self . report_current_pattern () await self . report_current_end_numbers () await self . report_current_pick_number () await self . report_separate_threading_repeats () await self . report_separate_weaving_repeats () await self . report_shaft_state () await self . report_thread_group_size () docs async def report_loom_connection_state ( self , reason : str = \"\" ) -> None : \"\"\"Report LoomConnectionState to the client.\"\"\" if self . loom_connecting : state = client_replies . ConnectionStateEnum . CONNECTING elif self . loom_disconnecting : state = client_replies . ConnectionStateEnum . DISCONNECTING elif self . loom_connected : state = client_replies . ConnectionStateEnum . CONNECTED else : state = client_replies . ConnectionStateEnum . DISCONNECTED reply = client_replies . LoomConnectionState ( state = state , reason = reason ) await self . write_to_client ( reply ) async def report_pattern_names ( self ) -> None : docs \"\"\"Report PatternNames to the client.\"\"\" names = await self . pattern_db . get_pattern_names () reply = client_replies . PatternNames ( names = names ) await self . write_to_client ( reply ) async def report_current_pick_number ( self ) -> None : docs \"\"\"Report CurrentPickNumber to the client. Also update pick information in the database. \"\"\" if self . current_pattern is None : return await self . pattern_db . update_pick_number ( pattern_name = self . current_pattern . name , pick_number = self . current_pattern . pick_number , pick_repeat_number = self . current_pattern . pick_repeat_number , ) reply = client_replies . CurrentPickNumber ( total_pick_number = compute_total_num ( num_within = self . current_pattern . pick_number , repeat_number = self . current_pattern . pick_repeat_number , repeat_len = self . current_pattern . num_picks , ), pick_number = self . current_pattern . pick_number , pick_repeat_number = self . current_pattern . pick_repeat_number , ) await self . write_to_client ( reply ) async def report_current_end_numbers ( self ) -> None : docs \"\"\"Report CurrentEndNumber to the client. Also update threading information the database. \"\"\" if self . current_pattern is None : return await self . pattern_db . update_end_number ( pattern_name = self . current_pattern . name , end_number0 = self . current_pattern . end_number0 , end_number1 = self . current_pattern . end_number1 , end_repeat_number = self . current_pattern . end_repeat_number , ) total_end_number0 = compute_total_num ( num_within = self . current_pattern . end_number0 , repeat_number = self . current_pattern . end_repeat_number , repeat_len = self . current_pattern . num_ends , ) total_end_number1 = compute_total_num ( num_within = self . current_pattern . end_number1 , repeat_number = self . current_pattern . end_repeat_number , repeat_len = self . current_pattern . num_ends , ) reply = client_replies . CurrentEndNumber ( total_end_number0 = total_end_number0 , total_end_number1 = total_end_number1 , end_number0 = self . current_pattern . end_number0 , end_number1 = self . current_pattern . end_number1 , end_repeat_number = self . current_pattern . end_repeat_number , ) await self . write_to_client ( reply ) async def report_jump_end ( self ) -> None : docs \"\"\"Report JumpEndNumber to the client.\"\"\" await self . write_to_client ( self . jump_end ) async def report_jump_pick ( self ) -> None : docs \"\"\"Report JumpPickNumber to the client.\"\"\" await self . write_to_client ( self . jump_pick ) async def report_shaft_state ( self ) -> None : docs \"\"\"Report ShaftState to the client.\"\"\" await self . write_to_client ( client_replies . ShaftState ( state = self . shaft_state , shaft_word = self . shaft_word ) ) async def report_mode ( self ) -> None : docs \"\"\"Report the current mode to the client.\"\"\" await self . write_to_client ( client_replies . Mode ( mode = self . mode )) async def report_separate_threading_repeats ( self ) -> None : docs \"\"\"Report SeparateThreadingRepeats.\"\"\" if self . current_pattern is None : return await self . write_to_client ( client_replies . SeparateThreadingRepeats ( separate = self . current_pattern . separate_threading_repeats ) ) async def report_separate_weaving_repeats ( self ) -> None : docs \"\"\"Report SeparateWeavingRepeats.\"\"\" if self . current_pattern is None : return await self . write_to_client ( client_replies . SeparateWeavingRepeats ( separate = self . current_pattern . separate_weaving_repeats ) ) async def report_settings ( self ) -> None : docs \"\"\"Report Settings.\"\"\" await self . write_to_client ( self . settings ) docs async def report_status_message ( self , message : str , severity : MessageSeverityEnum ) -> None : \"\"\"Report a status message to the client.\"\"\" await self . write_to_client ( client_replies . StatusMessage ( message = message , severity = severity )) async def report_thread_group_size ( self ) -> None : docs \"\"\"Report ThreadGroupSize.\"\"\" if self . current_pattern is None : return client_reply = client_replies . ThreadGroupSize ( group_size = self . current_pattern . thread_group_size ) await self . write_to_client ( client_reply ) async def report_language_names ( self ) -> None : docs \"\"\"Report LanguageNames.\"\"\" client_reply = client_replies . LanguageNames ( languages = get_language_names ()) await self . write_to_client ( client_reply ) async def report_direction ( self ) -> None : docs \"\"\"Report Direction.\"\"\" await self . write_to_client ( client_replies . Direction ( forward = self . direction_forward , ) ) def reset_database ( self ) -> None : docs \"\"\"Reset the pattern database (write a new one).\"\"\" self . db_path . unlink ( missing_ok = True ) self . pattern_db = PatternDatabase ( self . db_path ) def save_settings ( self ) -> None : docs \"\"\"Save the settings file.\"\"\" datadict = dataclasses . asdict ( self . settings ) del datadict [ \"type\" ] try : with self . settings_path . open ( \"w\" ) as f : json . dump ( datadict , f ) except Exception as e : self . log . error ( f \"Could not write settings file { self . settings_path } : { e !r} \" ) async def select_pattern ( self , name : str ) -> None : docs \"\"\"Select the specified pattern.\"\"\" try : pattern = await self . pattern_db . get_pattern ( name ) except LookupError : raise CommandError ( f \"select_pattern failed: no such pattern: { name } \" ) from None self . current_pattern = pattern await self . report_current_pattern () await self . report_current_end_numbers () await self . report_current_pick_number () await self . report_separate_threading_repeats () await self . report_separate_weaving_repeats () await self . report_thread_group_size () def t ( self , phrase : str ) -> str : docs \"\"\"Translate a phrase, if possible.\"\"\" if phrase not in self . translation_dict : self . log . warning ( f \" { phrase !r} not in translation dict\" ) return self . translation_dict . get ( phrase , phrase ) # Use reply: Any because dataclasses are hard to type hint async def write_to_client ( self , reply : Any ) -> None : # noqa: ANN401 docs \"\"\"Send a reply to the client. Args: reply: The reply to write, as a dataclass. It should have a \"type\" field whose value is a string. \"\"\" reply_dict = dataclasses . asdict ( reply ) if self . verbose : reply_str = str ( reply_dict ) if reply . type == \"ReducedPattern\" and len ( reply_str ) > MAX_LOG_PATTERN_LEN : reply_str = reply_str [ 0 : MAX_LOG_PATTERN_LEN ] + \"...\" else : reply_str = \"\" if self . client_connected : assert self . websocket is not None # make mypy happy if self . verbose : self . log . info ( f \" { self } : reply to client: { reply_str } \" ) await self . websocket . send_json ( reply_dict ) elif self . verbose : self . log . info ( f \" { self } : do not send reply { reply_str } ; not connected\" ) docs async def write_to_loom ( self , data : bytes | bytearray | str ) -> None : \"\"\"Send data to the loom. Args: data: The data to send, without a terminator. (This method will append the terminator). \"\"\" if self . loom_writer is None or self . loom_writer . is_closing (): raise RuntimeError ( \"Cannot write to the loom: no connection.\" ) data_bytes = data . encode () if isinstance ( data , str ) else bytes ( data ) if self . verbose : self . log . info ( f \" { self } : sending command to loom: { data_bytes + self . terminator !r} \" ) self . loom_writer . write ( data_bytes + self . terminator ) await self . loom_writer . drain () def __repr__ ( self ) -> str : return type ( self ) . __name__ async def __aenter__ ( self ) -> Self : await self . start () return self async def __aexit__ ( self , exc_type : type [ BaseException ] | None , exc_value : BaseException | None , traceback : TracebackType | None , ) -> None : await self . close ()","title":"base_loom_server.base_loom_server"},{"location":"api/base_loom_server/base_mock_loom/","text":"base_loom_server.base_mock_loom source module base_loom_server.base_mock_loom Classes BaseMockLoom \u2014 Base class for a dobby loom similator. source class BaseMockLoom ( * , num_shafts : int , verbose : bool = True ) Bases : abc . ABC Base class for a dobby loom similator. Parameters num_shafts : int \u2014 The number of shafts; must be positive. verbose : bool \u2014 If True, log diagnostic information. Methods start \u2014 Connect to the loom server client and start reading commands. close \u2014 Shut down the mock loom. handle_read_bytes \u2014 Handle one command from the web server. report_direction \u2014 Report direction (weaving/unweaving). report_motion_state \u2014 Report the motion state of the shafts. report_pick_wanted \u2014 Report that a pick is wanted. report_shafts \u2014 Report shaft position. basic_read \u2014 Read one command to the loom. oob_command \u2014 Handle out-of-band commands. oob_command_c \u2014 Close the connection. oob_command_d \u2014 Toggle weave direction. oob_command_n \u2014 Request next pick. open_client_connection \u2014 Open a connection to the loom server client. connected \u2014 Am I connected to the loom server client? move \u2014 Move shafts. read_loop \u2014 Read commands from the loom server. report_initial_status \u2014 Report initial status. set_shaft_word \u2014 Set shafts to raise. set_direction_forward \u2014 Set the direction_forward attribute. write \u2014 Write the specified unterminated data to the client. source async method BaseMockLoom . start ( self ) \u2192 None Connect to the loom server client and start reading commands. source async method BaseMockLoom . close ( self , * , cancel_read_loop : bool = True ) \u2192 None Shut down the mock loom. source async method BaseMockLoom . handle_read_bytes ( self , read_bytes : bytes ) \u2192 None Handle one command from the web server. Raises NotImplementedError source async method BaseMockLoom . report_direction ( self ) \u2192 None Report direction (weaving/unweaving). Raises NotImplementedError source async method BaseMockLoom . report_motion_state ( self ) \u2192 None Report the motion state of the shafts. Raises NotImplementedError source async method BaseMockLoom . report_pick_wanted ( self ) \u2192 None Report that a pick is wanted. Raises NotImplementedError source async method BaseMockLoom . report_shafts ( self ) \u2192 None Report shaft position. Raises NotImplementedError source async method BaseMockLoom . basic_read ( self ) \u2192 bytes Read one command to the loom. Perform no error checking, except that self.reader exists. source async method BaseMockLoom . oob_command ( self , cmd : str ) \u2192 None Handle out-of-band commands. Find a method named \"oob_command_{cmdchar}\", where cmdchar = cmd[0] , and call it with one positional argument: cmd . None of the standard oob commands pay attention to the cmd argument, but subclasses may add other oob commands, and those may accept data. source async method BaseMockLoom . oob_command_c ( self , cmd : str ) \u2192 None Close the connection. source async method BaseMockLoom . oob_command_d ( self , cmd : str ) \u2192 None Toggle weave direction. source async method BaseMockLoom . oob_command_n ( self , cmd : str ) \u2192 None Request next pick. source async method BaseMockLoom . open_client_connection ( self ) \u2192 tuple[ StreamReaderType , StreamWriterType ] Open a connection to the loom server client. Raises RuntimeError source method BaseMockLoom . connected ( ) \u2192 bool Am I connected to the loom server client? source async method BaseMockLoom . move ( self , shaft_word : int ) \u2192 None Move shafts. source async method BaseMockLoom . read_loop ( self ) \u2192 None Read commands from the loom server. source async method BaseMockLoom . report_initial_status ( self ) \u2192 None Report initial status. source async method BaseMockLoom . set_shaft_word ( self , shaft_word : int ) \u2192 None Set shafts to raise. source async method BaseMockLoom . set_direction_forward ( self , direction_forward : bool ) \u2192 None Set the direction_forward attribute. source async method BaseMockLoom . write ( self , data : bytes | bytearray | str ) \u2192 None Write the specified unterminated data to the client.","title":"base_loom_server.base_mock_loom"},{"location":"src/base_loom_server/base_mock_loom/","text":"base_loom_server.base_mock_loom docs module base_loom_server.base_mock_loom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 from __future__ import annotations __all__ = [ \"BaseMockLoom\" ] import abc import asyncio import logging import threading from typing import TYPE_CHECKING , Self if TYPE_CHECKING : from types import TracebackType from .constants import LOG_NAME from .mock_streams import ( MockStreamReader , MockStreamWriter , StreamReaderType , StreamWriterType , open_mock_connection , ) DIRECTION_NAMES = { True : \"weave\" , False : \"unweave\" } class BaseMockLoom ( abc . ABC ): docs \"\"\"Base class for a dobby loom similator. Args: num_shafts: The number of shafts; must be positive. verbose: If True, log diagnostic information. Notes: To control a mock loom: * Call `reader.create_writer` to create a command writer. * Call `writer.create_reader` to create a reply reader. * Read replies from the reply reader. * Write commands to the command writer. \"\"\" terminator = b \" \\n \" motion_duration : float = 1 # seconds def __init__ ( self , * , num_shafts : int , verbose : bool = True ) -> None : if num_shafts <= 0 : raise ValueError ( f \" { num_shafts =} must be positive\" ) self . num_shafts = num_shafts self . log = logging . getLogger ( LOG_NAME ) self . verbose = verbose self . moving : bool = False self . pick_wanted : bool = False self . shaft_word : int = 0 self . direction_forward : bool = True self . writer : StreamWriterType | None = None self . reader : StreamReaderType | None = None self . done_task : asyncio . Future = asyncio . Future () self . move_task : asyncio . Future = asyncio . Future () self . read_loop_task : asyncio . Future = asyncio . Future () self . start_task = asyncio . create_task ( self . start ()) # When closing, store a reference to the close task # to prevent premature garbage collection. self . close_task : asyncio . Future | None = None # This event is set whenever a command is received. # It is solely intended for tests, and is used as follows: # * Clear the event # * Send a command to the loom # * Wait for the event before checking loom state # It is needed for testing looms that do not output # state information, such as Toika ES. self . command_event = asyncio . Event () # A threading version for use with fastapi.testclient.TestClient # which is, alas, synchronous. self . command_threading_event = threading . Event () self . __post_init__ () def __post_init__ ( self ) -> None : # noqa: B027 \"\"\"Subclases may override this method, preferably instead of overriding the constructor. Called at the end of the constructor. By default this is a no-op so subclases need not call `super().__post_init__()` \"\"\" async def start ( self ) -> None : docs \"\"\"Connect to the loom server client and start reading commands.\"\"\" self . reader , self . writer = open_mock_connection ( terminator = self . terminator ) self . read_loop_task = asyncio . create_task ( self . read_loop ()) async def close ( self , * , cancel_read_loop : bool = True ) -> None : docs \"\"\"Shut down the mock loom.\"\"\" self . start_task . cancel () if cancel_read_loop : self . read_loop_task . cancel () if self . writer is not None : self . writer . close () await self . writer . wait_closed () if not self . done_task . done (): self . done_task . set_result ( None ) @abc . abstractmethod async def handle_read_bytes ( self , read_bytes : bytes ) -> None : docs \"\"\"Handle one command from the web server.\"\"\" raise NotImplementedError @abc . abstractmethod async def report_direction ( self ) -> None : docs \"\"\"Report direction (weaving/unweaving).\"\"\" raise NotImplementedError @abc . abstractmethod async def report_motion_state ( self ) -> None : docs \"\"\"Report the motion state of the shafts.\"\"\" raise NotImplementedError @abc . abstractmethod async def report_pick_wanted ( self ) -> None : docs \"\"\"Report that a pick is wanted.\"\"\" raise NotImplementedError @abc . abstractmethod async def report_shafts ( self ) -> None : docs \"\"\"Report shaft position.\"\"\" raise NotImplementedError async def basic_read ( self ) -> bytes : docs \"\"\"Read one command to the loom. Perform no error checking, except that self.reader exists. \"\"\" assert self . reader is not None # make mypy happy return await self . reader . readuntil ( self . terminator ) async def oob_command ( self , cmd : str ) -> None : docs \"\"\"Handle out-of-band commands. Find a method named \"oob_command_{cmdchar}\", where `cmdchar = cmd[0]`, and call it with one positional argument: `cmd`. None of the standard oob commands pay attention to the `cmd` argument, but subclasses may add other oob commands, and those may accept data. \"\"\" if not cmd : return cmdchar = cmd [ 0 ] method = getattr ( self , f \"oob_command_ { cmdchar } \" , None ) if method is None : self . log . warning ( f \" { self } : unrecognized oob command: { cmd !r} \" ) return await method ( cmd ) async def oob_command_c ( self , cmd : str ) -> None : # noqa: ARG002 docs \"\"\"Close the connection.\"\"\" if self . verbose : self . log . info ( f \" { self } : oob close command\" ) # Don't await close, because the wait will be aborted # when close cancels the read loop. self . close_task = asyncio . create_task ( self . close ()) async def oob_command_d ( self , cmd : str ) -> None : # noqa: ARG002 docs \"\"\"Toggle weave direction.\"\"\" self . direction_forward = not self . direction_forward await self . report_direction () if self . verbose : self . log . info ( f \" { self } : oob toggle weave direction to: { DIRECTION_NAMES [ self . direction_forward ] } \" ) async def oob_command_n ( self , cmd : str ) -> None : # noqa: ARG002 docs \"\"\"Request next pick.\"\"\" if self . verbose : self . log . info ( f \" { self } : oob request next pick\" ) self . pick_wanted = True await self . report_pick_wanted () docs async def open_client_connection ( self ) -> tuple [ StreamReaderType , StreamWriterType ]: \"\"\"Open a connection to the loom server client.\"\"\" await self . start_task assert self . writer is not None assert self . reader is not None # The isinstance tests make mypy happy, and might catch # a future bug if I figure out how to use virtual serial ports. if isinstance ( self . writer , MockStreamWriter ) and isinstance ( self . reader , MockStreamReader ): await self . report_initial_status () return ( self . writer . create_reader (), self . reader . create_writer (), ) raise RuntimeError ( f \"Bug: { self . reader =} and { self . writer =} must both be mock streams\" ) def connected ( self ) -> bool : docs \"\"\"Am I connected to the loom server client?\"\"\" return ( self . reader is not None and self . writer is not None and not self . reader . at_eof () and not self . writer . is_closing () ) async def move ( self , shaft_word : int ) -> None : docs \"\"\"Move shafts.\"\"\" self . moving = True await self . report_motion_state () await asyncio . sleep ( self . motion_duration ) self . moving = False self . shaft_word = shaft_word await self . report_shafts () await self . report_motion_state () async def read_loop ( self ) -> None : docs \"\"\"Read commands from the loom server.\"\"\" try : while self . connected (): assert self . reader is not None # make mypy happy cmd_bytes = await self . basic_read () if not cmd_bytes : # Connection has closed break self . command_event . set () self . command_threading_event . set () await self . handle_read_bytes ( cmd_bytes ) except Exception : self . log . exception ( f \" { self } : read_loop failed; giving up\" ) await self . close ( cancel_read_loop = False ) async def report_initial_status ( self ) -> None : docs \"\"\"Report initial status.\"\"\" await self . report_direction () await self . report_motion_state () await self . report_pick_wanted () async def set_shaft_word ( self , shaft_word : int ) -> None : docs \"\"\"Set shafts to raise.\"\"\" # Ignore the command unless a pick is wanted if not self . pick_wanted : return self . pick_wanted = False await self . report_pick_wanted () self . move_task . cancel () if self . verbose : self . log . info ( f \" { self } : raise shafts { self . shaft_word : 08x } \" ) self . move_task = asyncio . create_task ( self . move ( shaft_word = shaft_word )) async def set_direction_forward ( docs self , direction_forward : bool , # noqa: FBT001 ) -> None : \"\"\"Set the direction_forward attribute.\"\"\" self . direction_forward = bool ( direction_forward ) if self . verbose : self . log . info ( f \" { self } : set { direction_forward =} by software\" ) await self . report_direction () async def write ( self , data : bytes | bytearray | str ) -> None : docs \"\"\"Write the specified unterminated data to the client.\"\"\" if self . verbose : self . log . info ( f \" { self } : send reply { data !r} \" ) if self . connected (): data_bytes : bytes = data . encode () if isinstance ( data , str ) else bytes ( data ) assert self . writer is not None self . writer . write ( data_bytes + self . terminator ) await self . writer . drain () def __repr__ ( self ) -> str : return type ( self ) . __name__ async def __aenter__ ( self ) -> Self : await self . start () return self async def __aexit__ ( self , exc_type : type [ BaseException ] | None , exc_value : BaseException | None , traceback : TracebackType | None , ) -> None : await self . close ()","title":"base_loom_server.base_mock_loom"},{"location":"api/base_loom_server/check_translation_files/","text":"base_loom_server.check_translation_files source module base_loom_server.check_translation_files Functions check_translation_files \u2014 Check for issues in the language translation files. report_problems \u2014 Check for issues in one file and print the results to stdout. source check_translation_files ( ) \u2192 None Check for issues in the language translation files. Report to stdout. source report_problems ( * , filepath : Traversable , desired_keys : set[str] , lang_dict : dict[str, Any ] , report_missing_keys : bool ) \u2192 None Check for issues in one file and print the results to stdout.","title":"base_loom_server.check_translation_files"},{"location":"src/base_loom_server/check_translation_files/","text":"base_loom_server.check_translation_files docs module base_loom_server.check_translation_files 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 # ruff: noqa: T201 import importlib.resources import json from importlib.resources.abc import Traversable from typing import Any PKG_FILES = importlib . resources . files ( \"base_loom_server\" ) LOCALE_FILES = PKG_FILES . joinpath ( \"locales\" ) def check_translation_files () -> None : docs \"\"\"Check for issues in the language translation files. Report to stdout. \"\"\" default_dict = json . loads ( LOCALE_FILES . joinpath ( \"default.json\" ) . read_text ( encoding = \"utf_8\" )) desired_keys = set ( default_dict . keys ()) for filepath in LOCALE_FILES . glob ( \"*.json\" ): # type: ignore[attr-defined] if filepath . name == \"default.json\" : continue languages_seen = set () dict_list = [] lang_dict = json . loads ( filepath . read_text ( encoding = \"utf_8\" )) report_problems ( filepath = filepath , desired_keys = desired_keys , lang_dict = lang_dict , report_missing_keys = False , ) dict_list . append ( lang_dict ) languages_seen . add ( filepath . stem ) prev_path = filepath while True : next_language = lang_dict . get ( \"_extends\" ) if not next_language : break if next_language in languages_seen : print ( f \"Circular dependency found in { next_language } ; giving up on { prev_path . name } \" ) break next_path = LOCALE_FILES . joinpath ( f \" { next_language } .json\" ) if not next_path . is_file (): print ( f \"Dependency { next_path } not found in { prev_path . name } ; giving up\" ) break lang_dict = json . loads ( next_path . read_text ( encoding = \"utf_8\" )) dict_list . append ( lang_dict ) report_problems ( filepath = next_path , desired_keys = desired_keys , lang_dict = lang_dict , report_missing_keys = False , ) # Ignore default_dict when producing full_dict # so we can detect missing keys full_dict_without_default = {} for subdict in reversed ( dict_list ): full_dict_without_default . update ( subdict ) report_problems ( filepath = filepath , desired_keys = desired_keys , lang_dict = full_dict_without_default , report_missing_keys = True , ) KeysToIgnore = { \"?\" , \"_direction\" , \"_extends\" , \"_language_code\" } def report_problems ( docs * , filepath : Traversable , desired_keys : set [ str ], lang_dict : dict [ str , Any ], report_missing_keys : bool , ) -> None : \"\"\"Check for issues in one file and print the results to stdout.\"\"\" missing_keys = desired_keys - lang_dict . keys () - KeysToIgnore if report_missing_keys else set () extra_keys = lang_dict . keys () - desired_keys blank_keys = { key : value for key , value in lang_dict . items () if value == \"\" } non_str_entries = { key : value for key , value in lang_dict . items () if not isinstance ( value , str )} if missing_keys or extra_keys or blank_keys or non_str_entries : print ( f \" { filepath . name } has one or more problems:\" ) if missing_keys : print ( f \" missing keys: { missing_keys } \" ) if extra_keys : print ( f \" extra keys: { extra_keys } \" ) if blank_keys : print ( f \" blank entries: { blank_keys } \" ) if non_str_entries : print ( f \" non-str entries: { non_str_entries } \" ) elif report_missing_keys : print ( f \" { filepath . name } is complete\" )","title":"base_loom_server.check_translation_files"},{"location":"api/base_loom_server/client_replies/","text":"base_loom_server.client_replies source module base_loom_server.client_replies Classes CommandDone \u2014 Report completion or failure of a command. CommandProblem \u2014 A problem with a command from the client. CurrentEndNumber \u2014 The current threading end numbers and repeat number. CurrentPickNumber \u2014 The current total_pick_number, pick_number and pick_repeat_number. Direction \u2014 The weaving and threading direction. JumpEndNumber \u2014 Pending end and repeat numbers. JumpPickNumber \u2014 Pending total_pick_number, pick_number, and pick_repeat_number. LanguageNames \u2014 Supported languages. LoomConnectionState \u2014 The state of the server's connection to the loom. LoomInfo \u2014 Information about the loom. Mode \u2014 The mode of the server. SeparateThreadingRepeats \u2014 Separate weaving repeats? SeparateWeavingRepeats \u2014 Separate weaving repeats? Settings \u2014 Settings for the settings file (which apply to all patterns). ShaftState \u2014 Shaft status. StatusMessage \u2014 Status message. PatternNames \u2014 The list of loaded patterns (including the current pattern). ThreadGroupSize \u2014 The threading group size for the current pattern. source dataclass CommandDone ( cmd_type : str , success : bool , message : str ) Report completion or failure of a command. source dataclass CommandProblem ( message : str , severity : MessageSeverityEnum ) A problem with a command from the client. source dataclass CurrentEndNumber ( total_end_number0 : int , total_end_number1 : int , end_number0 : int , end_number1 : int , end_repeat_number : int ) The current threading end numbers and repeat number. The range of end numbers is end_number0 through end_number1, inclusive. If end_number0 is 0 then end_number1 will also be 0; this indicates the beginning, or a gap between pattern repeats. source dataclass CurrentPickNumber ( total_pick_number : int , pick_number : int , pick_repeat_number : int ) The current total_pick_number, pick_number and pick_repeat_number. source dataclass Direction ( forward : bool ) The weaving and threading direction. source dataclass JumpEndNumber ( total_end_number0 : int | None = None , total_end_number1 : int | None = None , end_number0 : int | None = None , end_number1 : int | None = None , end_repeat_number : int | None = None ) Pending end and repeat numbers. source dataclass JumpPickNumber ( total_pick_number : int | None = None , pick_number : int | None = None , pick_repeat_number : int | None = None ) Pending total_pick_number, pick_number, and pick_repeat_number. If total_pick_number is not None then pick_number and pick_repeat_number must also not be None. source dataclass LanguageNames ( languages : list[str] ) Supported languages. source dataclass LoomConnectionState ( state : ConnectionStateEnum , reason : str = '' ) The state of the server's connection to the loom. source dataclass LoomInfo ( num_shafts : int , serial_port : str , is_mock : bool ) Information about the loom. source dataclass Mode ( mode : ModeEnum ) The mode of the server. source dataclass SeparateThreadingRepeats ( separate : bool ) Separate weaving repeats? source dataclass SeparateWeavingRepeats ( separate : bool ) Separate weaving repeats? source dataclass Settings ( language : str , loom_name : str , direction_control : DirectionControlEnum , end1_on_right : bool , thread_group_size : int , thread_right_to_left : bool , thread_back_to_front : bool ) Settings for the settings file (which apply to all patterns). source dataclass ShaftState ( state : ShaftStateEnum , shaft_word : int ) Shaft status. shaft_word is a bitmask: bit 0 = shaft 1, etc. bit value is 0 if shaft is up shaft_word is only meaningful if state = ShaftStateEnum.DONE source dataclass StatusMessage ( message : str , severity : MessageSeverityEnum ) Status message. source dataclass PatternNames ( names : list[str] ) The list of loaded patterns (including the current pattern). source dataclass ThreadGroupSize ( group_size : int ) The threading group size for the current pattern.","title":"base_loom_server.client_replies"},{"location":"src/base_loom_server/client_replies/","text":"base_loom_server.client_replies docs module base_loom_server.client_replies 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 import dataclasses from .enums import ( ConnectionStateEnum , DirectionControlEnum , MessageSeverityEnum , ModeEnum , ShaftStateEnum , ) @dataclasses . dataclass class CommandDone : docs \"\"\"Report completion or failure of a command.\"\"\" type : str = dataclasses . field ( init = False , default = \"CommandDone\" ) cmd_type : str success : bool message : str @dataclasses . dataclass class CommandProblem : docs \"\"\"A problem with a command from the client.\"\"\" type : str = dataclasses . field ( init = False , default = \"CommandProblem\" ) message : str severity : MessageSeverityEnum @dataclasses . dataclass class CurrentEndNumber : docs \"\"\"The current threading end numbers and repeat number. The range of end numbers is end_number0 through end_number1, inclusive. If end_number0 is 0 then end_number1 will also be 0; this indicates the beginning, or a gap between pattern repeats. \"\"\" type : str = dataclasses . field ( init = False , default = \"CurrentEndNumber\" ) total_end_number0 : int total_end_number1 : int end_number0 : int end_number1 : int end_repeat_number : int @dataclasses . dataclass class CurrentPickNumber : docs \"\"\"The current total_pick_number, pick_number and pick_repeat_number.\"\"\" type : str = dataclasses . field ( init = False , default = \"CurrentPickNumber\" ) total_pick_number : int pick_number : int pick_repeat_number : int @dataclasses . dataclass class Direction : docs \"\"\"The weaving and threading direction.\"\"\" type : str = dataclasses . field ( init = False , default = \"Direction\" ) forward : bool @dataclasses . dataclass class JumpEndNumber : docs \"\"\"Pending end and repeat numbers.\"\"\" type : str = dataclasses . field ( init = False , default = \"JumpEndNumber\" ) total_end_number0 : int | None = None total_end_number1 : int | None = None end_number0 : int | None = None end_number1 : int | None = None end_repeat_number : int | None = None @dataclasses . dataclass class JumpPickNumber : docs \"\"\"Pending total_pick_number, pick_number, and pick_repeat_number. If total_pick_number is not None then pick_number and pick_repeat_number must also not be None. \"\"\" type : str = dataclasses . field ( init = False , default = \"JumpPickNumber\" ) total_pick_number : int | None = None pick_number : int | None = None pick_repeat_number : int | None = None def __post_init__ ( self ) -> None : if self . total_pick_number is not None and ( self . pick_number is None or self . pick_repeat_number is None ): raise ValueError ( f \" { self . pick_number =} and { self . pick_repeat_number =} must not be None \" f \"if { self . total_pick_number =} is not None\" ) @dataclasses . dataclass class LanguageNames : docs \"\"\"Supported languages.\"\"\" type : str = dataclasses . field ( init = False , default = \"LanguageNames\" ) languages : list [ str ] @dataclasses . dataclass class LoomConnectionState : docs \"\"\"The state of the server's connection to the loom.\"\"\" type : str = dataclasses . field ( init = False , default = \"LoomConnectionState\" ) state : ConnectionStateEnum reason : str = \"\" @dataclasses . dataclass class LoomInfo : docs \"\"\"Information about the loom.\"\"\" type : str = dataclasses . field ( init = False , default = \"LoomInfo\" ) num_shafts : int serial_port : str is_mock : bool @dataclasses . dataclass class Mode : docs \"\"\"The mode of the server.\"\"\" type : str = dataclasses . field ( init = False , default = \"Mode\" ) mode : ModeEnum @dataclasses . dataclass class SeparateThreadingRepeats : docs \"\"\"Separate weaving repeats?\"\"\" type : str = dataclasses . field ( init = False , default = \"SeparateThreadingRepeats\" ) separate : bool @dataclasses . dataclass class SeparateWeavingRepeats : docs \"\"\"Separate weaving repeats?\"\"\" type : str = dataclasses . field ( init = False , default = \"SeparateWeavingRepeats\" ) separate : bool @dataclasses . dataclass class Settings : docs \"\"\"Settings for the settings file (which apply to all patterns).\"\"\" type : str = dataclasses . field ( init = False , default = \"Settings\" ) language : str loom_name : str direction_control : DirectionControlEnum end1_on_right : bool thread_group_size : int thread_right_to_left : bool thread_back_to_front : bool @dataclasses . dataclass class ShaftState : docs \"\"\"Shaft status. shaft_word is a bitmask: * bit 0 = shaft 1, etc. * bit value is 0 if shaft is up shaft_word is only meaningful if state = ShaftStateEnum.DONE \"\"\" type : str = dataclasses . field ( init = False , default = \"ShaftState\" ) state : ShaftStateEnum shaft_word : int @dataclasses . dataclass class StatusMessage : docs \"\"\"Status message.\"\"\" type : str = dataclasses . field ( init = False , default = \"StatusMessage\" ) message : str severity : MessageSeverityEnum @dataclasses . dataclass class PatternNames : docs \"\"\"The list of loaded patterns (including the current pattern).\"\"\" type : str = dataclasses . field ( init = False , default = \"PatternNames\" ) names : list [ str ] @dataclasses . dataclass class ThreadGroupSize : docs \"\"\"The threading group size for the current pattern.\"\"\" type : str = dataclasses . field ( init = False , default = \"ThreadGroupSize\" ) group_size : int","title":"base_loom_server.client_replies"},{"location":"api/base_loom_server/constants/","text":"base_loom_server.constants source module base_loom_server.constants","title":"base_loom_server.constants"},{"location":"src/base_loom_server/constants/","text":"base_loom_server.constants docs module base_loom_server.constants 1 2 3 4 5 6 __all__ = [ \"LOG_NAME\" ] # Name of the primary log used by uvicorn. # This value is from https://stackoverflow.com/a/77007723 LOG_NAME = \"uvicorn.error\"","title":"base_loom_server.constants"},{"location":"api/base_loom_server/enums/","text":"base_loom_server.enums source module base_loom_server.enums Classes ConnectionStateEnum \u2014 Client websocket connection state. DirectionControlEnum \u2014 What controls the direction (weave/unweave). MessageSeverityEnum \u2014 Severity for text messages. ModeEnum \u2014 The current server mode. ShaftStateEnum \u2014 The current shaft motion state. source enum ConnectionStateEnum ( * args , ** kwds ) Bases : enum . IntEnum Client websocket connection state. Attributes DISCONNECTED CONNECTED CONNECTING DISCONNECTING source enum DirectionControlEnum ( * args , ** kwds ) Bases : enum . IntEnum What controls the direction (weave/unweave). FULL: The direction can be changed by both the web interface and the direction button on the loom. If the loom supports this (e.g. S\u00e9guin), it is the only allowed value. If the loom does not (e.g. Toika), this value is prohibited. LOOM: The direction can only be changed by the unweave button on the loom. The web browser only displays the direction. SOFTWARE: The direction can only be changed by the web interface. The unweave button on the loom is ignored. Attributes FULL LOOM SOFTWARE source enum MessageSeverityEnum ( * args , ** kwds ) Bases : enum . IntEnum Severity for text messages. Attributes INFO WARNING ERROR source enum ModeEnum ( * args , ** kwds ) Bases : enum . IntEnum The current server mode. Attributes WEAVE THREAD SETTINGS source enum ShaftStateEnum ( * args , ** kwds ) Bases : enum . IntEnum The current shaft motion state. Attributes UNKNOWN DONE MOVING ERROR","title":"base_loom_server.enums"},{"location":"src/base_loom_server/enums/","text":"base_loom_server.enums docs module base_loom_server.enums 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import enum class ConnectionStateEnum ( enum . IntEnum ): docs \"\"\"Client websocket connection state.\"\"\" DISCONNECTED = 0 CONNECTED = 1 CONNECTING = 2 DISCONNECTING = 3 class DirectionControlEnum ( enum . IntEnum ): docs \"\"\"What controls the direction (weave/unweave). * FULL: The direction can be changed by both the web interface and the direction button on the loom. If the loom supports this (e.g. S\u00e9guin), it is the only allowed value. If the loom does not (e.g. Toika), this value is prohibited. * LOOM: The direction can only be changed by the unweave button on the loom. The web browser only displays the direction. * SOFTWARE: The direction can only be changed by the web interface. The unweave button on the loom is ignored. \"\"\" FULL = 1 LOOM = 2 SOFTWARE = 3 class MessageSeverityEnum ( enum . IntEnum ): docs \"\"\"Severity for text messages.\"\"\" INFO = 1 WARNING = 2 ERROR = 3 class ModeEnum ( enum . IntEnum ): docs \"\"\"The current server mode.\"\"\" WEAVE = 1 THREAD = 2 SETTINGS = 3 class ShaftStateEnum ( enum . IntEnum ): docs \"\"\"The current shaft motion state.\"\"\" UNKNOWN = 0 DONE = 1 MOVING = 2 ERROR = 3","title":"base_loom_server.enums"},{"location":"api/base_loom_server/example_loom_server/","text":"base_loom_server.example_loom_server source module base_loom_server.example_loom_server Classes ExampleLoomServer \u2014 Example loom server. source class ExampleLoomServer ( * , num_shafts : int , serial_port : str , reset_db : bool , verbose : bool , db_path : pathlib.Path | None = None ) Bases : BaseLoomServer Example loom server. Attributes enable_software_direction : bool \u2014 Is software direction control enabled? thread_low_to_high : bool \u2014 Return True if threading (or unthreading) is currently low to high. loom_connected : bool \u2014 Return True if connected to the loom. Methods write_shafts_to_loom \u2014 Send a shaft_word to the loom. handle_loom_reply \u2014 Process one reply from the loom. source async method ExampleLoomServer . write_shafts_to_loom ( self , shaft_word : int ) \u2192 None Send a shaft_word to the loom. source async method ExampleLoomServer . handle_loom_reply ( self , reply_bytes : bytes ) \u2192 None Process one reply from the loom.","title":"base_loom_server.example_loom_server"},{"location":"src/base_loom_server/example_loom_server/","text":"base_loom_server.example_loom_server docs module base_loom_server.example_loom_server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 __all__ = [ \"ExampleLoomServer\" ] from .base_loom_server import BaseLoomServer from .client_replies import MessageSeverityEnum , ShaftStateEnum from .example_mock_loom import ExampleMockLoom class ExampleLoomServer ( BaseLoomServer ): docs \"\"\"Example loom server.\"\"\" default_name = \"example\" mock_loom_type = ExampleMockLoom async def write_shafts_to_loom ( self , shaft_word : int ) -> None : docs \"\"\"Send a shaft_word to the loom.\"\"\" await self . write_to_loom ( f \"C { shaft_word : 08x } \" ) async def handle_loom_reply ( self , reply_bytes : bytes ) -> None : docs \"\"\"Process one reply from the loom.\"\"\" reply = reply_bytes . decode () . strip () if not reply : return reply_char = reply [ 0 ] reply_data = reply [ 1 :] match reply_char : case \"c\" : # Shafts that are up. self . shaft_word = int ( reply_data , base = 16 ) await self . report_shaft_state () case \"m\" : # Loom moving. self . moving = reply_data == \"1\" self . shaft_state = ShaftStateEnum . MOVING if reply_data == \"1\" else ShaftStateEnum . DONE await self . report_shaft_state () case \"p\" : # Next pick wanted. await self . handle_next_pick_request () case \"u\" : # Weave or thread direction. if reply_data == \"0\" : self . direction_forward = True elif reply_data == \"1\" : self . direction_forward = False else : message = f \"invalid loom reply { reply !r} : direction must be 0 or 1\" self . log . warning ( f \"LoomServer: { message } \" ) await self . report_command_problem ( message = message , severity = MessageSeverityEnum . WARNING ) return await self . report_direction ()","title":"base_loom_server.example_loom_server"},{"location":"api/base_loom_server/example_mock_loom/","text":"base_loom_server.example_mock_loom source module base_loom_server.example_mock_loom Classes ExampleMockLoom \u2014 Example dobby loom simulator. source class ExampleMockLoom ( * , num_shafts : int , verbose : bool = True ) Bases : BaseMockLoom Example dobby loom simulator. This is a slightly simplified version of the S\u00e9guin dobby loom. See the doc string for BaseMockLoom for usage instructions. Parameters verbose : bool \u2014 If True, log diagnostic information. Methods handle_read_bytes \u2014 Handle one command from the web server. report_direction report_motion_state report_pick_wanted report_shafts source async method ExampleMockLoom . handle_read_bytes ( self , read_bytes : bytes ) \u2192 None Handle one command from the web server. source async method ExampleMockLoom . report_direction ( self ) \u2192 None source async method ExampleMockLoom . report_motion_state ( self ) \u2192 None source async method ExampleMockLoom . report_pick_wanted ( self ) \u2192 None source async method ExampleMockLoom . report_shafts ( self ) \u2192 None","title":"base_loom_server.example_mock_loom"},{"location":"src/base_loom_server/example_mock_loom/","text":"base_loom_server.example_mock_loom docs module base_loom_server.example_mock_loom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 __all__ = [ \"BaseMockLoom\" ] from .base_mock_loom import BaseMockLoom class ExampleMockLoom ( BaseMockLoom ): docs \"\"\"Example dobby loom simulator. This is a slightly simplified version of the S\u00e9guin dobby loom. See the doc string for `BaseMockLoom` for usage instructions. Args: verbose: If True, log diagnostic information. \"\"\" async def handle_read_bytes ( self , read_bytes : bytes ) -> None : docs \"\"\"Handle one command from the web server.\"\"\" cmd = read_bytes . decode () . rstrip () if self . verbose : self . log . info ( f \" { self } : process client command { cmd !r} \" ) if len ( cmd ) < 1 : self . log . warning ( f \" { self } : invalid command { cmd !r} : must be at least 1 character\" ) return cmd_char = cmd [ 0 ] cmd_data = cmd [ 1 :] match cmd_char : case \"C\" : # Specify which shafts to raise as a hex value try : shaft_word = int ( cmd_data , base = 16 ) except Exception : self . log . warning ( f \" { self } : invalid command { cmd !r} : data after =C not a hex value\" ) return await self . set_shaft_word ( shaft_word ) case \"U\" : # Client commands unweave on/off # (as opposed to user pushing UNW button on the loom, # in which case the loom changes it and reports it # to the client). if cmd_data not in { \"0\" , \"1\" }: self . log . warning ( f \" { self } : invalid command { cmd !r} : arg must be 0 or 1\" ) return await self . set_direction_forward ( direction_forward = cmd_data == \"0\" ) case _ : self . log . warning ( f \"MockLoom: unrecognized command: { cmd !r} \" ) async def report_direction ( self ) -> None : docs await self . write ( f \"u { int ( not self . direction_forward ) } \" ) async def report_motion_state ( self ) -> None : docs await self . write ( f \"m { int ( self . moving ) } \" ) async def report_pick_wanted ( self ) -> None : docs if self . pick_wanted : await self . write ( \"p\" ) async def report_shafts ( self ) -> None : docs await self . write ( f \"c { self . shaft_word : 08x } \" )","title":"base_loom_server.example_mock_loom"},{"location":"api/base_loom_server/main/","text":"base_loom_server.main source module base_loom_server.main Functions run_example_loom \u2014 Run the example loom. source run_example_loom ( ) \u2192 None Run the example loom.","title":"base_loom_server.main"},{"location":"src/base_loom_server/main/","text":"base_loom_server.main docs module base_loom_server.main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import importlib.resources from fastapi import FastAPI from .app_runner import AppRunner from .example_loom_server import ExampleLoomServer PKG_NAME = \"base_loom_server\" PKG_FILES = importlib . resources . files ( PKG_NAME ) app = FastAPI () app_runner = AppRunner ( app = app , server_class = ExampleLoomServer , favicon = PKG_FILES . joinpath ( \"favicon-32x32.png\" ) . read_bytes (), app_package_name = f \" { PKG_NAME } .main:app\" , ) def run_example_loom () -> None : docs \"\"\"Run the example loom.\"\"\" app_runner . run ()","title":"base_loom_server.main"},{"location":"api/base_loom_server/mock_streams/","text":"base_loom_server.mock_streams source module base_loom_server.mock_streams Classes MockStreamReader \u2014 Minimal mock stream reader that only supports line-oriented data and fixed-length unterminated messages. MockStreamWriter \u2014 Minimal mock stream writer that only allows writing terminated data. StreamData \u2014 Data contained in a mock stream. BaseMockStream \u2014 Base class for MockStreamReader and MockStreamWriter. Functions open_mock_connection \u2014 Create a mock stream reader, writer pair. source class MockStreamReader ( sd : StreamData | None = None , terminator : bytes = DEFAULT_TERMINATOR ) Bases : BaseMockStream Minimal mock stream reader that only supports line-oriented data and fixed-length unterminated messages. Intended to be created in one of two ways: open_mock_connection to create a reader and writer that are linked in that closing the writer also closes the reader. MockStreamWriter.create_reader to create a reader that reads from the writer. Parameters sd : StreamData | None \u2014 Stream data to use; if None create new. terminator : bytes \u2014 Required terminator. Calls to readuntil will raise AssertionError if the separator is not in the terminator. Methods at_eof \u2014 Return true if closed and all buffered data has been read. readexactly \u2014 Read exactly n bytes (including a terminator, if any). readline \u2014 Read one line of data ending with self.terminator. readuntil \u2014 Read until the specified value. create_writer \u2014 Create a MockStreamWriter that writes to this reader. source method MockStreamReader . at_eof ( ) \u2192 bool Return true if closed and all buffered data has been read. source async method MockStreamReader . readexactly ( self , n : int ) \u2192 bytes Read exactly n bytes (including a terminator, if any). Unlike asyncio.StreamReader , this assumes the message will be exactly n bytes long, and the terminator is checked if self.terminator != b\"\". Raises AssertionError \u2014 If the message is too long. asyncio.IncompleteReadError \u2014 If the message is too short. AssertionError \u2014 If self.terminator is not blank and the message is not terminated with self.terminator. source async method MockStreamReader . readline ( self ) \u2192 bytes Read one line of data ending with self.terminator. Raises AssertionError \u2014 If self.terminator is blank. source async method MockStreamReader . readuntil ( self , separator : bytes = b'\\n' ) \u2192 bytes Read until the specified value. Raises AssertionError \u2014 If separator is blank. AssertionError \u2014 If separator not in self.terminator. source method MockStreamReader . create_writer ( ) \u2192 MockStreamWriter Create a MockStreamWriter that writes to this reader. source class MockStreamWriter ( sd : StreamData | None = None , terminator : bytes = DEFAULT_TERMINATOR ) Bases : BaseMockStream Minimal mock stream writer that only allows writing terminated data. Intended to be created in one of two ways: open_mock_connection to create a reader and writer that are linked in that closing the writer also closes the reader. MockStreamReader.create_writer to create a writer that writes to the reader. Parameters sd : StreamData | None \u2014 Stream data to use; if None create new. terminator : bytes \u2014 Required terminator. Calls to write with data that is not correctly terminated will raise AssertionError . Methods close \u2014 Close the writer. is_closing \u2014 Return true if the writer is closed or being closed. drain \u2014 Push the current data to the reader. wait_closed \u2014 Wait for closing to finish. A no-op if closed. write \u2014 Write the specified data. create_reader \u2014 Create a MockStreamReader that reads from this writer. source method MockStreamWriter . close ( ) \u2192 None Close the writer. source method MockStreamWriter . is_closing ( ) \u2192 bool Return true if the writer is closed or being closed. source async method MockStreamWriter . drain ( self ) \u2192 None Push the current data to the reader. source async method MockStreamWriter . wait_closed ( self ) \u2192 None Wait for closing to finish. A no-op if closed. source method MockStreamWriter . write ( data : bytes ) \u2192 None Write the specified data. Raises AssertionError \u2014 If self.terminator is not empty and data is not properly terminated. source method MockStreamWriter . create_reader ( ) \u2192 MockStreamReader Create a MockStreamReader that reads from this writer. source open_mock_connection ( terminator : bytes = DEFAULT_TERMINATOR ) \u2192 tuple[ MockStreamReader , MockStreamWriter ] Create a mock stream reader, writer pair. To create a stream that writes to the returned reader, call reader.create_writer, and similarly for the returned writer. source class StreamData ( ) Data contained in a mock stream. Contains a queue of data and asyncio events to track data available and stream closing. Methods is_closed \u2014 Return true if this stream has been closed. source method StreamData . is_closed ( ) \u2192 bool Return true if this stream has been closed. source class BaseMockStream ( sd : StreamData | None = None , terminator : bytes = DEFAULT_TERMINATOR ) Base class for MockStreamReader and MockStreamWriter. Parameters sd : StreamData | None \u2014 Stream data to use; if None create new. terminator : bytes \u2014 Required terminator.","title":"base_loom_server.mock_streams"},{"location":"src/base_loom_server/mock_streams/","text":"base_loom_server.mock_streams docs module base_loom_server.mock_streams 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 from __future__ import annotations __all__ = [ \"MockStreamReader\" , \"MockStreamWriter\" , \"open_mock_connection\" , \"StreamReaderType\" , \"StreamWriterType\" , ] import asyncio import collections import weakref from typing import TypeAlias DEFAULT_TERMINATOR = b \" \\n \" class StreamData : docs \"\"\"Data contained in a mock stream. Contains a queue of data and asyncio events to track data available and stream closing. \"\"\" def __init__ ( self ) -> None : self . closed_event = asyncio . Event () self . data_available_event = asyncio . Event () self . queue : collections . deque [ bytes ] = collections . deque () def is_closed ( self ) -> bool : docs \"\"\"Return true if this stream has been closed.\"\"\" return self . closed_event . is_set () class BaseMockStream : docs \"\"\"Base class for MockStreamReader and MockStreamWriter. Args: sd: Stream data to use; if None create new. terminator: Required terminator. \"\"\" def __init__ ( self , sd : StreamData | None = None , terminator : bytes = DEFAULT_TERMINATOR ) -> None : if sd is None : sd = StreamData () self . sd = sd self . terminator = terminator self . sibling_sd : weakref . ProxyType [ StreamData ] | None = None class MockStreamReader ( BaseMockStream ): docs \"\"\"Minimal mock stream reader that only supports line-oriented data and fixed-length unterminated messages. Intended to be created in one of two ways: * `open_mock_connection` to create a reader and writer that are linked in that closing the writer also closes the reader. * `MockStreamWriter.create_reader` to create a reader that reads from the writer. Args: sd: Stream data to use; if None create new. terminator: Required terminator. Calls to `readuntil` will raise `AssertionError` if the separator is not in the terminator. \"\"\" def at_eof ( self ) -> bool : docs \"\"\"Return true if closed and all buffered data has been read.\"\"\" return not self . sd . queue and self . sd . is_closed () async def readexactly ( self , n : int ) -> bytes : docs \"\"\"Read exactly n bytes (including a terminator, if any). Unlike `asyncio.StreamReader`, this assumes the message will be exactly n bytes long, and the terminator is checked if self.terminator != b\"\". Raises: AssertionError: If the message is too long. asyncio.IncompleteReadError: If the message is too short. AssertionError: If self.terminator is not blank and the message is not terminated with self.terminator. \"\"\" while not self . sd . queue : if self . sd . is_closed (): return b \"\" self . sd . data_available_event . clear () await self . sd . data_available_event . wait () data = self . sd . queue . popleft () if not self . sd . queue : self . sd . data_available_event . clear () if len ( data ) != n : if len ( data ) < n : raise asyncio . IncompleteReadError ( expected = n , partial = data ) raise AssertionError ( f \"Read len( { data =} )= { len ( data ) } > { n =} \" ) if self . terminator and not data . endswith ( self . terminator ): raise AssertionError ( f \"Data { data =} does not end with { self . terminator =!r} \" ) return data async def readline ( self ) -> bytes : docs \"\"\"Read one line of data ending with self.terminator. Raises: AssertionError: If self.terminator is blank. \"\"\" if not self . terminator : raise AssertionError ( \"readline not allowed: self.terminator is blank\" ) while not self . sd . queue : if self . sd . is_closed (): return b \"\" self . sd . data_available_event . clear () await self . sd . data_available_event . wait () data = self . sd . queue . popleft () if not self . sd . queue : self . sd . data_available_event . clear () return data async def readuntil ( self , separator : bytes = b \" \\n \" ) -> bytes : docs \"\"\"Read until the specified value. Raises: AssertionError: If `separator` is blank. AssertionError: If `separator` not in self.terminator. \"\"\" if separator == b \"\" : raise AssertionError ( \"readuntil must have a non-blank separator\" ) if separator not in self . terminator : raise AssertionError ( f \"readuntil { separator =} not in required terminator { self . terminator !r} \" ) return await self . readline () def create_writer ( self ) -> MockStreamWriter : docs \"\"\"Create a MockStreamWriter that writes to this reader.\"\"\" return MockStreamWriter ( sd = self . sd , terminator = self . terminator ) class MockStreamWriter ( BaseMockStream ): docs \"\"\"Minimal mock stream writer that only allows writing terminated data. Intended to be created in one of two ways: * `open_mock_connection` to create a reader and writer that are linked in that closing the writer also closes the reader. * `MockStreamReader.create_writer` to create a writer that writes to the reader. Args: sd: Stream data to use; if None create new. terminator: Required terminator. Calls to `write` with data that is not correctly terminated will raise `AssertionError`. \"\"\" def close ( self ) -> None : docs \"\"\"Close the writer.\"\"\" self . sd . closed_event . set () if self . sibling_sd and not self . sibling_sd . is_closed (): self . sibling_sd . closed_event . set () def is_closing ( self ) -> bool : docs \"\"\"Return true if the writer is closed or being closed.\"\"\" return self . sd . is_closed () async def drain ( self ) -> None : docs \"\"\"Push the current data to the reader.\"\"\" if self . is_closing (): return self . sd . data_available_event . set () async def wait_closed ( self ) -> None : docs \"\"\"Wait for closing to finish. A no-op if closed.\"\"\" await self . sd . closed_event . wait () def write ( self , data : bytes ) -> None : docs \"\"\"Write the specified data. Raises: AssertionError: If self.terminator is not empty and `data` is not properly terminated. \"\"\" if self . terminator and not data . endswith ( self . terminator ): raise AssertionError ( f \"Cannot write { data =} : it must end with { self . terminator =!r} \" ) if self . is_closing (): return self . sd . queue . append ( data ) def _set_sibling_data ( self , reader : MockStreamReader ) -> None : self . sibling_sd = weakref . proxy ( reader . sd ) def create_reader ( self ) -> MockStreamReader : docs \"\"\"Create a MockStreamReader that reads from this writer.\"\"\" return MockStreamReader ( sd = self . sd , terminator = self . terminator ) StreamReaderType : TypeAlias = asyncio . StreamReader | MockStreamReader StreamWriterType : TypeAlias = asyncio . StreamWriter | MockStreamWriter def open_mock_connection ( docs terminator : bytes = DEFAULT_TERMINATOR , ) -> tuple [ MockStreamReader , MockStreamWriter ]: \"\"\"Create a mock stream reader, writer pair. To create a stream that writes to the returned reader, call reader.create_writer, and similarly for the returned writer. \"\"\" reader = MockStreamReader ( terminator = terminator ) writer = MockStreamWriter ( terminator = terminator ) writer . _set_sibling_data ( reader = reader ) # noqa: SLF001 return ( reader , writer )","title":"base_loom_server.mock_streams"},{"location":"api/base_loom_server/pattern_database/","text":"base_loom_server.pattern_database source module base_loom_server.pattern_database Classes PatternDatabase \u2014 sqlite database to hold ReducedPattern instances. Functions create_pattern_database \u2014 Create the pattern database. source class PatternDatabase ( dbpath : pathlib . Path ) sqlite database to hold ReducedPattern instances. The patterns are stored as json strings, but the the associated cache fields are saved in separate fields so they can be updated as they change (the values in the json strings are ignored during pattern retrieval). Methods init \u2014 Create the database, if it does not exist. check_schema \u2014 Return True if the patterns table schema is as expected. add_pattern \u2014 Add a new pattern to the database. clear_database \u2014 Remove all patterns from the database. get_pattern \u2014 Get the named pattern. get_pattern_names \u2014 Get all pattern names. update_pick_number \u2014 Update weaving pick and repeat numbers for the specified pattern. update_end_number \u2014 Update threading end & repeat numbers for the specified pattern. update_separate_threading_repeats \u2014 Update separate_threading_repeats for the specified pattern. update_separate_weaving_repeats \u2014 Update separate_weaving_repeats for the specified pattern. update_thread_group_size \u2014 Update thread_group_size for the specified pattern. set_timestamp \u2014 Set the timestamp for the specified pattern. source async method PatternDatabase . init ( self ) \u2192 None Create the database, if it does not exist. source async method PatternDatabase . check_schema ( self ) \u2192 bool Return True if the patterns table schema is as expected. Extra fields in the table are ignored. source async method PatternDatabase . add_pattern ( self , pattern : ReducedPattern , max_entries : int = 0 ) \u2192 None Add a new pattern to the database. Add the specified pattern to the database, overwriting any existing pattern by that name (with a new id number, so the new pattern is the most recent). Prune excess patterns and return the resulting pattern names. Parameters pattern : ReducedPattern \u2014 The pattern to add. The associated cache fields are set to values from the pattern: pick_number pick_repeat_number end_number0 end_number1 end_repeat_number thread_group_size separate_weaving_repeats separate_threading_repeats max_entries : int \u2014 Maximum number of patterns to keep; no limit if 0. If >0 and there are more patterns in the database, the oldest are purged. source async method PatternDatabase . clear_database ( self ) \u2192 None Remove all patterns from the database. source async method PatternDatabase . get_pattern ( self , pattern_name : str ) \u2192 ReducedPattern Get the named pattern. Raises LookupError source async method PatternDatabase . get_pattern_names ( self ) \u2192 list[str] Get all pattern names. source async method PatternDatabase . update_pick_number ( self , * , pattern_name : str , pick_number : int , pick_repeat_number : int ) \u2192 None Update weaving pick and repeat numbers for the specified pattern. source async method PatternDatabase . update_end_number ( self , * , pattern_name : str , end_number0 : int , end_number1 : int , end_repeat_number : int ) \u2192 None Update threading end & repeat numbers for the specified pattern. source async method PatternDatabase . update_separate_threading_repeats ( self , * , pattern_name : str , separate_threading_repeats : bool ) \u2192 None Update separate_threading_repeats for the specified pattern. source async method PatternDatabase . update_separate_weaving_repeats ( self , * , pattern_name : str , separate_weaving_repeats : bool ) \u2192 None Update separate_weaving_repeats for the specified pattern. source async method PatternDatabase . update_thread_group_size ( self , pattern_name : str , thread_group_size : int ) \u2192 None Update thread_group_size for the specified pattern. source async method PatternDatabase . set_timestamp ( self , pattern_name : str , timestamp : float ) \u2192 None Set the timestamp for the specified pattern. Parameters pattern_name : str \u2014 Pattern name. timestamp : float \u2014 Timestamp in unix seconds, e.g. from time.time(). source async create_pattern_database ( dbpath : pathlib . Path ) \u2192 PatternDatabase Create the pattern database.","title":"base_loom_server.pattern_database"},{"location":"src/base_loom_server/pattern_database/","text":"base_loom_server.pattern_database docs module base_loom_server.pattern_database 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 __all__ = [ \"PatternDatabase\" , \"create_pattern_database\" ] import dataclasses import json import pathlib import time import aiosqlite from .reduced_pattern import ReducedPattern FIELD_TYPE_DICT = dict ( id = \"integer primary key\" , pattern_name = \"text\" , pattern_json = \"text\" , pick_number = \"integer\" , pick_repeat_number = \"integer\" , end_number0 = \"integer\" , end_number1 = \"integer\" , end_repeat_number = \"integer\" , thread_group_size = \"integer\" , separate_weaving_repeats = \"integer\" , separate_threading_repeats = \"integer\" , timestamp_sec = \"real\" , ) FIELDS_STR = \", \" . join ( f \" { key } { value } \" for key , value in FIELD_TYPE_DICT . items ()) def _make_insert_str () -> str : \"\"\"Make the value for INSERT_STR from FIELD_TYPE_DICT.\"\"\" field_names = [ field_name for field_name in FIELD_TYPE_DICT if field_name != \"id\" ] field_names_str = \", \" . join ( field_names ) placeholders_str = \", \" . join ([ \"?\" ] * len ( field_names )) return f \"insert into patterns ( { field_names_str } ) values ( { placeholders_str } )\" # noqa: S608 INSERT_STR = _make_insert_str () CACHE_FIELD_NAMES = ( \"pick_number\" , \"pick_repeat_number\" , \"end_number0\" , \"end_number1\" , \"end_repeat_number\" , \"thread_group_size\" , \"separate_weaving_repeats\" , \"separate_threading_repeats\" , ) REPEAT_FIELD_NAMES = { \"pick_repeat_number\" , \"end_repeat_number\" , } class PatternDatabase : docs \"\"\"sqlite database to hold ReducedPattern instances. The patterns are stored as json strings, but the the associated cache fields are saved in separate fields so they can be updated as they change (the values in the json strings are ignored during pattern retrieval). \"\"\" def __init__ ( self , dbpath : pathlib . Path ) -> None : self . dbpath = dbpath async def init ( self ) -> None : docs \"\"\"Create the database, if it does not exist.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( f \"create table if not exists patterns ( { FIELDS_STR } )\" ) await conn . commit () async def check_schema ( self ) -> bool : docs \"\"\"Return True if the patterns table schema is as expected. Extra fields in the table are ignored. \"\"\" async with ( aiosqlite . connect ( self . dbpath ) as conn , conn . execute ( \"pragma table_info(patterns)\" ) as cursor , ): field_info_list = await cursor . fetchall () field_info_dict = { field_info [ 1 ]: ( field_info [ 2 ] . lower (), bool ( field_info [ - 1 ])) for field_info in field_info_list } for field_name , expected_field_type in FIELD_TYPE_DICT . items (): field_type_is_primary = field_info_dict . get ( field_name ) if field_type_is_primary is None : return False if field_name == \"id\" : if field_type_is_primary != ( \"integer\" , True ): return False elif field_type_is_primary != ( expected_field_type , False ): return False return True async def add_pattern ( docs self , pattern : ReducedPattern , max_entries : int = 0 , ) -> None : \"\"\"Add a new pattern to the database. Add the specified pattern to the database, overwriting any existing pattern by that name (with a new id number, so the new pattern is the most recent). Prune excess patterns and return the resulting pattern names. Args: pattern: The pattern to add. The associated cache fields are set to values from the pattern: * pick_number * pick_repeat_number * end_number0 * end_number1 * end_repeat_number * thread_group_size * separate_weaving_repeats * separate_threading_repeats max_entries: Maximum number of patterns to keep; no limit if 0. If >0 and there are more patterns in the database, the oldest are purged. \"\"\" pattern_json = json . dumps ( dataclasses . asdict ( pattern )) cache_values = tuple ( getattr ( pattern , field ) for field in CACHE_FIELD_NAMES ) current_time = time . time () async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"delete from patterns where pattern_name = ?\" , ( pattern . name ,)) # If limiting the number of entries, make sure to allow # at least two, to save the most recent pattern, # since it is likely to be the current pattern. if max_entries > 0 : max_entries = max ( max_entries , 2 ) await conn . execute ( INSERT_STR , ( pattern . name , pattern_json , * cache_values , current_time ), ) await conn . commit () pattern_names = await self . get_pattern_names () names_to_delete = pattern_names [ 0 : - max_entries ] if len ( names_to_delete ) > 0 : # Purge old patterns for pattern_name in names_to_delete : await conn . execute ( \"delete from patterns where pattern_name = ?\" , ( pattern_name ,)) await conn . commit () async def clear_database ( self ) -> None : docs \"\"\"Remove all patterns from the database.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"delete from patterns\" ) await conn . commit () async def get_pattern ( self , pattern_name : str ) -> ReducedPattern : docs \"\"\"Get the named pattern.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : conn . row_factory = aiosqlite . Row async with conn . execute ( \"select * from patterns where pattern_name = ?\" , ( pattern_name ,) ) as cursor : row = await cursor . fetchone () if row is None : raise LookupError ( f \" { pattern_name } not found\" ) pattern_dict = json . loads ( row [ \"pattern_json\" ]) pattern = ReducedPattern . from_dict ( pattern_dict ) for field_name in CACHE_FIELD_NAMES : value = row [ field_name ] if field_name in REPEAT_FIELD_NAMES and value < 0 : # From an older version that allowed jump numbers < 0 value = 0 setattr ( pattern , field_name , value ) return pattern async def get_pattern_names ( self ) -> list [ str ]: docs \"\"\"Get all pattern names.\"\"\" async with ( aiosqlite . connect ( self . dbpath ) as conn , conn . execute ( \"select pattern_name from patterns order by timestamp_sec asc, id asc\" ) as cursor , ): rows = await cursor . fetchall () return [ row [ 0 ] for row in rows ] async def update_pick_number ( docs self , * , pattern_name : str , pick_number : int , pick_repeat_number : int ) -> None : \"\"\"Update weaving pick and repeat numbers for the specified pattern.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"update patterns \" \"set pick_number = ?, pick_repeat_number = ?, timestamp_sec = ?\" \"where pattern_name = ?\" , ( pick_number , pick_repeat_number , time . time (), pattern_name ), ) await conn . commit () async def update_end_number ( docs self , * , pattern_name : str , end_number0 : int , end_number1 : int , end_repeat_number : int , ) -> None : \"\"\"Update threading end & repeat numbers for the specified pattern.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"update patterns \" \"set end_number0 = ?, end_number1 = ?, end_repeat_number = ?, timestamp_sec = ?\" \"where pattern_name = ?\" , ( end_number0 , end_number1 , end_repeat_number , time . time (), pattern_name , ), ) await conn . commit () async def update_separate_threading_repeats ( docs self , * , pattern_name : str , separate_threading_repeats : bool , ) -> None : \"\"\"Update separate_threading_repeats for the specified pattern.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"update patterns set separate_threading_repeats = ?, timestamp_sec = ?where pattern_name = ?\" , ( int ( separate_threading_repeats ), time . time (), pattern_name ), ) await conn . commit () async def update_separate_weaving_repeats ( docs self , * , pattern_name : str , separate_weaving_repeats : bool , ) -> None : \"\"\"Update separate_weaving_repeats for the specified pattern.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"update patterns set separate_weaving_repeats = ?, timestamp_sec = ?where pattern_name = ?\" , ( int ( separate_weaving_repeats ), time . time (), pattern_name ), ) await conn . commit () docs async def update_thread_group_size ( self , pattern_name : str , thread_group_size : int ) -> None : \"\"\"Update thread_group_size for the specified pattern.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"update patterns set thread_group_size = ?, timestamp_sec = ?where pattern_name = ?\" , ( thread_group_size , time . time (), pattern_name ), ) await conn . commit () docs async def set_timestamp ( self , pattern_name : str , timestamp : float ) -> None : \"\"\"Set the timestamp for the specified pattern. Args: pattern_name: Pattern name. timestamp: Timestamp in unix seconds, e.g. from time.time(). \"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"update patterns set timestamp_sec = ? where pattern_name = ?\" , ( timestamp , pattern_name ), ) await conn . commit () docs async def create_pattern_database ( dbpath : pathlib . Path ) -> PatternDatabase : \"\"\"Create the pattern database.\"\"\" db = PatternDatabase ( dbpath = dbpath ) await db . init () return db","title":"base_loom_server.pattern_database"},{"location":"api/base_loom_server/reduced_pattern/","text":"base_loom_server.reduced_pattern source module base_loom_server.reduced_pattern Classes Pick \u2014 One pick of a pattern. ReducedPattern \u2014 A weaving pattern reduced to the bare essentials. Functions reduced_pattern_from_pattern_data \u2014 Convert a dtx_to_wif.PatternData to a ReducedPattern. pop_and_check_type_field shaft_word_from_shaft_set \u2014 Convert a shaft set to a shaft word. shaft_set_from_shaft_word \u2014 Convert a shaft word to a shaft set. source dataclass Pick ( color : int , shaft_word : int ) One pick of a pattern. Parameters color : int \u2014 Weft color, as an index into the color table. shaft_word : int \u2014 A bit mask, with bit 1 = shaft 0. The shaft is up if the bit is set. Methods from_dict \u2014 Construct a Pick from a dict representation. source classmethod Pick . from_dict ( datadict : dict[str, Any ] ) \u2192 Pick Construct a Pick from a dict representation. The \"type\" field is optional, but checked if present. source dataclass ReducedPattern ( name : str , color_table : list[str] , warp_colors : list[int] , threading : list[int] , picks : list[ Pick ] , pick0 : Pick , pick_number : int = 0 , pick_repeat_number : int = 1 , end_number0 : int = 0 , end_number1 : int = 0 , end_repeat_number : int = 1 , _thread_group_size : int = DEFAULT_THREAD_GROUP_SIZE , separate_weaving_repeats : bool = False , separate_threading_repeats : bool = False ) A weaving pattern reduced to the bare essentials. Contains just enough information to allow loom control, with a simple display. Picks are accessed by pick number, which is 1-based. 0 indicates that nothing has been woven. Attributes num_ends : int \u2014 How many warp ends are in the pattern. num_picks : int \u2014 How many weft picks are in the pattern. thread_group_size : int \u2014 Get the thread group size. Methods from_dict \u2014 Construct a ReducedPattern from a dict. check_end_number \u2014 Raise IndexError if end_number0 out of range. check_pick_number \u2014 Raise IndexError if pick_number out of range. compute_end_number1 \u2014 Compute end_number1 given end_number0. compute_next_end_numbers \u2014 Compute the next (end_number0, end_number1, end_repeat_number) in the specified direction. compute_next_pick_numbers \u2014 Compute (next pick_number, pick_repeat_number) in the specified direction. get_current_pick \u2014 Get the current pick. get_pick \u2014 Get the specified pick. get_threading_shaft_word \u2014 Get current threading shaft word. increment_end_number \u2014 Increment self.end_number0 in the specified direction. Increment end_repeat_number as well, if appropriate. increment_pick_number \u2014 Increment pick_number in the specified direction. set_current_end_number \u2014 Set end_number0, end_number1, and possibly end_repeat_number. set_current_pick_number \u2014 Set pick_number. source classmethod ReducedPattern . from_dict ( datadict : dict[str, Any ] ) \u2192 ReducedPattern Construct a ReducedPattern from a dict. source property ReducedPattern . num_ends : int How many warp ends are in the pattern. source property ReducedPattern . num_picks : int How many weft picks are in the pattern. source property ReducedPattern . thread_group_size : int Get the thread group size. source method ReducedPattern . check_end_number ( end_number0 : int ) \u2192 None Raise IndexError if end_number0 out of range. The allowed range is 0 to self.len(self.threading), inclusive. See get_end_number for more information. Raises IndexError source method ReducedPattern . check_pick_number ( pick_number : int ) \u2192 None Raise IndexError if pick_number out of range. The allowed range is 0 to self.len(self.picks), inclusive. See get_pick_number for more information. Raises IndexError source method ReducedPattern . compute_end_number1 ( end_number0 : int ) \u2192 int Compute end_number1 given end_number0. Uses the current value of end_repeat_number. source method ReducedPattern . compute_next_end_numbers ( * , thread_low_to_high : bool ) \u2192 tuple[int, int, int] Compute the next (end_number0, end_number1, end_repeat_number) in the specified direction. End number is 1-based, but 0 means at start or between repeats (in which case there are no threads in the group). Raises IndexError \u2014 If trying to increment past the start of threading. IndexError \u2014 if self.end_number0 is invalid. source method ReducedPattern . compute_next_pick_numbers ( * , direction_forward : bool ) \u2192 tuple[int, int] Compute (next pick_number, pick_repeat_number) in the specified direction. Raises IndexError \u2014 If trying to increment past the start of weaving. source method ReducedPattern . get_current_pick ( ) \u2192 Pick Get the current pick. source method ReducedPattern . get_pick ( pick_number : int ) \u2192 Pick Get the specified pick. Return self.pick0 if pick_number = 0, else return self.picks[pick_number-1] if pick_number in range. Raises IndexError \u2014 If pick_number < 0 or > len(self.picks). source method ReducedPattern . get_threading_shaft_word ( ) \u2192 int Get current threading shaft word. source method ReducedPattern . increment_end_number ( * , thread_low_to_high : bool ) \u2192 None Increment self.end_number0 in the specified direction. Increment end_repeat_number as well, if appropriate. End number is 1-based, but 0 means at start or between repeats (in which case there are no threads in the group). Raises IndexError \u2014 If trying to increment past the start of threading. IndexError \u2014 if self.end_number0 is invalid. source method ReducedPattern . increment_pick_number ( * , direction_forward : bool ) \u2192 int Increment pick_number in the specified direction. Increment pick_repeat_number as well, if appropriate. Return the new pick number. Raises IndexError \u2014 If trying to increment past the start of weaving. source method ReducedPattern . set_current_end_number ( end_number0 : int , end_number1 : int | None = None , end_repeat_number : int | None = None ) \u2192 None Set end_number0, end_number1, and possibly end_repeat_number. Parameters end_number0 : int \u2014 New value for end_number0, the starting end number for a group of ends to thread. Must be in range 0 \u2264 end_number0 \u2264 num_shafts. end_number1 : int | None \u2014 New value for end_number1. If None, compute it. If not None then the value must be: 0, if end_number0 = 0. Else in range end_number0 <= end_number1 \u2264 num ends. end_repeat_number : int | None \u2014 New value for end_repeat_number. If None, use the current value. Raises IndexError \u2014 If end_number0 < 0 or > len(self.threading). IndexError \u2014 If end_number1 not None and not valid. source method ReducedPattern . set_current_pick_number ( pick_number : int ) \u2192 None Set pick_number. Parameters pick_number : int \u2014 The pick number. Raise IndexError if pick_number < 0 or > num picks. source reduced_pattern_from_pattern_data ( name : str , data : dtx_to_wif . PatternData ) \u2192 ReducedPattern Convert a dtx_to_wif.PatternData to a ReducedPattern. Parameters name : str \u2014 The name of the pattern to use. data : dtx_to_wif . PatternData \u2014 The pattern read by dtx_to_wif. The name field is ignored. The result is simpler and smaller, and can be sent to easily encoded and sent to JavaScript. Note that all input (PatternData) indices are 1-based and all output (ReducedPattern) indices are 0-based. Raises RuntimeError source pop_and_check_type_field ( typename : str , datadict : dict[str, Any ] ) \u2192 None Raises TypeError source shaft_word_from_shaft_set ( shaft_set : Iterable [int] ) \u2192 int Convert a shaft set to a shaft word. A shaft set is a collection of 1-based shafts numbers for shafts that are up. If 0 is present, it is ignored. A shaft word is a bit mask, with bit 0 = shaft 1; if a bit is high, that shaft is up. source shaft_set_from_shaft_word ( shaft_word : int ) \u2192 set[int] Convert a shaft word to a shaft set. See shaft_word_from_shaft_set for details.","title":"base_loom_server.reduced_pattern"},{"location":"src/base_loom_server/reduced_pattern/","text":"base_loom_server.reduced_pattern docs module base_loom_server.reduced_pattern 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 from __future__ import annotations __all__ = [ \"DEFAULT_THREAD_GROUP_SIZE\" , \"NUM_ITEMS_FOR_REPEAT_SEPARATOR\" , \"Pick\" , \"ReducedPattern\" , \"reduced_pattern_from_pattern_data\" , ] import copy import dataclasses from typing import TYPE_CHECKING , Any if TYPE_CHECKING : from collections.abc import Iterable import dtx_to_wif DEFAULT_THREAD_GROUP_SIZE = 4 # The number of picks or warp threads above which # the repeat separator is, by default, enabled # (so if the number is <= then no separator) NUM_ITEMS_FOR_REPEAT_SEPARATOR = 20 docs def pop_and_check_type_field ( typename : str , datadict : dict [ str , Any ]) -> None : typestr = datadict . pop ( \"type\" , typename ) if typestr != typename : raise TypeError ( f \"Wrong type: { typestr =!r} != { typename !r} \" ) @dataclasses . dataclass class Pick : docs \"\"\"One pick of a pattern. Args: color: Weft color, as an index into the color table. shaft_word: A bit mask, with bit 1 = shaft 0. The shaft is up if the bit is set. \"\"\" color : int shaft_word : int @classmethod def from_dict ( cls , datadict : dict [ str , Any ]) -> Pick : docs \"\"\"Construct a Pick from a dict representation. The \"type\" field is optional, but checked if present. \"\"\" pop_and_check_type_field ( \"Pick\" , datadict ) return cls ( ** datadict ) @dataclasses . dataclass class ReducedPattern : docs \"\"\"A weaving pattern reduced to the bare essentials. Contains just enough information to allow loom control, with a simple display. Picks are accessed by pick number, which is 1-based. 0 indicates that nothing has been woven. \"\"\" type : str = dataclasses . field ( init = False , default = \"ReducedPattern\" ) name : str color_table : list [ str ] warp_colors : list [ int ] threading : list [ int ] picks : list [ Pick ] pick0 : Pick # Keep track of where we are in weaving pick_number : int = 0 pick_repeat_number : int = 1 # keep track of where we are in threading end_number0 : int = 0 end_number1 : int = 0 end_repeat_number : int = 1 _thread_group_size : int = DEFAULT_THREAD_GROUP_SIZE separate_weaving_repeats : bool = False separate_threading_repeats : bool = False @classmethod def from_dict ( cls , datadict : dict [ str , Any ]) -> ReducedPattern : docs \"\"\"Construct a ReducedPattern from a dict.\"\"\" # Make a copy, so the caller doesn't see the picks field change datadict = copy . deepcopy ( datadict ) pop_and_check_type_field ( typename = \"ReducedPattern\" , datadict = datadict ) datadict [ \"picks\" ] = [ Pick . from_dict ( pickdict ) for pickdict in datadict [ \"picks\" ]] datadict [ \"pick0\" ] = Pick . from_dict ( datadict [ \"pick0\" ]) return cls ( ** datadict ) @property def num_ends ( self ) -> int : docs \"\"\"How many warp ends are in the pattern.\"\"\" return len ( self . threading ) @property def num_picks ( self ) -> int : docs \"\"\"How many weft picks are in the pattern.\"\"\" return len ( self . picks ) @property def thread_group_size ( self ) -> int : docs \"\"\"Get the thread group size.\"\"\" return self . _thread_group_size @thread_group_size . setter def thread_group_size ( self , value : int ) -> None : value = int ( value ) if value < 1 : raise ValueError ( f \" { value =} must be positive\" ) self . _thread_group_size = value def check_end_number ( self , end_number0 : int ) -> None : docs \"\"\"Raise IndexError if end_number0 out of range. The allowed range is 0 to self.len(self.threading), inclusive. See get_end_number for more information. \"\"\" if end_number0 < 0 : raise IndexError ( f \" { end_number0 =} < 0\" ) if end_number0 > len ( self . threading ): raise IndexError ( f \" { end_number0 =} > { len ( self . threading ) } \" ) def check_pick_number ( self , pick_number : int ) -> None : docs \"\"\"Raise IndexError if pick_number out of range. The allowed range is 0 to self.len(self.picks), inclusive. See get_pick_number for more information. \"\"\" if pick_number < 0 : raise IndexError ( f \" { pick_number =} < 0\" ) if pick_number > len ( self . picks ): raise IndexError ( f \" { pick_number =} > { len ( self . picks ) } \" ) def compute_end_number1 ( self , end_number0 : int ) -> int : docs \"\"\"Compute end_number1 given end_number0. Uses the current value of end_repeat_number. \"\"\" self . check_end_number ( end_number0 ) max_end_number = len ( self . threading ) if end_number0 == 0 : return 0 return min ( end_number0 + self . thread_group_size - 1 , max_end_number ) docs def compute_next_end_numbers ( self , * , thread_low_to_high : bool ) -> tuple [ int , int , int ]: \"\"\"Compute the next (end_number0, end_number1, end_repeat_number) in the specified direction. End number is 1-based, but 0 means at start or between repeats (in which case there are no threads in the group). Raises: IndexError: If trying to increment past the start of threading. IndexError: if self.end_number0 is invalid. \"\"\" self . check_end_number ( self . end_number0 ) if self . end_number0 == 0 and self . end_repeat_number == 1 and not thread_low_to_high : raise IndexError max_end_number = len ( self . threading ) new_end_number0 = 0 # Initialize new_end_number1 to None to allow set_current_end_number # to compute it, if possible (most cases below). new_end_number1 = None new_end_repeat_number = self . end_repeat_number if thread_low_to_high : if self . end_number0 == 0 : new_end_number0 = 1 elif self . end_number1 < max_end_number : new_end_number0 = self . end_number1 + 1 else : # At the end of one repeat; start the next. new_end_number0 = 0 if self . separate_threading_repeats else 1 new_end_repeat_number += 1 else : # noqa: PLR5501 if self . end_number0 == 1 and ( self . separate_threading_repeats or self . end_repeat_number == 1 ): # We are at the beginning of a pattern repeat and # either we separate repeats or it is the very first. # Go to end 0. new_end_number0 = 0 elif self . end_number0 == 0 or ( self . end_number0 == 1 and not self . separate_threading_repeats ): # Start the previous repeat. new_end_number1 = max_end_number new_end_number0 = max ( new_end_number1 + 1 - self . thread_group_size , 1 ) new_end_repeat_number -= 1 else : # We are still threading the current pattern repeat. # We must compute end_number1 because the available group # size may be smaller than the desired group size. new_end_number0 = max ( self . end_number0 - self . thread_group_size , 1 ) new_end_number1 = self . end_number0 - 1 if new_end_number1 is None : if new_end_number0 == 0 : new_end_number1 = 0 else : new_end_number1 = min ( new_end_number0 + self . thread_group_size - 1 , max_end_number ) return ( new_end_number0 , new_end_number1 , new_end_repeat_number ) docs def compute_next_pick_numbers ( self , * , direction_forward : bool ) -> tuple [ int , int ]: \"\"\"Compute (next pick_number, pick_repeat_number) in the specified direction. Raises: IndexError: If trying to increment past the start of weaving. \"\"\" self . check_pick_number ( self . pick_number ) if self . pick_number == 0 and self . pick_repeat_number == 1 and not direction_forward : raise IndexError # Start by assuming the common case. next_pick_repeat_number = self . pick_repeat_number next_pick_number = self . pick_number + 1 if direction_forward else self . pick_number - 1 # Handle special cases: end of pattern repeats if direction_forward : if self . pick_number == len ( self . picks ): # At the end; start a new repeat. next_pick_number = 0 if self . separate_weaving_repeats else 1 next_pick_repeat_number += 1 else : # noqa: PLR5501 if self . pick_number == 1 and ( self . separate_weaving_repeats or self . pick_repeat_number == 1 ): # At the beginning of a repeat, and either we # separate repeats or it is the very first. Go to pick 0. next_pick_number = 0 elif self . pick_number == 0 or ( self . pick_number == 1 and not self . separate_weaving_repeats ): # Start the previous repeat. next_pick_number = len ( self . picks ) next_pick_repeat_number -= 1 return ( next_pick_number , next_pick_repeat_number ) def get_current_pick ( self ) -> Pick : docs \"\"\"Get the current pick.\"\"\" return self . get_pick ( self . pick_number ) def get_pick ( self , pick_number : int ) -> Pick : docs \"\"\"Get the specified pick. Return self.pick0 if pick_number = 0, else return self.picks[pick_number-1] if pick_number in range. Raises: IndexError: If `pick_number` < 0 or > len(self.picks). \"\"\" self . check_pick_number ( pick_number ) if pick_number == 0 : return self . pick0 return self . picks [ pick_number - 1 ] def get_threading_shaft_word ( self ) -> int : docs \"\"\"Get current threading shaft word.\"\"\" if self . end_number0 == 0 : return 0 shaft_set = { self . threading [ i ] for i in range ( self . end_number0 - 1 , self . end_number1 )} return sum ( 1 << shaft for shaft in shaft_set if shaft >= 0 ) def increment_end_number ( self , * , thread_low_to_high : bool ) -> None : docs \"\"\"Increment self.end_number0 in the specified direction. Increment end_repeat_number as well, if appropriate. End number is 1-based, but 0 means at start or between repeats (in which case there are no threads in the group). Raises: IndexError: If trying to increment past the start of threading. IndexError: if self.end_number0 is invalid. \"\"\" end_number0 , end_number1 , end_repeat_number = self . compute_next_end_numbers ( thread_low_to_high = thread_low_to_high ) self . set_current_end_number ( end_number0 = end_number0 , end_number1 = end_number1 , end_repeat_number = end_repeat_number , ) def increment_pick_number ( self , * , direction_forward : bool ) -> int : docs \"\"\"Increment pick_number in the specified direction. Increment pick_repeat_number as well, if appropriate. Return the new pick number. Raises: IndexError: If trying to increment past the start of weaving. \"\"\" self . pick_number , self . pick_repeat_number = self . compute_next_pick_numbers ( direction_forward = direction_forward ) return self . pick_number def set_current_end_number ( docs self , end_number0 : int , end_number1 : int | None = None , end_repeat_number : int | None = None , ) -> None : \"\"\"Set end_number0, end_number1, and possibly end_repeat_number. Args: end_number0: New value for end_number0, the starting end number for a group of ends to thread. Must be in range 0 \u2264 end_number0 \u2264 num_shafts. end_number1: New value for end_number1. If None, compute it. If not None then the value must be: * 0, if end_number0 = 0. * Else in range end_number0 <= end_number1 \u2264 num ends. end_repeat_number: New value for end_repeat_number. If None, use the current value. Raises: IndexError: If end_number0 < 0 or > len(self.threading). IndexError: If end_number1 not None and not valid. \"\"\" self . check_end_number ( end_number0 ) max_end_number = len ( self . threading ) if end_number1 is not None : if end_number0 == 0 : if end_number1 != 0 : raise IndexError ( f \" { end_number1 =} must be 0, since end_number0=0\" ) elif end_number1 > max_end_number : raise IndexError ( f \" { end_number1 =} must be <= { max_end_number } \" ) elif end_number1 < end_number0 : raise IndexError ( f \" { end_number1 =} must be >= { end_number0 =} \" ) self . end_number1 = end_number1 else : self . end_number1 = self . compute_end_number1 ( end_number0 = end_number0 ) self . end_number0 = end_number0 if end_repeat_number is not None : self . end_repeat_number = end_repeat_number def set_current_pick_number ( self , pick_number : int ) -> None : docs \"\"\"Set pick_number. Args: pick_number: The pick number. Raise IndexError if pick_number < 0 or > num picks. \"\"\" self . check_pick_number ( pick_number ) self . pick_number = pick_number def _smallest_shaft ( shafts : set [ int ]) -> int : \"\"\"Return the smallest non-zero shaft from a set of shafts. Return 0 if no non-zero shafts. \"\"\" pruned_shafts = shafts - { 0 } if pruned_shafts : return sorted ( shafts )[ 0 ] return 0 docs def reduced_pattern_from_pattern_data ( name : str , data : dtx_to_wif . PatternData ) -> ReducedPattern : \"\"\"Convert a dtx_to_wif.PatternData to a ReducedPattern. Args: name: The name of the pattern to use. data: The pattern read by dtx_to_wif. The `name` field is ignored. The result is simpler and smaller, and can be sent to easily encoded and sent to JavaScript. Note that all input (PatternData) indices are 1-based and all output (ReducedPattern) indices are 0-based. \"\"\" if data . color_table : # Note: PatternData promises to have color_range # if color_table is present. if data . color_range is None : raise RuntimeError ( \"color_table specified, but color_range is None\" ) # Compute a scaled version of the color table, where each # scaled r,g,b value is in range 0-255 (0-0xff) inclusive min_color = data . color_range [ 0 ] color_scale = 255 / ( data . color_range [ 1 ] - min_color ) # Note: PatternData promises that color_table # keys are 1, 2, ...N, with no missing keys, # so we can ignore the keys and just use the values. scaled_color_rgbs = ( [ int (( value - min_color ) * color_scale ) for value in color_rgb ] for color_rgb in data . color_table . values () ) color_strs = [ f \"# { r : 02x }{ g : 02x }{ b : 02x } \" for r , g , b in scaled_color_rgbs ] if len ( color_strs ) < 1 : # Make sure we have at least 2 entries color_strs += [ \"#ffffff\" , \"#000000\" ] else : color_strs = [ \"#ffffff\" , \"#000000\" ] num_warps = max ( data . threading . keys ()) warps_from1 = list ( range ( 1 , num_warps + 1 )) num_wefts = max ( data . liftplan . keys ()) if data . liftplan else max ( data . treadling . keys ()) wefts_from1 = list ( range ( 1 , num_wefts + 1 )) default_warp_color = data . warp . color if data . warp . color is not None else 1 warp_colors = [ data . warp_colors . get ( warp , default_warp_color ) - 1 for warp in warps_from1 ] default_weft_color = data . weft . color if data . weft . color is not None else 2 weft_colors = [ data . weft_colors . get ( weft , default_weft_color ) - 1 for weft in wefts_from1 ] if data . liftplan : shaft_sets = [ data . liftplan . get ( weft , set ()) - { 0 } for weft in wefts_from1 ] else : shaft_sets = [] for weft in wefts_from1 : treadle_set = data . treadling . get ( weft , set ()) - { 0 } shaft_sets . append ( set . union ( * ( data . tieup [ treadle ] for treadle in treadle_set )) - { 0 }) if len ( shaft_sets ) != len ( weft_colors ): raise RuntimeError ( f \" { len ( shaft_sets ) =} != { len ( weft_colors ) =} \\n { shaft_sets =} \\n { weft_colors =} \" ) try : num_shafts = max ( max ( shaft_set ) for shaft_set in shaft_sets if shaft_set ) except ( ValueError , TypeError ): raise RuntimeError ( \"No shafts are raised\" ) from None threading = [ _smallest_shaft ( data . threading . get ( warp , { 0 })) - 1 for warp in warps_from1 ] all_shafts = set ( range ( 1 , num_shafts + 1 )) if data . is_rising_shed : shaft_words = [ shaft_word_from_shaft_set ( shaft_set ) for shaft_set in shaft_sets ] else : shaft_words = [ shaft_word_from_shaft_set ( all_shafts - shaft_set ) for shaft_set in shaft_sets ] picks = [ Pick ( shaft_word = shaft_word , color = weft_color ) for shaft_word , weft_color in zip ( shaft_words , weft_colors , strict = True ) ] return ReducedPattern ( color_table = color_strs , name = name , warp_colors = warp_colors , threading = threading , picks = picks , pick0 = Pick ( shaft_word = 0 , color = default_weft_color ), separate_weaving_repeats = len ( picks ) > NUM_ITEMS_FOR_REPEAT_SEPARATOR , separate_threading_repeats = len ( threading ) > NUM_ITEMS_FOR_REPEAT_SEPARATOR , ) def shaft_word_from_shaft_set ( shaft_set : Iterable [ int ]) -> int : docs \"\"\"Convert a shaft set to a shaft word. A shaft set is a collection of 1-based shafts numbers for shafts that are up. If 0 is present, it is ignored. A shaft word is a bit mask, with bit 0 = shaft 1; if a bit is high, that shaft is up. \"\"\" return sum ( 1 << shaft - 1 for shaft in shaft_set if shaft > 0 ) def shaft_set_from_shaft_word ( shaft_word : int ) -> set [ int ]: docs \"\"\"Convert a shaft word to a shaft set. See shaft_word_from_shaft_set for details. \"\"\" bin_str = bin ( shaft_word )[ 2 :] return { i + 1 for i , bit in enumerate ( reversed ( bin_str )) if bit == \"1\" }","title":"base_loom_server.reduced_pattern"},{"location":"api/base_loom_server/testutils/","text":"base_loom_server.testutils source module base_loom_server.testutils Classes Client \u2014 Client for testing loom servers. BaseTestLoomServer \u2014 Base class for server tests. Functions assert_replies_equal \u2014 Assert a portion of a reply matches the expected data. source assert_replies_equal ( reply : dict[str, Any ] , expected_reply : dict[str, Any ] ) \u2192 None Assert a portion of a reply matches the expected data. Only check items that are present in expected_reply . Raises AssertionError source class Client ( test_client : TestClient , loom_server : BaseLoomServer , mock_loom : BaseMockLoom , websocket : WebSocketType ) Client for testing loom servers. Methods send_dict \u2014 Write a dict as json. receive_dict \u2014 Read json as a dict. change_direction \u2014 Command the loom to weave or thread in the opposite direction, and read and check the reply, if one is expected. command_next_end \u2014 Command the next threading end group and test the replies. command_next_pick \u2014 Command the next pick and test the replies. command_settings \u2014 Send a setting command and check the replies. select_pattern \u2014 Tell the loom server to select a pattern. send_command \u2014 Issue a command and return all replies. upload_pattern \u2014 Upload a pattern to the loom server. source method Client . send_dict ( datadict : dict[str, Any ] ) \u2192 None Write a dict as json. source method Client . receive_dict ( ) \u2192 dict[str, Any ] Read json as a dict. source method Client . change_direction ( ) \u2192 None Command the loom to weave or thread in the opposite direction, and read and check the reply, if one is expected. Use a software command, if the loom supports that, else an oob command. Parameters client \u2014 Client fixture. source method Client . command_next_end ( * , expected_end_number0 : int , expected_end_number1 : int , expected_repeat_number : int , jump_pending : bool = False ) \u2192 None Command the next threading end group and test the replies. Ignore info-level StatusMessage Parameters expected_end_number0 : int \u2014 Expected end number0 of the next end group. expected_end_number1 : int \u2014 Expected end number1 of the next end group. expected_repeat_number : int \u2014 Expected repeat number of the next end group. jump_pending : bool \u2014 Is a jump pending? source method Client . command_next_pick ( * , expected_pick_number : int , expected_repeat_number : int , expected_shaft_word : int , jump_pending : bool = False ) \u2192 None Command the next pick and test the replies. Ignore info-level StatusMessage Parameters client \u2014 Client fixture. expected_pick_number : int \u2014 Expected pick number of the next pick. expected_repeat_number : int \u2014 Expected repeat number of the next pick. expected_shaft_word : int \u2014 Expected shaft_word of the next pick. jump_pending : bool \u2014 Is a jump pending? source method Client . command_settings ( * , should_fail : bool = False , ** settings : Any ) \u2192 None Send a setting command and check the replies. source method Client . select_pattern ( * , pattern_name : str , check_defaults : bool = True ) \u2192 ReducedPattern Tell the loom server to select a pattern. Read and check the expected replies and return the pattern. Parameters client \u2014 Client test fixture. pattern_name : str \u2014 Pattern name. check_defaults : bool \u2014 If true (the default), check that all pattern fields, that are updated as one weaves or threads (such as pick_value) have the expected default value. This is only safe for patterns that are newly loaded, or have not been woven on or threaded since being loaded. Returns current_pattern \u2014 the actual current_pattern in the loom server (rather than the one reconstructed from the ReducedPattern reply, so you can monitor internal changes). Raises AssertionError source method Client . send_command ( cmd_dict : dict[str, Any ] , * , should_fail : bool = False ) \u2192 list[dict[str, Any ]] Issue a command and return all replies. Parameters client \u2014 Test self. cmd_dict : dict[str, Any ] \u2014 Command to send, as a dict. should_fail : bool \u2014 If true, upload should fail. Returns replies \u2014 a list of replies (as dicts). The final reply will be CommandDone and its success flag is checked Raises AssertionError source method Client . upload_pattern ( * , filepath : Traversable , expected_names : Iterable [str] , should_fail : bool = False ) \u2192 None Upload a pattern to the loom server. Check expected replies. Parameters client \u2014 Test self. filepath : Traversable \u2014 Path to pattern file. expected_names : Iterable [str] \u2014 Expected pattern names. should_fail : bool \u2014 If true, upload should fail (and expected_names is ignored). source class BaseTestLoomServer ( ) Base class for server tests. Subclasses must Set class property app to the FastAPI app for your loom server. Have a name beginning with Test Not have an __init__ method Methods test_jump_to_end \u2014 Test the jump_to_end command. test_jump_to_pick \u2014 Test the jump_to_pick command. test_next_end \u2014 Test advancing to the next end. test_next_pick \u2014 Test advancing to the next pick. test_pattern_persistence \u2014 Test pattern persistence, including current location. test_select_pattern \u2014 Test the select_pattern command. test_settings_command \u2014 Test the settings command. test_read_settings_file \u2014 Test reading the settings file. test_upload \u2014 Test the upload command. test_weave_direction \u2014 Test changing the weave direction. create_test_client \u2014 Create a test client fixture. source method BaseTestLoomServer . test_jump_to_end ( ) \u2192 None Test the jump_to_end command. Raises RuntimeError source method BaseTestLoomServer . test_jump_to_pick ( ) \u2192 None Test the jump_to_pick command. Raises RuntimeError source method BaseTestLoomServer . test_next_end ( ) \u2192 None Test advancing to the next end. source method BaseTestLoomServer . test_next_pick ( ) \u2192 None Test advancing to the next pick. source method BaseTestLoomServer . test_pattern_persistence ( ) \u2192 None Test pattern persistence, including current location. Check that the location is saved when it changes. source method BaseTestLoomServer . test_select_pattern ( ) \u2192 None Test the select_pattern command. source method BaseTestLoomServer . test_settings_command ( ) \u2192 None Test the settings command. source method BaseTestLoomServer . test_read_settings_file ( ) \u2192 None Test reading the settings file. source method BaseTestLoomServer . test_upload ( ) \u2192 None Test the upload command. source method BaseTestLoomServer . test_weave_direction ( ) \u2192 None Test changing the weave direction. Raises pytest . skip source classmethod BaseTestLoomServer . create_test_client ( * , app : FastAPI | None , num_shafts : int = 24 , read_initial_state : bool = True , upload_patterns : Iterable [ pathlib . Path ] = () , reset_db : bool = False , db_path : pathlib . Path | str | None = None , expected_status_messages : Iterable [str] = () , expected_pattern_names : Iterable [str] = () , expected_current_pattern : ReducedPattern | None = None ) \u2192 Generator [ Client ] Create a test client fixture. Parameters app : FastAPI | None \u2014 Server application to test. If None, raise an error. num_shafts : int \u2014 The number of shafts that the loom has. read_initial_state : bool \u2014 If true, read and check the initial server replies from the websocket. This is the most common case. upload_patterns : Iterable [ pathlib . Path ] \u2014 Initial patterns to upload, if any. reset_db : bool \u2014 Specify argument --reset-db ? If False, you should also specify expected_pattern_names db_path : pathlib . Path | str | None \u2014 --db-path argument value. If None, use a temp file. If not None and you expect the database to contain any patterns, then also specify expected_pattern_names and expected_current_pattern . expected_status_messages : Iterable [str] \u2014 Expected status messages when the connection is made, in order. All should have severity level INFO. expected_pattern_names : Iterable [str] \u2014 Expected pattern names, in order. Specify if and only if db_path is not None and you expect the database to contain these patterns. expected_current_pattern : ReducedPattern | None \u2014 Expected_current_pattern. Specify if and only if db_path is not None and you expect the database to contain any patterns. Raises AssertionError","title":"base_loom_server.testutils"},{"location":"src/base_loom_server/testutils/","text":"base_loom_server.testutils docs module base_loom_server.testutils 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 import base64 import contextlib import copy import dataclasses import importlib.resources import itertools import json import pathlib import random import sys import tempfile from collections.abc import Generator , Iterable from importlib.resources.abc import Traversable from types import SimpleNamespace from typing import Any , TypeAlias import pytest from dtx_to_wif import read_pattern_file from fastapi import FastAPI from fastapi.testclient import TestClient from fastapi.websockets import WebSocket from starlette.testclient import WebSocketTestSession from .base_loom_server import MAX_THREAD_GROUP_SIZE , SETTINGS_FILE_NAME , BaseLoomServer from .base_mock_loom import BaseMockLoom from .enums import ( ConnectionStateEnum , DirectionControlEnum , MessageSeverityEnum , ModeEnum , ShaftStateEnum , ) from .reduced_pattern import ( DEFAULT_THREAD_GROUP_SIZE , NUM_ITEMS_FOR_REPEAT_SEPARATOR , ReducedPattern , reduced_pattern_from_pattern_data , ) from .utils import compute_total_num WebSocketType : TypeAlias = WebSocket | WebSocketTestSession _PKG_NAME = \"base_loom_server\" TEST_DATA_FILES = importlib . resources . files ( _PKG_NAME ) / \"test_data\" / \"pattern_files\" # in Python 3.11 mypy complains: \"Traversable\" has no attribute \"glob\" ALL_PATTERN_PATHS = ( list ( TEST_DATA_FILES . glob ( \"*.wif\" )) # type: ignore[attr-defined] + list ( TEST_DATA_FILES . glob ( \"*.dtx\" )) # type: ignore[attr-defined] + list ( TEST_DATA_FILES . glob ( \"*.wpo\" )) # type: ignore[attr-defined] ) docs def assert_replies_equal ( reply : dict [ str , Any ], expected_reply : dict [ str , Any ]) -> None : \"\"\"Assert a portion of a reply matches the expected data. Only check items that are present in `expected_reply`. \"\"\" for key , value in expected_reply . items (): if value is not None and reply . get ( key ) != value : raise AssertionError ( f \" { reply =} != { expected_reply } : failed on field { key !r} \" ) class Client : docs \"\"\"Client for testing loom servers.\"\"\" def __init__ ( self , test_client : TestClient , loom_server : BaseLoomServer , mock_loom : BaseMockLoom , websocket : WebSocketType , ) -> None : self . test_client = test_client self . loom_server = loom_server self . mock_loom = mock_loom self . websocket = websocket def send_dict ( self , datadict : dict [ str , Any ]) -> None : docs \"\"\"Write a dict as json.\"\"\" self . websocket . send_json ( datadict ) def receive_dict ( self ) -> dict [ str , Any ]: docs \"\"\"Read json as a dict.\"\"\" data : Any = self . websocket . receive_json () assert isinstance ( data , dict ) return data def change_direction ( self ) -> None : docs \"\"\"Command the loom to weave or thread in the opposite direction, and read and check the reply, if one is expected. Use a software command, if the loom supports that, else an oob command. Args: client: Client fixture. \"\"\" expected_direction_reply = True self . mock_loom . command_threading_event . clear () if self . loom_server . enable_software_direction : direction_forward = not self . loom_server . direction_forward replies = self . send_command ( dict ( type = \"direction\" , forward = direction_forward )) else : expected_direction_reply = self . loom_server . loom_reports_direction direction_forward = not self . mock_loom . direction_forward replies = self . send_command ( dict ( type = \"oobcommand\" , command = \"d\" )) if expected_direction_reply : assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ][ \"type\" ] == \"Direction\" assert replies [ 0 ][ \"forward\" ] == direction_forward else : assert len ( replies ) == 1 # Give the loom self time to process the command self . mock_loom . command_threading_event . wait ( timeout = 1 ) def command_next_end ( docs self , * , expected_end_number0 : int , expected_end_number1 : int , expected_repeat_number : int , jump_pending : bool = False , ) -> None : \"\"\"Command the next threading end group and test the replies. Ignore info-level StatusMessage Args: expected_end_number0: Expected end number0 of the next end group. expected_end_number1: Expected end number1 of the next end group. expected_repeat_number: Expected repeat number of the next end group. jump_pending: Is a jump pending? \"\"\" pattern = self . loom_server . current_pattern assert pattern is not None self . mock_loom . command_threading_event . clear () replies = self . send_command ( dict ( type = \"oobcommand\" , command = \"n\" )) assert len ( replies ) == 1 # Give the loom client time to process the command self . mock_loom . command_threading_event . wait ( timeout = 1 ) expected_shaft_word = pattern . get_threading_shaft_word () expected_replies : list [ dict [ str , Any ]] = [] if jump_pending : expected_replies += [ dict ( type = \"JumpEndNumber\" , end_number0 = None , end_repeat_number = None , ), ] num_ends_in_pattern = len ( pattern . threading ) expected_total_end_number0 = compute_total_num ( num_within = expected_end_number0 , repeat_number = expected_repeat_number , repeat_len = num_ends_in_pattern , ) expected_total_end_number1 = compute_total_num ( num_within = expected_end_number1 , repeat_number = expected_repeat_number , repeat_len = num_ends_in_pattern , ) expected_replies += [ dict ( type = \"CurrentEndNumber\" , end_number0 = expected_end_number0 , end_number1 = expected_end_number1 , total_end_number0 = expected_total_end_number0 , total_end_number1 = expected_total_end_number1 , end_repeat_number = expected_repeat_number , ), ] if self . loom_server . loom_reports_motion : expected_replies += [ dict ( type = \"ShaftState\" , state = ShaftStateEnum . MOVING , shaft_word = None , ), dict ( type = \"ShaftState\" , state = ShaftStateEnum . MOVING , shaft_word = None , ), ] expected_replies += [ dict ( type = \"ShaftState\" , state = ShaftStateEnum . DONE , shaft_word = expected_shaft_word , ), ] for expected_reply in expected_replies : reply = self . receive_dict () if reply [ \"type\" ] == \"ServerMessage\" and reply [ \"severity\" ] == MessageSeverityEnum . INFO : # Ignore info-level status messages continue assert_replies_equal ( reply , expected_reply ) def command_next_pick ( docs self , * , expected_pick_number : int , expected_repeat_number : int , expected_shaft_word : int , jump_pending : bool = False , ) -> None : \"\"\"Command the next pick and test the replies. Ignore info-level StatusMessage Args: client: Client fixture. expected_pick_number: Expected pick number of the next pick. expected_repeat_number: Expected repeat number of the next pick. expected_shaft_word: Expected shaft_word of the next pick. jump_pending: Is a jump pending? \"\"\" replies = self . send_command ( dict ( type = \"oobcommand\" , command = \"n\" )) assert len ( replies ) == 1 expected_replies : list [ dict [ str , Any ]] = [] if ( not self . loom_server . enable_software_direction and not self . loom_server . loom_reports_direction and self . loom_server . direction_forward != self . mock_loom . direction_forward ): # Loom only reports direction when it asks for a pick # and the direction has changed expected_replies += [ dict ( type = \"Direction\" , forward = self . mock_loom . direction_forward , ) ] if jump_pending : expected_replies += [ dict ( type = \"JumpPickNumber\" , pick_number = None , pick_repeat_number = None , ), ] expected_replies += [ dict ( type = \"CurrentPickNumber\" , pick_number = expected_pick_number , total_pick_number = None , pick_repeat_number = expected_repeat_number , ), ] if self . loom_server . loom_reports_motion : expected_replies += [ dict ( type = \"ShaftState\" , state = ShaftStateEnum . MOVING , shaft_word = None , ), dict ( type = \"ShaftState\" , state = ShaftStateEnum . MOVING , shaft_word = None , ), ] expected_replies += [ dict ( type = \"ShaftState\" , state = ShaftStateEnum . DONE , shaft_word = expected_shaft_word , ), ] for expected_reply in expected_replies : reply = self . receive_dict () if reply [ \"type\" ] == \"ServerMessage\" and reply [ \"severity\" ] == MessageSeverityEnum . INFO : # Ignore info-level status messages continue assert_replies_equal ( reply , expected_reply ) def command_settings ( docs self , * , should_fail : bool = False , ** settings : Any , # noqa: ANN401 ) -> None : \"\"\"Send a setting command and check the replies.\"\"\" settings_cmd = settings . copy () initial_settings = copy . copy ( self . loom_server . settings ) settings_cmd [ \"type\" ] = \"settings\" replies = self . send_command ( settings_cmd , should_fail = should_fail ) if should_fail : assert len ( replies ) == 1 assert self . loom_server . settings == initial_settings else : assert len ( replies ) == 2 # noqa: PLR2004 reported_settings = replies [ 0 ] for key , value in settings . items (): assert reported_settings [ key ] == value for key , value in reported_settings . items (): assert getattr ( self . loom_server . settings , key ) == value expected_thread_low_to_high = ( self . loom_server . settings . thread_back_to_front == self . loom_server . settings . thread_right_to_left ) if not self . loom_server . direction_forward : expected_thread_low_to_high = not expected_thread_low_to_high if not self . loom_server . settings . end1_on_right : expected_thread_low_to_high = not expected_thread_low_to_high assert self . loom_server . thread_low_to_high == expected_thread_low_to_high def select_pattern ( docs self , * , pattern_name : str , check_defaults : bool = True , ) -> ReducedPattern : \"\"\"Tell the loom server to select a pattern. Read and check the expected replies and return the pattern. Args: client: Client test fixture. pattern_name: Pattern name. check_defaults: If true (the default), check that all pattern fields, that are updated as one weaves or threads (such as pick_value) have the expected default value. This is only safe for patterns that are newly loaded, or have not been woven on or threaded since being loaded. Returns: current_pattern: the actual current_pattern in the loom server (rather than the one reconstructed from the ReducedPattern reply, so you can monitor internal changes). \"\"\" expected_seen_types = { \"CommandDone\" , \"CurrentPickNumber\" , \"CurrentEndNumber\" , \"ReducedPattern\" , \"SeparateThreadingRepeats\" , \"SeparateWeavingRepeats\" , \"ThreadGroupSize\" , } replies = self . send_command ( dict ( type = \"select_pattern\" , name = pattern_name )) assert len ( replies ) == len ( expected_seen_types ) pattern_reply = replies [ 0 ] assert pattern_reply [ \"type\" ] == \"ReducedPattern\" pattern_in_reply = ReducedPattern . from_dict ( pattern_reply ) if check_defaults : assert pattern_in_reply . pick_number == 0 assert pattern_in_reply . pick_repeat_number == 1 assert pattern_in_reply . end_number0 == 0 assert pattern_in_reply . end_number1 == 0 assert pattern_in_reply . end_repeat_number == 1 assert pattern_in_reply . thread_group_size == DEFAULT_THREAD_GROUP_SIZE assert bool ( pattern_in_reply . separate_threading_repeats ) == ( len ( pattern_in_reply . threading ) > NUM_ITEMS_FOR_REPEAT_SEPARATOR ) assert bool ( pattern_in_reply . separate_weaving_repeats ) == ( len ( pattern_in_reply . picks ) > NUM_ITEMS_FOR_REPEAT_SEPARATOR ) seen_types : set [ str ] = { \"ReducedPattern\" } for reply_dict in replies [ 1 :]: reply = SimpleNamespace ( ** reply_dict ) match reply . type : case \"CommandDone\" : assert reply . cmd_type == \"select_pattern\" assert reply . success case \"CurrentPickNumber\" : assert reply . pick_number == pattern_in_reply . pick_number assert reply . pick_repeat_number == pattern_in_reply . pick_repeat_number assert reply . total_pick_number == compute_total_num ( num_within = pattern_in_reply . pick_number , repeat_number = pattern_in_reply . pick_repeat_number , repeat_len = len ( pattern_in_reply . picks ), ) case \"CurrentEndNumber\" : assert reply . end_number0 == pattern_in_reply . end_number0 assert reply . end_number1 == pattern_in_reply . end_number1 assert reply . end_repeat_number == pattern_in_reply . end_repeat_number assert reply . total_end_number0 == compute_total_num ( num_within = pattern_in_reply . end_number0 , repeat_number = pattern_in_reply . end_repeat_number , repeat_len = pattern_in_reply . num_ends , ) assert reply . total_end_number1 == compute_total_num ( num_within = pattern_in_reply . end_number1 , repeat_number = pattern_in_reply . end_repeat_number , repeat_len = pattern_in_reply . num_ends , ) case \"SeparateThreadingRepeats\" : assert reply . separate == pattern_in_reply . separate_threading_repeats case \"SeparateWeavingRepeats\" : assert reply . separate == pattern_in_reply . separate_weaving_repeats case \"ThreadGroupSize\" : assert reply . group_size == pattern_in_reply . thread_group_size case _ : raise AssertionError ( f \"Unexpected message type { reply . type } \" ) seen_types . add ( reply . type ) assert seen_types == expected_seen_types assert self . loom_server . current_pattern is not None return self . loom_server . current_pattern docs def send_command ( self , cmd_dict : dict [ str , Any ], * , should_fail : bool = False ) -> list [ dict [ str , Any ]]: \"\"\"Issue a command and return all replies. Args: client: Test self. cmd_dict: Command to send, as a dict. should_fail: If true, upload should fail. Returns: replies: a list of replies (as dicts). The final reply will be CommandDone and its success flag is checked \"\"\" self . send_dict ( cmd_dict ) replies = [] while True : reply = self . receive_dict () replies . append ( reply ) if reply [ \"type\" ] == \"CommandDone\" : if should_fail == reply [ \"success\" ]: if should_fail : raise AssertionError ( f \"Command { cmd_dict } succeeded, but should have failed\" ) raise AssertionError ( f \"Command { cmd_dict } failed\" ) break return replies def upload_pattern ( docs self , * , filepath : Traversable , expected_names : Iterable [ str ], should_fail : bool = False , ) -> None : \"\"\"Upload a pattern to the loom server. Check expected replies. Args: client: Test self. filepath: Path to pattern file. expected_names: Expected pattern names. should_fail: If true, upload should fail (and `expected_names` is ignored). \"\"\" suffix = pathlib . Path ( str ( filepath )) . suffix if suffix == \".wpo\" : raw_data = filepath . read_bytes () data = base64 . b64encode ( raw_data ) . decode ( \"ascii\" ) else : data = filepath . read_text () replies = self . send_command ( dict ( type = \"upload\" , name = filepath . name , data = data ), should_fail = should_fail , ) if should_fail : assert len ( replies ) == 1 else : assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ] == dict ( type = \"PatternNames\" , names = list ( expected_names )) class BaseTestLoomServer : docs \"\"\"Base class for server tests. Subclasses must: * Set class property `app` to the FastAPI app for your loom server. * Have a name beginning with Test * Not have an `__init__` method \"\"\" expected_status_messages = () app : FastAPI | None = None extra_args = () def test_jump_to_end ( self ) -> None : docs \"\"\"Test the jump_to_end command.\"\"\" pattern_name = ALL_PATTERN_PATHS [ 4 ] . name with self . create_test_client ( app = self . app , num_shafts = 32 , upload_patterns = ALL_PATTERN_PATHS [ 2 : 5 ], ) as client : pattern = client . select_pattern ( pattern_name = pattern_name ) num_ends_in_pattern = len ( pattern . threading ) replies = client . send_command ( dict ( type = \"mode\" , mode = ModeEnum . THREAD )) assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ] == dict ( type = \"Mode\" , mode = ModeEnum . THREAD ) # post_action sets what to do after sending the jump_to_end cmd: # * cancel: cancel the jump_to_pick # * next: advance to the next end (thus accepting the jump) # * nothing: do nothing for ( thread_group_size , post_action , end_number0 , end_repeat_number , ) in itertools . product ( ( 1 , 4 ), ( \"cancel\" , \"next\" , \"nothing\" ), ( 0 , 1 , num_ends_in_pattern // 3 , num_ends_in_pattern ), ( 1 , 2 ), ): replies = client . send_command ( dict ( type = \"thread_group_size\" , group_size = thread_group_size )) assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ] == dict ( type = \"ThreadGroupSize\" , group_size = thread_group_size ) assert pattern . thread_group_size == thread_group_size total_end_number0 = compute_total_num ( num_within = end_number0 , repeat_number = end_repeat_number , repeat_len = num_ends_in_pattern , ) replies = client . send_command ( dict ( type = \"jump_to_end\" , total_end_number0 = total_end_number0 ), ) assert len ( replies ) == 2 # noqa: PLR2004 jump_end_reply = SimpleNamespace ( ** replies [ 0 ]) if total_end_number0 == 0 : # Jump to end_number0 0, repeat_number 1. assert jump_end_reply == SimpleNamespace ( type = \"JumpEndNumber\" , total_end_number0 = 0 , total_end_number1 = 0 , end_number0 = 0 , end_number1 = 0 , end_repeat_number = 1 , ) elif end_number0 == 0 : # Jump to end_number0 0, repeat_number not 1. # Report the last end of the previous repeat, # rather than the magic \"0\" end_number0 assert jump_end_reply == SimpleNamespace ( type = \"JumpEndNumber\" , total_end_number0 = total_end_number0 , total_end_number1 = total_end_number0 , end_number0 = num_ends_in_pattern , end_number1 = num_ends_in_pattern , end_repeat_number = end_repeat_number - 1 , ) else : end_delta = pattern . compute_end_number1 ( end_number0 ) - end_number0 # Jump to a nonzero end_number0. assert jump_end_reply == SimpleNamespace ( type = \"JumpEndNumber\" , total_end_number0 = total_end_number0 , total_end_number1 = total_end_number0 + end_delta , end_number0 = end_number0 , end_number1 = end_number0 + end_delta , end_repeat_number = end_repeat_number , ) match post_action : case \"cancel\" : replies = client . send_command ( dict ( type = \"jump_to_end\" , total_end_number0 = None )) assert len ( replies ) == 2 # noqa: PLR2004 jump_end_cancel_reply = SimpleNamespace ( ** replies [ 0 ]) assert jump_end_cancel_reply == SimpleNamespace ( type = \"JumpEndNumber\" , total_end_number0 = None , total_end_number1 = None , end_number0 = None , end_number1 = None , end_repeat_number = None , ) case \"next\" : # Test against jump_end_reply because we already # checked that against expected values. client . command_next_end ( expected_end_number0 = jump_end_reply . end_number0 , expected_end_number1 = jump_end_reply . end_number1 , expected_repeat_number = jump_end_reply . end_repeat_number , jump_pending = True , ) case \"nothing\" : pass case _ : raise RuntimeError ( f \"Unsupported { post_action =!r} \" ) # Test jumping to invalid ends, including # that the bad command doesn't change the pattern's end numbers. end_field_names = ( \"end_number0\" , \"end_number1\" , \"end_repeat_number\" ) current_end_data = { field_name : getattr ( client . loom_server . current_pattern , field_name ) for field_name in end_field_names } for bad_total_end_number0 in ( - 1 , - 2 ): client . send_command ( dict ( type = \"jump_to_end\" , total_end_number0 = bad_total_end_number0 ), should_fail = True , ) for field_name in end_field_names : assert ( getattr ( client . loom_server . current_pattern , field_name ) == current_end_data [ field_name ] ) def test_jump_to_pick ( self ) -> None : docs \"\"\"Test the jump_to_pick command.\"\"\" pattern_name = ALL_PATTERN_PATHS [ 3 ] . name with self . create_test_client ( app = self . app , num_shafts = 32 , upload_patterns = ALL_PATTERN_PATHS [ 2 : 5 ], ) as client : pattern = client . select_pattern ( pattern_name = pattern_name ) num_picks_in_pattern = len ( pattern . picks ) # post_action sets what to do after sending the jump_to_pick cmd: # * cancel: cancel the jump_to_pick # * next: advance to the next pick (thus accepting the jump) # * nothing: do nothing for post_action , pick_number , pick_repeat_number in itertools . product ( ( \"cancel\" , \"next\" , \"nothing\" ), ( 0 , 1 , num_picks_in_pattern // 3 , num_picks_in_pattern ), ( 1 , 2 ), ): total_pick_number = compute_total_num ( num_within = pick_number , repeat_number = pick_repeat_number , repeat_len = num_picks_in_pattern , ) replies = client . send_command ( dict ( type = \"jump_to_pick\" , total_pick_number = total_pick_number )) assert len ( replies ) == 2 # noqa: PLR2004 jump_pick_reply = SimpleNamespace ( ** replies [ 0 ]) if total_pick_number == 0 : # Jump to pick_number 0, repeat_number 1. assert jump_pick_reply == SimpleNamespace ( type = \"JumpPickNumber\" , total_pick_number = 0 , pick_number = 0 , pick_repeat_number = 1 , ) elif pick_number == 0 : # Jump to pick_number 0, repeat_number not 1. # Report the last pick of the previous repeat, # rather than the magic \"0\" pick_number assert jump_pick_reply == SimpleNamespace ( type = \"JumpPickNumber\" , total_pick_number = total_pick_number , pick_number = num_picks_in_pattern , pick_repeat_number = pick_repeat_number - 1 , ) else : # Jump to a nonzero pick_number. assert jump_pick_reply == SimpleNamespace ( type = \"JumpPickNumber\" , total_pick_number = total_pick_number , pick_number = pick_number , pick_repeat_number = pick_repeat_number , ) match post_action : case \"cancel\" : replies = client . send_command ( dict ( type = \"jump_to_pick\" , total_pick_number = None )) assert len ( replies ) == 2 # noqa: PLR2004 jump_pick_cancel_reply = SimpleNamespace ( ** replies [ 0 ]) assert jump_pick_cancel_reply == SimpleNamespace ( type = \"JumpPickNumber\" , total_pick_number = None , pick_number = None , pick_repeat_number = None , ) case \"next\" : client . command_next_pick ( expected_pick_number = jump_pick_reply . pick_number , expected_repeat_number = jump_pick_reply . pick_repeat_number , expected_shaft_word = pattern . get_pick ( jump_pick_reply . pick_number ) . shaft_word , jump_pending = True , ) case \"nothing\" : pass case _ : raise RuntimeError ( f \"Unsupported { post_action =!r} \" ) # Test jumping to invalid picks, including # that the bad command doesn't change the pattern's pick numbers. pick_field_names = ( \"pick_number\" , \"pick_repeat_number\" ) current_pick_data = { field_name : getattr ( client . loom_server . current_pattern , field_name ) for field_name in pick_field_names } for bad_total_pick_number in ( - 1 , - 2 ): client . send_command ( dict ( type = \"jump_to_pick\" , total_pick_number = bad_total_pick_number ), should_fail = True , ) for field_name in pick_field_names : assert ( getattr ( client . loom_server . current_pattern , field_name ) == current_pick_data [ field_name ] ) def test_next_end ( self ) -> None : docs \"\"\"Test advancing to the next end.\"\"\" pattern_name = ALL_PATTERN_PATHS [ 1 ] . name with self . create_test_client ( app = self . app , upload_patterns = ALL_PATTERN_PATHS [ 0 : 3 ], ) as client : pattern = client . select_pattern ( pattern_name = pattern_name ) num_ends_in_pattern = len ( pattern . threading ) replies = client . send_command ( dict ( type = \"mode\" , mode = ModeEnum . THREAD )) assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ] == dict ( type = \"Mode\" , mode = ModeEnum . THREAD ) for separate_threading_repeats , thread_group_size in itertools . product ( ( False , True ), ( 1 , 2 , 3 , num_ends_in_pattern - 1 , num_ends_in_pattern , num_ends_in_pattern + 1 , ), ): print ( # noqa: T201 f \" { separate_threading_repeats =} , { thread_group_size =} \" ) # Restore initial state that we care about. client . loom_server . settings . end1_on_right = True client . loom_server . settings . thread_back_to_front = True client . loom_server . settings . thread_right_to_left = True client . loom_server . direction_forward = True pattern . set_current_end_number ( end_number0 = 0 , end_repeat_number = 1 ) expected_end_number0 = 0 expected_end_number1 = 0 expected_repeat_number = 1 # Start threading low to high assert client . loom_server . thread_low_to_high replies = client . send_command ( dict ( type = \"separate_threading_repeats\" , separate = separate_threading_repeats , ), ) assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ] == dict ( type = \"SeparateThreadingRepeats\" , separate = separate_threading_repeats ) assert pattern . separate_threading_repeats == separate_threading_repeats replies = client . send_command ( dict ( type = \"thread_group_size\" , group_size = thread_group_size )) assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ] == dict ( type = \"ThreadGroupSize\" , group_size = thread_group_size ) assert pattern . thread_group_size == thread_group_size # Make enough low_to_high end advances to get into 3rd repeat expected_end_number0 = 0 expected_repeat_number = 1 while expected_repeat_number < 3 : # noqa: PLR2004 ( expected_end_number0 , expected_end_number1 , expected_repeat_number , ) = pattern . compute_next_end_numbers ( thread_low_to_high = True ) client . command_next_end ( expected_end_number0 = expected_end_number0 , expected_end_number1 = expected_end_number1 , expected_repeat_number = expected_repeat_number , ) # Change to high-to-low client . change_direction () assert not client . loom_server . thread_low_to_high # Make enough advances to get to the beginning while True : try : ( expected_end_number0 , expected_end_number1 , expected_repeat_number , ) = pattern . compute_next_end_numbers ( thread_low_to_high = False ) except IndexError : break client . command_next_end ( expected_end_number0 = expected_end_number0 , expected_end_number1 = expected_end_number1 , expected_repeat_number = expected_repeat_number , ) assert expected_repeat_number == 1 assert expected_end_number0 == 0 # Another advance should be rejected, # without changing the end numbers in the pattern. client . send_command ( dict ( type = \"oobcommand\" , command = \"n\" )) reply = client . receive_dict () assert reply [ \"message\" ] == \"At start of threading\" assert reply [ \"severity\" ] == MessageSeverityEnum . ERROR assert pattern . end_number0 == expected_end_number0 assert pattern . end_number1 == expected_end_number1 assert pattern . end_repeat_number == expected_repeat_number # Toggle low_to_high by toggling end1_at_right client . command_settings ( end1_on_right = not client . loom_server . settings . end1_on_right ) assert client . loom_server . thread_low_to_high client . command_next_end ( expected_end_number0 = 1 , expected_end_number1 = min ( num_ends_in_pattern , thread_group_size ), expected_repeat_number = 1 , ) # Toggle low_to_high by toggling thread_back_to_front client . command_settings ( thread_back_to_front = not client . loom_server . settings . thread_back_to_front , ) assert not client . loom_server . thread_low_to_high client . command_next_end ( expected_end_number0 = 0 , expected_end_number1 = 0 , expected_repeat_number = 1 , ) # Toggle low_to_high by toggling thread_right_to_left client . command_settings ( thread_right_to_left = not client . loom_server . settings . thread_right_to_left , ) assert client . loom_server . thread_low_to_high client . command_next_end ( expected_end_number0 = 1 , expected_end_number1 = min ( num_ends_in_pattern , thread_group_size ), expected_repeat_number = 1 , ) def test_next_pick ( self ) -> None : docs \"\"\"Test advancing to the next pick.\"\"\" pattern_name = ALL_PATTERN_PATHS [ 2 ] . name with self . create_test_client ( app = self . app , upload_patterns = ALL_PATTERN_PATHS [ 0 : 3 ], ) as client : pattern = client . select_pattern ( pattern_name = pattern_name ) # Make enough forward picks to get into the 3rd repeat expected_pick_number = 0 expected_repeat_number = 1 assert client . loom_server . direction_forward while True : expected_pick_number , expected_repeat_number = pattern . compute_next_pick_numbers ( direction_forward = True ) expected_shaft_word = pattern . get_pick ( expected_pick_number ) . shaft_word client . command_next_pick ( expected_pick_number = expected_pick_number , expected_repeat_number = expected_repeat_number , expected_shaft_word = expected_shaft_word , ) if expected_repeat_number == 3 : # noqa: PLR2004 break client . change_direction () assert not client . loom_server . direction_forward # Now go backwards to the beginning while True : try : expected_pick_number , expected_repeat_number = pattern . compute_next_pick_numbers ( direction_forward = False ) except IndexError : break expected_shaft_word = pattern . get_pick ( expected_pick_number ) . shaft_word client . command_next_pick ( expected_pick_number = expected_pick_number , expected_repeat_number = expected_repeat_number , expected_shaft_word = expected_shaft_word , ) assert expected_pick_number == 0 assert expected_repeat_number == 1 # Another advance should be rejected, # without changing the pick numbers in the pattern. client . send_command ( dict ( type = \"oobcommand\" , command = \"n\" )) reply = client . receive_dict () assert reply [ \"message\" ] == \"At start of weaving\" assert reply [ \"severity\" ] == MessageSeverityEnum . ERROR assert pattern . pick_number == expected_pick_number assert pattern . pick_repeat_number == expected_repeat_number # Change direction to forward client . change_direction () assert client . loom_server . direction_forward def test_pattern_persistence ( self ) -> None : docs \"\"\"Test pattern persistence, including current location. Check that the location is saved when it changes. \"\"\" rnd = random . Random ( 47 ) pattern_list = [] with tempfile . TemporaryDirectory () as temp_dir : db_path = pathlib . Path ( temp_dir ) / \"loom_server_database.sqlite\" with self . create_test_client ( app = self . app , upload_patterns = ALL_PATTERN_PATHS , db_path = db_path , ) as client : # Select a few patterns; for each one jump to some random # pick and some random end_number0, including actually # going to that pick or end. assert len ( ALL_PATTERN_PATHS ) > 3 # noqa: PLR2004 for path in ( ALL_PATTERN_PATHS [ 0 ], ALL_PATTERN_PATHS [ 3 ]): # If needed, go to weaving mode if client . loom_server . mode != ModeEnum . WEAVE : replies = client . send_command ( dict ( type = \"mode\" , mode = ModeEnum . WEAVE )) assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ] == dict ( type = \"Mode\" , mode = ModeEnum . WEAVE ) pattern = client . select_pattern ( pattern_name = path . name ) num_ends_in_pattern = len ( pattern . threading ) num_picks_in_pattern = len ( pattern . picks ) pattern_list . append ( pattern ) pick_number = rnd . randrange ( 0 , num_picks_in_pattern ) pick_repeat_number = rnd . randrange ( 1 , 10 ) thread_group_size = rnd . randrange ( 1 , 10 ) end_number0 = rnd . randrange ( 0 , num_ends_in_pattern ) end_number1 = ( 0 if end_number0 == 0 else min ( end_number0 + thread_group_size - 1 , num_ends_in_pattern ) ) end_repeat_number = rnd . randrange ( 1 , 10 ) separate_threading_repeats = rnd . choice (( True , False )) separate_weaving_repeats = rnd . choice (( True , False )) if pattern . separate_threading_repeats != separate_threading_repeats : replies = client . send_command ( dict ( type = \"separate_threading_repeats\" , separate = separate_threading_repeats , ) ) assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ] == dict ( type = \"SeparateThreadingRepeats\" , separate = separate_threading_repeats , ) if pattern . separate_weaving_repeats != separate_weaving_repeats : replies = client . send_command ( dict ( type = \"separate_weaving_repeats\" , separate = separate_weaving_repeats , ), ) assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ] == dict ( type = \"SeparateWeavingRepeats\" , separate = separate_weaving_repeats , ) total_pick_number = compute_total_num ( num_within = pick_number , repeat_number = pick_repeat_number , repeat_len = num_picks_in_pattern , ) replies = client . send_command ( dict ( type = \"jump_to_pick\" , total_pick_number = total_pick_number ), ) assert len ( replies ) == 2 # noqa: PLR2004 if total_pick_number == 0 : assert total_pick_number == 0 assert pick_number == 0 assert pick_repeat_number == 1 elif pick_number == 0 and total_pick_number != 0 : # Special case: report the last pick of the previous # repeat, rather than the magic \"0\" pick_number pick_number = num_picks_in_pattern pick_repeat_number -= 1 assert replies [ 0 ] == dict ( type = \"JumpPickNumber\" , total_pick_number = total_pick_number , pick_number = pick_number , pick_repeat_number = pick_repeat_number , ) expected_shaft_word = pattern . get_pick ( pick_number ) . shaft_word client . command_next_pick ( jump_pending = True , expected_pick_number = pick_number , expected_repeat_number = pick_repeat_number , expected_shaft_word = expected_shaft_word , ) # Now advance to the desired end. # First set mode to threading and set thread group size, # Then jump to the pick and advance. replies = client . send_command ( dict ( type = \"mode\" , mode = ModeEnum . THREAD )) assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ] == dict ( type = \"Mode\" , mode = ModeEnum . THREAD ) replies = client . send_command ( dict ( type = \"thread_group_size\" , group_size = thread_group_size , ), ) assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ] == dict ( type = \"ThreadGroupSize\" , group_size = thread_group_size , ) total_end_number0 = compute_total_num ( num_within = end_number0 , repeat_number = end_repeat_number , repeat_len = num_ends_in_pattern , ) total_end_number1 = compute_total_num ( num_within = end_number1 , repeat_number = end_repeat_number , repeat_len = num_ends_in_pattern , ) replies = client . send_command ( dict ( type = \"jump_to_end\" , total_end_number0 = total_end_number0 ), ) if total_end_number0 == 0 : assert total_end_number1 == 0 assert end_number0 == 0 assert end_number1 == 0 assert end_repeat_number == 1 elif end_number0 == 0 and total_end_number0 != 0 : # Special case: report the last end of the previous # repeat, rather than the magic \"0\" end_number0 end_repeat_number -= 1 end_number0 = num_ends_in_pattern end_number1 = num_ends_in_pattern assert replies [ 0 ] == dict ( type = \"JumpEndNumber\" , total_end_number0 = total_end_number0 , total_end_number1 = total_end_number1 , end_number0 = end_number0 , end_number1 = end_number1 , end_repeat_number = end_repeat_number , ) client . command_next_end ( jump_pending = True , expected_end_number0 = end_number0 , expected_end_number1 = end_number1 , expected_repeat_number = end_repeat_number , ) assert pattern . pick_number == pick_number assert pattern . pick_repeat_number == pick_repeat_number assert pattern . end_number0 == end_number0 assert pattern . end_number1 == end_number1 assert pattern . end_repeat_number == end_repeat_number assert pattern . separate_threading_repeats == separate_threading_repeats assert pattern . separate_weaving_repeats == separate_weaving_repeats # This expects that first pattern 0 and then pattern 3 # was selected from ALL_PATTERN_PATHS: all_pattern_names = [ path . name for path in ALL_PATTERN_PATHS ] expected_pattern_names = ( all_pattern_names [ 1 : 3 ] + all_pattern_names [ 4 :] + [ all_pattern_names [ 0 ], all_pattern_names [ 3 ]] ) expected_current_pattern = pattern_list [ 1 ] with self . create_test_client ( app = self . app , reset_db = False , expected_pattern_names = expected_pattern_names , expected_current_pattern = expected_current_pattern , db_path = db_path , ) as client : for pattern in pattern_list : returned_pattern = client . select_pattern ( pattern_name = pattern . name , check_defaults = False , ) assert returned_pattern == pattern # Now try again, but this time reset the database with self . create_test_client ( app = self . app , reset_db = True , ) as client : pass def test_select_pattern ( self ) -> None : docs \"\"\"Test the select_pattern command.\"\"\" # Read a pattern file in and convert the data to a ReducedPattern pattern_path = ALL_PATTERN_PATHS [ 1 ] pattern_data = read_pattern_file ( pattern_path ) reduced_pattern = reduced_pattern_from_pattern_data ( name = pattern_path . name , data = pattern_data ) with self . create_test_client ( app = self . app , upload_patterns = ALL_PATTERN_PATHS [ 0 : 3 ], ) as client : selected_pattern = client . select_pattern ( pattern_name = pattern_path . name ) assert selected_pattern == reduced_pattern def test_settings_command ( self ) -> None : docs \"\"\"Test the settings command.\"\"\" with self . create_test_client ( app = self . app ) as client : initial_settings = copy . copy ( client . loom_server . settings ) if client . loom_server . supports_full_direction_control : assert initial_settings . direction_control is DirectionControlEnum . FULL else : assert initial_settings . direction_control is not DirectionControlEnum . FULL for direction_control , should_fail in { DirectionControlEnum . FULL : ( ( DirectionControlEnum . LOOM , True ), ( DirectionControlEnum . SOFTWARE , True ), ( DirectionControlEnum . FULL , False ), ), DirectionControlEnum . SOFTWARE : ( ( DirectionControlEnum . LOOM , False ), ( DirectionControlEnum . SOFTWARE , False ), ( DirectionControlEnum . FULL , True ), ), DirectionControlEnum . LOOM : ( ( DirectionControlEnum . SOFTWARE , False ), ( DirectionControlEnum . LOOM , False ), ( DirectionControlEnum . FULL , True ), ), }[ initial_settings . direction_control ]: client . command_settings ( direction_control = direction_control , should_fail = should_fail ) for loom_name in ( \"\" , \"?\" , \"S\u00e9guin Loom\" ): client . command_settings ( loom_name = loom_name ) for end1_on_right in ( not initial_settings . end1_on_right , initial_settings . end1_on_right , ): client . command_settings ( end1_on_right = end1_on_right ) for bad_bool in ( \"hello\" , 0 , 1 ): client . command_settings ( end1_on_right = bad_bool , should_fail = True , ) for thread_group_size in ( 1 , 2 , MAX_THREAD_GROUP_SIZE ): client . command_settings ( thread_group_size = thread_group_size ) for bad_thread_group_size in ( - 1 , 0 , MAX_THREAD_GROUP_SIZE + 1 ): client . command_settings ( thread_group_size = bad_thread_group_size , should_fail = True ) for thread_back_to_front in ( not initial_settings . thread_back_to_front , initial_settings . thread_back_to_front , ): client . command_settings ( thread_back_to_front = thread_back_to_front ) for bad_bool in ( \"hello\" , 0 , 1 ): client . command_settings ( thread_back_to_front = bad_bool , should_fail = True , ) for thread_right_to_left in ( not initial_settings . thread_right_to_left , initial_settings . thread_right_to_left , ): client . command_settings ( thread_right_to_left = thread_right_to_left ) for bad_bool in ( \"hello\" , 0 , 1 ): client . command_settings ( thread_right_to_left = bad_bool , should_fail = True , ) def test_read_settings_file ( self ) -> None : docs \"\"\"Test reading the settings file.\"\"\" with self . create_test_client ( app = self . app ) as client : default_settings = copy . copy ( client . loom_server . settings ) supports_full_direction_control = client . loom_server . supports_full_direction_control # Test settings files with no usable data. # The resulting settings should match the default. for unusable_settings_json in ( \"\" , \"?\" , \"} not json\" , \"{'not_a_key': true}\" ): with tempfile . TemporaryDirectory () as temp_dir : db_path = pathlib . Path ( temp_dir ) / \"loom_server_database.sqlite\" settings_path = pathlib . Path ( temp_dir ) / SETTINGS_FILE_NAME with settings_path . open ( \"w\" ) as f : f . write ( unusable_settings_json ) with self . create_test_client ( app = self . app , db_path = db_path , ) as client : assert client . loom_server . settings_path == settings_path assert client . loom_server . settings == default_settings if supports_full_direction_control : assert client . loom_server . settings . direction_control is DirectionControlEnum . FULL else : assert client . loom_server . settings . direction_control is not DirectionControlEnum . FULL # Test some valid settings files. if supports_full_direction_control : good_direction_control = DirectionControlEnum . FULL else : good_direction_control = ( DirectionControlEnum . LOOM if default_settings . direction_control is DirectionControlEnum . SOFTWARE else DirectionControlEnum . SOFTWARE ) for good_settings_dict in ( dict ( loom_name = \"a name\" , direction_control = good_direction_control , end1_on_right = False , thread_group_size = 1 , thread_back_to_front = False , thread_right_to_left = True , extra_key = 14 , ), dict ( loom_name = \"\" , direction_control = good_direction_control , end1_on_right = True , thread_group_size = MAX_THREAD_GROUP_SIZE , thread_back_to_front = True , thread_right_to_left = False , different_extra_key = \"hello\" , ), ): with tempfile . TemporaryDirectory () as temp_dir : db_path = pathlib . Path ( temp_dir ) / \"loom_server_database.sqlite\" settings_path = pathlib . Path ( temp_dir ) / SETTINGS_FILE_NAME with settings_path . open ( \"w\" ) as f : json . dump ( good_settings_dict , f ) with self . create_test_client ( app = self . app , db_path = db_path , ) as client : for key , value in good_settings_dict . items (): if \"extra\" in key : assert not hasattr ( client . loom_server . settings , key ) else : assert getattr ( client . loom_server . settings , key ) == value def test_upload ( self ) -> None : docs \"\"\"Test the upload command.\"\"\" with self . create_test_client ( app = self . app , upload_patterns = ALL_PATTERN_PATHS , ) as _ : pass # Test uploading a pattern file with too many shafts filename = \"eighteen shaft liftplan.wif\" filepath = TEST_DATA_FILES / filename with self . create_test_client ( app = self . app , num_shafts = 16 , ) as client : client . upload_pattern ( filepath = filepath , expected_names = [ \"\" ], should_fail = True ) def test_weave_direction ( self ) -> None : docs \"\"\"Test changing the weave direction.\"\"\" pattern_name = ALL_PATTERN_PATHS [ 1 ] . name with self . create_test_client ( app = self . app , upload_patterns = ALL_PATTERN_PATHS [ 0 : 4 ], ) as client : if not client . loom_server . enable_software_direction : raise pytest . skip ( \"Weave direction cannot be controlled by software\" ) client . select_pattern ( pattern_name = pattern_name ) for forward in ( False , True ): replies = client . send_command ( dict ( type = \"direction\" , forward = forward )) assert len ( replies ) == 2 # noqa: PLR2004 assert replies [ 0 ][ \"type\" ] == \"Direction\" assert replies [ 0 ][ \"forward\" ] == forward @classmethod @contextlib . contextmanager def create_test_client ( docs cls , * , app : FastAPI | None , num_shafts : int = 24 , read_initial_state : bool = True , upload_patterns : Iterable [ pathlib . Path ] = (), reset_db : bool = False , db_path : pathlib . Path | str | None = None , expected_status_messages : Iterable [ str ] = (), expected_pattern_names : Iterable [ str ] = (), expected_current_pattern : ReducedPattern | None = None , ) -> Generator [ Client ]: \"\"\"Create a test client fixture. Args: app: Server application to test. If None, raise an error. num_shafts: The number of shafts that the loom has. read_initial_state: If true, read and check the initial server replies from the websocket. This is the most common case. upload_patterns: Initial patterns to upload, if any. reset_db: Specify argument `--reset-db`? If False, you should also specify `expected_pattern_names` db_path: `--db-path` argument value. If None, use a temp file. If not None and you expect the database to contain any patterns, then also specify `expected_pattern_names` and `expected_current_pattern`. expected_status_messages: Expected status messages when the connection is made, in order. All should have severity level INFO. expected_pattern_names: Expected pattern names, in order. Specify if and only if `db_path` is not None and you expect the database to contain these patterns. expected_current_pattern: Expected_current_pattern. Specify if and only if `db_path` is not None and you expect the database to contain any patterns. \"\"\" expected_pattern_names = list ( expected_pattern_names ) expected_status_messages = list ( expected_status_messages ) if app is None : raise AssertionError ( \"app is None but must be a FastAPI; you must set the app class property in your subclass\" ) with tempfile . TemporaryDirectory () as temp_dir : if db_path is None : db_path = pathlib . Path ( temp_dir ) / \"loom_server_database.sqlite\" argv = [ \"testutils\" , str ( num_shafts ), \"mock\" , \"--verbose\" , * cls . extra_args ] if reset_db : argv . append ( \"--reset-db\" ) argv += [ \"--db-path\" , str ( db_path )] sys . argv = argv with ( TestClient ( app ) as test_client , test_client . websocket_connect ( \"/ws\" ) as websocket , ): loom_server : BaseLoomServer = ( test_client . app . state . loom_server # type: ignore[attr-defined] ) assert loom_server . mock_loom is not None assert loom_server . loom_info . num_shafts == num_shafts client = Client ( test_client = test_client , websocket = websocket , loom_server = loom_server , mock_loom = loom_server . mock_loom , ) if read_initial_state : seen_types : set [ str ] = set () expected_types = { \"JumpEndNumber\" , \"JumpPickNumber\" , \"LanguageNames\" , \"LoomConnectionState\" , \"LoomInfo\" , \"Mode\" , \"PatternNames\" , \"Settings\" , \"ShaftState\" , \"Direction\" , } if expected_status_messages : expected_types |= { \"StatusMessage\" } if expected_current_pattern : expected_types |= { \"CurrentPickNumber\" , \"CurrentEndNumber\" , \"ReducedPattern\" , \"SeparateWeavingRepeats\" , \"SeparateThreadingRepeats\" , \"ThreadGroupSize\" , } good_connection_states = { ConnectionStateEnum . CONNECTING , ConnectionStateEnum . CONNECTED , } while True : reply_dict = client . receive_dict () reply = SimpleNamespace ( ** reply_dict ) num_status_messages_seen = 0 match reply . type : case \"CurrentEndNumber\" : assert expected_current_pattern is not None assert reply . end_number0 == expected_current_pattern . end_number0 assert reply . end_number1 == expected_current_pattern . end_number1 assert reply . end_repeat_number == expected_current_pattern . end_repeat_number assert reply . total_end_number0 == compute_total_num ( num_within = expected_current_pattern . end_number0 , repeat_number = expected_current_pattern . end_repeat_number , repeat_len = expected_current_pattern . num_ends , ) assert reply . total_end_number1 == compute_total_num ( num_within = expected_current_pattern . end_number1 , repeat_number = expected_current_pattern . end_repeat_number , repeat_len = expected_current_pattern . num_ends , ) case \"CurrentPickNumber\" : assert expected_current_pattern is not None assert reply . pick_number == expected_current_pattern . pick_number assert reply . pick_repeat_number == expected_current_pattern . pick_repeat_number assert reply . total_pick_number == compute_total_num ( num_within = expected_current_pattern . pick_number , repeat_number = expected_current_pattern . pick_repeat_number , repeat_len = len ( expected_current_pattern . picks ), ) case \"JumpEndNumber\" : for field_name , value in vars ( reply ) . items (): if field_name == \"type\" : continue assert value is None case \"JumpPickNumber\" : for field_name , value in vars ( reply ) . items (): if field_name == \"type\" : continue assert value is None case \"LanguageNames\" : assert \"English\" in reply . languages case \"LoomConnectionState\" : if reply . state not in good_connection_states : raise AssertionError ( f \"Unexpected state in { reply =} ; should be in { good_connection_states } \" ) elif reply . state != ConnectionStateEnum . CONNECTED : continue case \"LoomInfo\" : assert vars ( reply ) == dataclasses . asdict ( loom_server . loom_info ) case \"Mode\" : assert reply . mode == ModeEnum . WEAVE case \"PatternNames\" : assert reply . names == expected_pattern_names case \"ReducedPattern\" : if not expected_pattern_names : raise AssertionError ( f \"Unexpected message type { reply . type } \" \"because expected_current_pattern is None\" ) assert reply . name == expected_pattern_names [ - 1 ] case \"SeparateThreadingRepeats\" : assert expected_current_pattern is not None assert reply . separate == expected_current_pattern . separate_threading_repeats case \"SeparateWeavingRepeats\" : assert expected_current_pattern is not None assert reply . separate == expected_current_pattern . separate_weaving_repeats case \"Settings\" : assert vars ( reply ) == dataclasses . asdict ( loom_server . settings ) case \"ShaftState\" : assert reply . state == ShaftStateEnum . DONE assert reply . shaft_word == 0 case \"StatusMessage\" : num_status_messages_seen += 1 assert reply . message == expected_status_messages [ num_status_messages_seen - 1 ] assert reply . severity == MessageSeverityEnum . INFO case \"ThreadGroupSize\" : assert expected_current_pattern is not None assert reply . group_size == expected_current_pattern . thread_group_size case \"Direction\" : assert reply . forward case _ : raise AssertionError ( f \"Unexpected message type { reply . type } \" ) seen_types . add ( reply . type ) if seen_types == expected_types and num_status_messages_seen == len ( expected_status_messages ): break expected_names : list [ str ] = [] for filepath in upload_patterns : expected_names . append ( filepath . name ) client . upload_pattern ( filepath = filepath , expected_names = expected_names , ) yield client","title":"base_loom_server.testutils"},{"location":"api/base_loom_server/translations/","text":"base_loom_server.translations source module base_loom_server.translations Functions get_language_names \u2014 Get a list of all language files found in LOCALE_FILES. get_default_dict \u2014 Get the default translation dict. get_translation_dict \u2014 Get the translation dict for the specified language. read_one_translation_file \u2014 Read and parse one language translation file. source get_language_names ( ) \u2192 list[str] Get a list of all language files found in LOCALE_FILES. Add \"English\" and omit \"default.json\". source get_default_dict ( ) \u2192 dict[str, str] Get the default translation dict. The data in the file is mostly a dict of word or phrase : context where context is a hint to people doing the translation. For those items the returned data is word or phrase : word or phrase (the context is ignored). For keys in the METADATA_KEYS, the data is copied directly. source get_translation_dict ( language : str , logger : logging . Logger | None = None , dir_ : Traversable = LOCALE_FILES ) \u2192 dict[str, str] Get the translation dict for the specified language. Parameters language : str \u2014 Name of one of the available language files, or \"English\" for English. Must not be \"\" or \"default\". logger : logging . Logger | None \u2014 Logger, which is created if None. dir_ : Traversable \u2014 Directory containing the non-default translation files. Use the default value except in unit tests. Raises FileNotFoundError \u2014 If a file is not found. RecursionError \u2014 If a circular \"_extends\" reference is found. RuntimeError source read_one_translation_file ( translation_file : Traversable , valid_keys : set[str] | KeysView , logger : logging . Logger ) \u2192 dict[str, str] Read and parse one language translation file. Parameters translation_file : Traversable \u2014 Path to translation file. valid_keys : set[str] | KeysView \u2014 Keys that are allowed in the translation dict. Invalid keys are purged with a logged warning. logger : logging . Logger \u2014 Logger. Returns The translation dict \u2014 a dict of English word or phrase: translation. Raises FileNotFoundError \u2014 If the file is not found.","title":"base_loom_server.translations"},{"location":"src/base_loom_server/translations/","text":"base_loom_server.translations docs module base_loom_server.translations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 import importlib.resources import json import logging from collections.abc import KeysView from importlib.resources.abc import Traversable PKG_FILES = importlib . resources . files ( \"base_loom_server\" ) LOCALE_FILES = PKG_FILES . joinpath ( \"locales\" ) # Translation keys that provide metadata instead of phrases to translate. METADATA_KEYS = { \"_direction\" , \"_extends\" , \"_language_code\" } def get_language_names () -> list [ str ]: docs \"\"\"Get a list of all language files found in LOCALE_FILES. Add \"English\" and omit \"default.json\". \"\"\" filenames = [ filepath . stem for filepath in LOCALE_FILES . glob ( \"*.json\" ) # type: ignore[attr-defined] if filepath . stem != \"default\" ] return [ \"English\" , * sorted ( filenames )] def get_default_dict () -> dict [ str , str ]: docs \"\"\"Get the default translation dict. The data in the file is mostly a dict of `word or phrase`: `context` where context is a hint to people doing the translation. For those items the returned data is `word or phrase`: `word or phrase` (the context is ignored). For keys in the METADATA_KEYS, the data is copied directly. \"\"\" default_dict = json . loads ( LOCALE_FILES . joinpath ( \"default.json\" ) . read_text ( encoding = \"utf_8\" )) translation_dict = { key : key for key in default_dict if key not in METADATA_KEYS } for key in METADATA_KEYS : translation_dict [ key ] = default_dict [ key ] return translation_dict def get_translation_dict ( docs language : str , logger : logging . Logger | None = None , dir_ : Traversable = LOCALE_FILES , ) -> dict [ str , str ]: \"\"\"Get the translation dict for the specified language. Args: language: Name of one of the available language files, or \"English\" for English. Must not be \"\" or \"default\". logger: Logger, which is created if None. dir_: Directory containing the non-default translation files. Use the default value except in unit tests. Raises: FileNotFoundError: If a file is not found. RecursionError: If a circular \"_extends\" reference is found. \"\"\" if language in ( \"\" , \"default\" ): raise RuntimeError ( f \"Invalid value for { language =} \" ) if logger is None : logger = logging . getLogger () translation_dict = get_default_dict () valid_keys = set ( translation_dict . keys ()) # Keep track of the language files read, in order to # prevent infinite recursion caused by translation dicts # extending each other in a circular fashion. languages_read : set [ str ] = set () dict_list : list [ dict [ str , str ]] = [] next_language = language while next_language not in { \"\" , \"default\" , \"English\" }: if next_language in languages_read : raise RecursionError ( f \"Circular reference for { language =} , found reading { next_language =} \" ) next_file = dir_ . joinpath ( f \" { next_language } .json\" ) next_dict = read_one_translation_file ( translation_file = next_file , valid_keys = valid_keys , logger = logger ) dict_list . append ( next_dict ) languages_read . add ( next_language ) next_language = next_dict . get ( \"_extends\" , \"\" ) # Apply the dicts in the correct order: # default dict is overridden by last dependency (the last _extends # in the chain), and so on up the (usually short) chain of dependencies. for next_dict in reversed ( dict_list ): translation_dict . update ( next_dict ) return translation_dict def read_one_translation_file ( docs translation_file : Traversable , valid_keys : set [ str ] | KeysView , logger : logging . Logger , ) -> dict [ str , str ]: \"\"\"Read and parse one language translation file. Args: translation_file: Path to translation file. valid_keys: Keys that are allowed in the translation dict. Invalid keys are purged with a logged warning. logger: Logger. Returns: The translation dict: a dict of English word or phrase: translation. Raises: FileNotFoundError: If the file is not found. \"\"\" if not translation_file . is_file (): raise FileNotFoundError ( f \"Translation file { translation_file } not found\" ) logger . info ( f \"Loading translation file { translation_file } \" ) raw_translation_dict = json . loads ( translation_file . read_text ( encoding = \"utf_8\" )) translation_dict = { key : value for key , value in raw_translation_dict . items () if key in valid_keys } extra_keys = raw_translation_dict . keys () - translation_dict . keys () if extra_keys : extra_keys_str = \", \" . join ( sorted ( extra_keys )) logger . warning ( f \"Ignoring invalid keys in { translation_file } : { extra_keys_str } \" ) return translation_dict","title":"base_loom_server.translations"},{"location":"api/base_loom_server/utils/","text":"base_loom_server.utils source module base_loom_server.utils Functions compute_num_within_and_repeats \u2014 Compute num_within and repeat_number from total_num and repeat_len such that total_num = (repeat_number - 1) * repeat_len + num_within. compute_total_num \u2014 Compute total_num from num_within, repeat_number, and repeat_len. source compute_num_within_and_repeats ( total_num : int , repeat_len : int ) \u2192 tuple[int, int] Compute num_within and repeat_number from total_num and repeat_len such that total_num = (repeat_number - 1) * repeat_len + num_within. Parameters total_num : int \u2014 Total count (e.g. picks or ends). repeat_len : int \u2014 Number of counts in one repeat; must be positive. Returns A tuple consisting of \u2014 num_within: Number of counts in range [1, repeat_len], or 0 if total_num == 0 repeat_num: 1 + number of full repeats (the first repeat has value 1) Raises ValueError \u2014 If repeat_len \u2264 0. Notes If total_num is 0 return (0, 0) because that is the most sensible thing to show when we haven't started weaving or threading. Otherwise, if total_num is exactly N repeats of repeat_len, return (repeat_len, N) rather than (0, N+1), because I want to display a pick or end that is in the pattern, rather than the mythical pick or repeat 0. source compute_total_num ( num_within : int , repeat_number : int , repeat_len : int ) \u2192 int Compute total_num from num_within, repeat_number, and repeat_len. This is basically the opposite of divmod, but handles None inputs and repeat_number is 1-based. Parameters num_within : int \u2014 A value in range [-repeat_len, repeat_len]. repeat_number : int \u2014 1 + number of full repeats. repeat_len : int \u2014 Length of one repeat; must be positive or None. Returns int \u2014 total_num = repeat_len * (repeat_number - 1) + num_within Raises ValueError","title":"base_loom_server.utils"},{"location":"src/base_loom_server/utils/","text":"base_loom_server.utils docs module base_loom_server.utils 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def compute_num_within_and_repeats ( total_num : int , repeat_len : int ) -> tuple [ int , int ]: docs \"\"\"Compute num_within and repeat_number from total_num and repeat_len such that total_num = (repeat_number - 1) * repeat_len + num_within. Args: total_num: Total count (e.g. picks or ends). repeat_len: Number of counts in one repeat; must be positive. Returns: A tuple consisting of: * num_within: Number of counts in range [1, repeat_len], or 0 if total_num == 0 * repeat_num: 1 + number of full repeats (the first repeat has value 1) Raises: ValueError: If `repeat_len` \u2264 0. Notes: If total_num is 0 return (0, 0) because that is the most sensible thing to show when we haven't started weaving or threading. Otherwise, if total_num is exactly N repeats of repeat_len, return (repeat_len, N) rather than (0, N+1), because I want to display a pick or end that is in the pattern, rather than the mythical pick or repeat 0. \"\"\" if repeat_len <= 0 : raise ValueError ( f \" { repeat_len =} must be positive (or None)\" ) zero_based_repeat_number , num_within = divmod ( total_num , repeat_len ) if num_within == 0 and total_num != 0 : # Avoid num_within 0 unless total_num is also 0 num_within = repeat_len zero_based_repeat_number -= 1 return ( num_within , zero_based_repeat_number + 1 ) docs def compute_total_num ( num_within : int , repeat_number : int , repeat_len : int ) -> int : \"\"\"Compute total_num from num_within, repeat_number, and repeat_len. This is basically the opposite of divmod, but handles None inputs and repeat_number is 1-based. Args: num_within: A value in range [-repeat_len, repeat_len]. repeat_number: 1 + number of full repeats. repeat_len: Length of one repeat; must be positive or None. Returns: total_num = repeat_len * (repeat_number - 1) + num_within \"\"\" if repeat_len <= 0 : raise ValueError ( f \" { repeat_len =} must be positive (or None)\" ) return repeat_len * ( repeat_number - 1 ) + num_within","title":"base_loom_server.utils"},{"location":"api/base_loom_server/version/","text":"base_loom_server.version source module base_loom_server.version","title":"base_loom_server.version"},{"location":"src/base_loom_server/version/","text":"base_loom_server.version docs module base_loom_server.version 1 2 3 # Generated by setuptools_scm __all__ = [ \"__version__\" ] __version__ = \"0.27\"","title":"base_loom_server.version"}]}