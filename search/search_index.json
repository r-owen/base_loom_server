{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Loom Server A loom server is a package based on base_loom_server that allows you to control a dobby loom from a web browser (e.g. on a phone or tablet). Two examples are seguin_loom_server and toika_loom_server . This document explains how to use any of these loom servers (though there may be a few loom-specific differences that are described in that package's documentation). The first step is to install the software. Once you have done that, read on: Connect to the Loom Server Connect to the loom server using any modern web browser (e.g. on a phone, tablet, or laptop). The address will be http://*hostname*.local:8000 where hostname is the host name of the loom server computer, as determined in Installing . Select the Mode The server has three modes, which are listed at the top of the web page: Weaving, Threading, and Settings: Weaving is used to weave fabric; this is by far the most common mode. Threading will help you thread the loom, by lifting shafts for groups of threads. Settings allows you specify a few settings that the server remembers. ( Threading also has two settings that allow you to specify how you prefer to thread.) Click on the word to select that mode. The bold word shows the current mode. The links above give detailed instructions for using each mode. But before you dive into that, read the next section about pattern files: Upload and Select Pattern Files Before you can weave or thread, you must upload one or more pattern files to the loom server. The server accepts WIF (.wif), Fiberworks (.dtx), and WeavePoint (.wpo) files. There are two ways to upload files: Push the \"Upload\" button. Drag and drop the files onto the web page (making sure the web page is gray before dropping them). Once you have uploaded patterns, you can select one using the menu labeled \"Pattern\" (next to the \"Upload\" button). The loom server remembers the 25 most recent patterns that you have uploaded, and this information is saved on disk, so should not be lost in a power failure. The saved information includes the most recent pick (weaving) and the most recent warp thread group (threading). This allows you to switch between different patterns while weaving something. However, if you upload a new pattern with the same file name as a saved pattern, the new pattern overwrites the old and the pick and warp thread group information is reset. So please be careful. To clear out the pattern menu (which may become cluttered over time), select \"Clear Recents\", the last item in the pattern menu. This clears out information for all patterns except the current pattern. You can also restart the loom server with the --reset-db command-line argument. This can be useful if upgrading to a new version of the loom software that has an incompatible database format. Multiple Connections The server only allows one web browser to connect, and the most recent connection wins. This prevents a mystery connection from hogging the loom. If the connection is dropped on the device you want to use for weaving, simply reload the page to regain the connection. Reset the Loom Connection Every time you connected to the web server or reload the page, the server refreshes its connection to the loom (by disconnecting and immediately reconnecting). So if the server is reporting a problem with its connection to the loom, and it is not due to the loom losing power, or a disconnected or bad USB cable, you might try reloading the page. If the loom seems confused, try turning off the loom, waiting a few seconds, then turning it on again. Then reload the web page, to force the web server to make a new connection to the loom.","title":"Home"},{"location":"#loom-server","text":"A loom server is a package based on base_loom_server that allows you to control a dobby loom from a web browser (e.g. on a phone or tablet). Two examples are seguin_loom_server and toika_loom_server . This document explains how to use any of these loom servers (though there may be a few loom-specific differences that are described in that package's documentation). The first step is to install the software. Once you have done that, read on:","title":"Loom Server"},{"location":"#connect-to-the-loom-server","text":"Connect to the loom server using any modern web browser (e.g. on a phone, tablet, or laptop). The address will be http://*hostname*.local:8000 where hostname is the host name of the loom server computer, as determined in Installing .","title":"Connect to the Loom Server"},{"location":"#select-the-mode","text":"The server has three modes, which are listed at the top of the web page: Weaving, Threading, and Settings: Weaving is used to weave fabric; this is by far the most common mode. Threading will help you thread the loom, by lifting shafts for groups of threads. Settings allows you specify a few settings that the server remembers. ( Threading also has two settings that allow you to specify how you prefer to thread.) Click on the word to select that mode. The bold word shows the current mode. The links above give detailed instructions for using each mode. But before you dive into that, read the next section about pattern files:","title":"Select the Mode"},{"location":"#upload-and-select-pattern-files","text":"Before you can weave or thread, you must upload one or more pattern files to the loom server. The server accepts WIF (.wif), Fiberworks (.dtx), and WeavePoint (.wpo) files. There are two ways to upload files: Push the \"Upload\" button. Drag and drop the files onto the web page (making sure the web page is gray before dropping them). Once you have uploaded patterns, you can select one using the menu labeled \"Pattern\" (next to the \"Upload\" button). The loom server remembers the 25 most recent patterns that you have uploaded, and this information is saved on disk, so should not be lost in a power failure. The saved information includes the most recent pick (weaving) and the most recent warp thread group (threading). This allows you to switch between different patterns while weaving something. However, if you upload a new pattern with the same file name as a saved pattern, the new pattern overwrites the old and the pick and warp thread group information is reset. So please be careful. To clear out the pattern menu (which may become cluttered over time), select \"Clear Recents\", the last item in the pattern menu. This clears out information for all patterns except the current pattern. You can also restart the loom server with the --reset-db command-line argument. This can be useful if upgrading to a new version of the loom software that has an incompatible database format.","title":"Upload and Select Pattern Files"},{"location":"#multiple-connections","text":"The server only allows one web browser to connect, and the most recent connection wins. This prevents a mystery connection from hogging the loom. If the connection is dropped on the device you want to use for weaving, simply reload the page to regain the connection.","title":"Multiple Connections"},{"location":"#reset-the-loom-connection","text":"Every time you connected to the web server or reload the page, the server refreshes its connection to the loom (by disconnecting and immediately reconnecting). So if the server is reporting a problem with its connection to the loom, and it is not due to the loom losing power, or a disconnected or bad USB cable, you might try reloading the page. If the loom seems confused, try turning off the loom, waiting a few seconds, then turning it on again. Then reload the web page, to force the web server to make a new connection to the loom.","title":"Reset the Loom Connection"},{"location":"coding/","text":"Coding Installing Source Code Install Python as explained in Installing . Download the source code from github , or make a fork and git clone that. Inside the directory, do the following: Make \"editable installation\" of the package. An editable installation runs from the source code, so changes you make to the source are used when you run or test the code, without the need to reinstall the package: pip install -e .'[dev]' where the single quotes around [dev] are required in zsh, but not in bash. '[dev]' installs development-related packages such as pytest (see the file pyproject.toml for the full list). Activate the pre-commit hooks: pre-commit install Run unit tests to test your installation: pytest You may run an example loom server with: run_example_loom <num_shafts> mock Please only specify the mock serial port; connecting it to a real loom will not work ( ExampleMockLoom is loosely based on a S\u00e9guin loom, but is not compatible). run_example_loom <num_shafts> mock also accepts these command-line arguments: * `--reset-db` Reset the pattern database. Try this if you think the database is corrupted. * `--verbose` Print more diagnostic information. Note that the example loom server uses the same pattern database as seguin_loom_server and toika_loom_server . To run mypy run: MYPYPATH=src mypy . This avoids complaints about module name ambiguity. In mock mode the web page shows a few extra controls for debugging. Warning: the web server's automatic reload feature, which reloads Python code whenever you save changes, does not work with this software. Instead you have to kill the web server by typing control-C several times, until you get a terminal prompt, then run the server again. This may be a bug in uvicorn; see this discussion for more information. Writing a Loom Server Install the base_loom_server package either using pip, or from source (as described above). Source makes it easier to look through the code. Write a subclass of BaseMockLoom that emulates your loom. Two examples are ExampleMockLoom in this package and MockLoom in toika_loom_server . Write a subclass of BaseLoomServer that talks to the loom. Two examples are ExampleLoomServer in this package and LoomServer in toika_loom_server . Write a main.py like the one in this package, to run your loom server. Copy tests/test_mock_loom.py and modify it to suit your mock loom. The unit tests for your loom server should be able to use testutils.BaseTestLoomServer , as tests/test_loom_server.py does. Write a pyproject.toml like the one for toika_loom_server .","title":"Coding"},{"location":"coding/#coding","text":"","title":"Coding"},{"location":"coding/#installing-source-code","text":"Install Python as explained in Installing . Download the source code from github , or make a fork and git clone that. Inside the directory, do the following: Make \"editable installation\" of the package. An editable installation runs from the source code, so changes you make to the source are used when you run or test the code, without the need to reinstall the package: pip install -e .'[dev]' where the single quotes around [dev] are required in zsh, but not in bash. '[dev]' installs development-related packages such as pytest (see the file pyproject.toml for the full list). Activate the pre-commit hooks: pre-commit install Run unit tests to test your installation: pytest You may run an example loom server with: run_example_loom <num_shafts> mock Please only specify the mock serial port; connecting it to a real loom will not work ( ExampleMockLoom is loosely based on a S\u00e9guin loom, but is not compatible). run_example_loom <num_shafts> mock also accepts these command-line arguments: * `--reset-db` Reset the pattern database. Try this if you think the database is corrupted. * `--verbose` Print more diagnostic information. Note that the example loom server uses the same pattern database as seguin_loom_server and toika_loom_server . To run mypy run: MYPYPATH=src mypy . This avoids complaints about module name ambiguity. In mock mode the web page shows a few extra controls for debugging. Warning: the web server's automatic reload feature, which reloads Python code whenever you save changes, does not work with this software. Instead you have to kill the web server by typing control-C several times, until you get a terminal prompt, then run the server again. This may be a bug in uvicorn; see this discussion for more information.","title":"Installing Source Code"},{"location":"coding/#writing-a-loom-server","text":"Install the base_loom_server package either using pip, or from source (as described above). Source makes it easier to look through the code. Write a subclass of BaseMockLoom that emulates your loom. Two examples are ExampleMockLoom in this package and MockLoom in toika_loom_server . Write a subclass of BaseLoomServer that talks to the loom. Two examples are ExampleLoomServer in this package and LoomServer in toika_loom_server . Write a main.py like the one in this package, to run your loom server. Copy tests/test_mock_loom.py and modify it to suit your mock loom. The unit tests for your loom server should be able to use testutils.BaseTestLoomServer , as tests/test_loom_server.py does. Write a pyproject.toml like the one for toika_loom_server .","title":"Writing a Loom Server"},{"location":"installing/","text":"Installing This page gives instructions for installing a loom driver such as such as seguin_loom_server or toika_loom_server that is based on base_loom_server . See Coding if you want to work on base_loom_server or use it to develop a new loom driver. Pick your Computer Decide which computer you will use to run the loom server. Any macOS, Windows, or linux computer will work. The software uses minimal resources, so an old, slow computer is fine. A Raspberry Pi (model 4 or better) will work, but will be a bit slow when uploading patterns. A used Mac Mini is a great choice if you have a spare keyboard and monitor to get it set up. (You may also run your web browser on the same computer. This avoids the need for wifi, but may make it harder to put the display where it can easily be seen.) Install Python 3.11 or later. The link has installers for common operating systems. If you have a Raspberry Pi and the version of Python is too old, try sudo apt update followed by sodu apt upgrade python3 . If that doesn't work, you may need to build Python from source or install a newer version of the Raspberry Pi operating system. If you are a Python programmer and know what a virtual environment is, I suggest you set up a virtual environment for the loom server. Otherwise don't bother. Determine your computer's host name. In a terminal run: hostname Determine the name of the port that your computer is using to connect to the loom. The first step is to make sure the loom is not connected (unplug the USB cable or turn off the loom). The next step depends on the operating system: On macOS or linux: Run this terminal command to see which USB ports are already in use, if any: ls /dev | grep -i \"tty.*usb.*\" Connect your computer to the loom with a USB cable, turn on the loom, and wait a few seconds to let it connect. Run the same command again. There should be one new entry, which is the name of the port connected to the loom. If not, wait a bit longer and try again. On Windows this may work: Open \"Device Manager\" Expand the \"Universal Serial Bus controllers\" section. Connect your computer to the loom with a USB cable, turn on the loom, and wait a few seconds to let it connect. Check for the new connection by clicking \"Action\" > \"Scan for hardware changes\". Install the loom server software. From here on I will assume you are installing toika_loom_server . For seguin_loom_server replace \"toika\" with \"seguin\". On the command line: python -m pip install toika_loom_server Use sudo on Raspberry Pi to avoid having to hunt for the loom server executable in ~/.local/bin : sudo python -m pip install toika_loom_server In either case, watch pip's output. Near the end it should tell you where it installed run_toika_loom . Find the installed loom server executable: On macOS, Raspberry Pi (if you installed with sudo ) and most unix you can probably run the executable directly: run_toika_loom <num_shafts> mock where is the number of shafts you wish the mock loom to have. If that does not work, look at pip's output to see where it was installed. On Raspberry Pi if you did not install with sudo then it is probably here (if not, look at pip's output): ~/.local/bin/run_toika_loom <num_shafts> mock On Windows the executable will probably be buried in the Scripts subdirectory of your python installation. Again, pip's output should tell you where. If the path to the executable is long or hard to remember, consider adding the directory containing the executable to your \"PATH\", or in the case of macOS or unix, making an alias (a short word that will run the command). On macOS and unix you do this by editing a shell configuration file, which you can read about online. Here are instructions for Windows 10 . Test the loom server with the mock port: Once you have found and started the server, as above, make sure you can connect to it. Point your web browser to https://hostname.local/8000 where hostname is the host name you determined above (if the hostname ends with \".local\", don't duplicate that). Try a few things: Load one or a few weaving pattern files (which will still be there when you run with the real loom). When using the mock loom there are extra debug controls shown at the bottom of the page. One of those is a button that lets you advance to the next pick. Try that. Try changing weave direction. Try the threading panel. If you plan to weave any of the patterns you uploaded, go to the beginning before you disconnect, because the pattern database remembers where you left off weaving and threading. Run the loom server. Once you know how to run the loom server, run it with the real USB port for your loom. On macOS or unix: run_toika_loom <num_shafts> <usb_port_name> or, if it is not on the PATH: <path-to-executable>/run_toika_loom <num_shafts> <usb_port_name> On Windows: run_toika_loom.exe <num_shafts> <usb_port_name> or, if it is not on the PATH: <path-to-executable>/run_toika_loom.exe <num_shafts> <usb_port_name> is the number of shafts your loom has. This is used in two ways: Pattern files that have too many shafts are rejected. The data format used by Toika ES dobby heads varies depending on the number of shafts. If you specify the wrong value, the loom will not work correctly. The run command accepts additional options to specify the loom name, server port, etc. One option of note: --reset-db : clear all save weaving patterns. Only use this when you want a fresh start. To run more than one loom server on the same computer, specify loom-specific values for each of the following options: --db-path : path of the pattern database --port : server port For a full list of options, run the command with option --help . To upgrade to a newer version of one or more packages: python -m pip install --upgrade dtx_to_wif base_loom_server toika_loom_server (omit any packages you do not wish to upgrade). You can also specify specific versions; seee pip's documentation for details.","title":"Installing"},{"location":"installing/#installing","text":"This page gives instructions for installing a loom driver such as such as seguin_loom_server or toika_loom_server that is based on base_loom_server . See Coding if you want to work on base_loom_server or use it to develop a new loom driver. Pick your Computer Decide which computer you will use to run the loom server. Any macOS, Windows, or linux computer will work. The software uses minimal resources, so an old, slow computer is fine. A Raspberry Pi (model 4 or better) will work, but will be a bit slow when uploading patterns. A used Mac Mini is a great choice if you have a spare keyboard and monitor to get it set up. (You may also run your web browser on the same computer. This avoids the need for wifi, but may make it harder to put the display where it can easily be seen.) Install Python 3.11 or later. The link has installers for common operating systems. If you have a Raspberry Pi and the version of Python is too old, try sudo apt update followed by sodu apt upgrade python3 . If that doesn't work, you may need to build Python from source or install a newer version of the Raspberry Pi operating system. If you are a Python programmer and know what a virtual environment is, I suggest you set up a virtual environment for the loom server. Otherwise don't bother. Determine your computer's host name. In a terminal run: hostname Determine the name of the port that your computer is using to connect to the loom. The first step is to make sure the loom is not connected (unplug the USB cable or turn off the loom). The next step depends on the operating system: On macOS or linux: Run this terminal command to see which USB ports are already in use, if any: ls /dev | grep -i \"tty.*usb.*\" Connect your computer to the loom with a USB cable, turn on the loom, and wait a few seconds to let it connect. Run the same command again. There should be one new entry, which is the name of the port connected to the loom. If not, wait a bit longer and try again. On Windows this may work: Open \"Device Manager\" Expand the \"Universal Serial Bus controllers\" section. Connect your computer to the loom with a USB cable, turn on the loom, and wait a few seconds to let it connect. Check for the new connection by clicking \"Action\" > \"Scan for hardware changes\". Install the loom server software. From here on I will assume you are installing toika_loom_server . For seguin_loom_server replace \"toika\" with \"seguin\". On the command line: python -m pip install toika_loom_server Use sudo on Raspberry Pi to avoid having to hunt for the loom server executable in ~/.local/bin : sudo python -m pip install toika_loom_server In either case, watch pip's output. Near the end it should tell you where it installed run_toika_loom . Find the installed loom server executable: On macOS, Raspberry Pi (if you installed with sudo ) and most unix you can probably run the executable directly: run_toika_loom <num_shafts> mock where is the number of shafts you wish the mock loom to have. If that does not work, look at pip's output to see where it was installed. On Raspberry Pi if you did not install with sudo then it is probably here (if not, look at pip's output): ~/.local/bin/run_toika_loom <num_shafts> mock On Windows the executable will probably be buried in the Scripts subdirectory of your python installation. Again, pip's output should tell you where. If the path to the executable is long or hard to remember, consider adding the directory containing the executable to your \"PATH\", or in the case of macOS or unix, making an alias (a short word that will run the command). On macOS and unix you do this by editing a shell configuration file, which you can read about online. Here are instructions for Windows 10 . Test the loom server with the mock port: Once you have found and started the server, as above, make sure you can connect to it. Point your web browser to https://hostname.local/8000 where hostname is the host name you determined above (if the hostname ends with \".local\", don't duplicate that). Try a few things: Load one or a few weaving pattern files (which will still be there when you run with the real loom). When using the mock loom there are extra debug controls shown at the bottom of the page. One of those is a button that lets you advance to the next pick. Try that. Try changing weave direction. Try the threading panel. If you plan to weave any of the patterns you uploaded, go to the beginning before you disconnect, because the pattern database remembers where you left off weaving and threading. Run the loom server. Once you know how to run the loom server, run it with the real USB port for your loom. On macOS or unix: run_toika_loom <num_shafts> <usb_port_name> or, if it is not on the PATH: <path-to-executable>/run_toika_loom <num_shafts> <usb_port_name> On Windows: run_toika_loom.exe <num_shafts> <usb_port_name> or, if it is not on the PATH: <path-to-executable>/run_toika_loom.exe <num_shafts> <usb_port_name> is the number of shafts your loom has. This is used in two ways: Pattern files that have too many shafts are rejected. The data format used by Toika ES dobby heads varies depending on the number of shafts. If you specify the wrong value, the loom will not work correctly. The run command accepts additional options to specify the loom name, server port, etc. One option of note: --reset-db : clear all save weaving patterns. Only use this when you want a fresh start. To run more than one loom server on the same computer, specify loom-specific values for each of the following options: --db-path : path of the pattern database --port : server port For a full list of options, run the command with option --help . To upgrade to a newer version of one or more packages: python -m pip install --upgrade dtx_to_wif base_loom_server toika_loom_server (omit any packages you do not wish to upgrade). You can also specify specific versions; seee pip's documentation for details.","title":"Installing"},{"location":"settings/","text":"Settings This panel offers a few settings that you can change which apply to all weaving patterns. Settings are automatically saved, and should survive rebooting the loom server. These include: Loom name : the name of the loom, as it appears in the display. Direction control : specifies how to change direction (weaving or unweaving, threading or unthreading). See Weave Direction for more information. This setting is not shown for S\u00e9guin looms and others that support changing direction from both software and a button on the loom. Threading : Specify whether you prefer to thread right-to-left or left-to-right, and front-to-back or back-to-front. Specifying front-to-back simply changes the threading display to appear as if you are sitting behind the castle: shaft 1 is displayed on the left and shaft 1 on the top. Default threading group size : specify the default threading group size. This setting only applies when you load pattern files. It has no effect on the pattern files you have already loaded (because threading group size is saved with each pattern file).","title":"Settings"},{"location":"settings/#settings","text":"This panel offers a few settings that you can change which apply to all weaving patterns. Settings are automatically saved, and should survive rebooting the loom server. These include: Loom name : the name of the loom, as it appears in the display. Direction control : specifies how to change direction (weaving or unweaving, threading or unthreading). See Weave Direction for more information. This setting is not shown for S\u00e9guin looms and others that support changing direction from both software and a button on the loom. Threading : Specify whether you prefer to thread right-to-left or left-to-right, and front-to-back or back-to-front. Specifying front-to-back simply changes the threading display to appear as if you are sitting behind the castle: shaft 1 is displayed on the left and shaft 1 on the top. Default threading group size : specify the default threading group size. This setting only applies when you load pattern files. It has no effect on the pattern files you have already loaded (because threading group size is saved with each pattern file).","title":"Settings"},{"location":"threading/","text":"Threading The threading mode helps you correctly thread warp strings through the heddles. Every time you press the pedal, the loom will raise the next group of shafts and a display will show you which threads belong on which shaft. This page assumes you have done all the basics : Connected your web browser to the loom server Uploaded at least one pattern, and selected a pattern from the pattern menu Selected the Threading mode. Threading Direction The [Settings][settings.md] panel contains several settings specific to threading. In particular, you can choose whether to thread right-to-left or left-to-right, and whether to display threading for front-to-back or back-to-front. Threading Display Threading is displayed as a picture that shows a group of threads (vertical colored bars) and the shaft they go through (numbers that interrupt the colored bars). It also shows warp end numbers above some threads. Warp end 0 is special: it has no shafts and no warp thread. It is the first pick when starting to thread a pattern. It is also an intermediate step when repeating a threading sequence, unless \"Separate repeats\" is unchecked. Special cases that may only be supported by WIF files: Ends that are threaded through heddles on more than one shaft are only shown threaded on the lowest-numbered shaft, ignoring 0. Ends that are only threaded on shaft 0 (meaning not threaded through heddles on any shaft) are displayed without a shaft number. Threading Direction See Weave Direction for information on changing between threading and unthreading. If you are using a Toika loom, you must specify whether Software or the Loom controls threading direction in Settings . If you thread front-to-back, consider specifying Software, because it may be difficult to reach the REVERSE button on the dobby head from behind the castle. Jumping You can jump to a different group of warp ends, specified by the smaller warp end number. For example if the group size is 4 and you jump to end 21, the new ends will be 21, 22, 23, 24, and 25 (or fewer, if the warp has fewer than 25 threads), regardless of the threading direction. Jumping is a two-step process: first you request the jump, then you advance to it by pressing the loom's pedal. (Two steps are necessary because most looms will not accept an unsolicited command to raise shafts.) In detail: Enter the desired warp end number in the box to the right of \"Jump to end\". The box will turn pink and the Jump button will be enabled. Press the \"return\" keyboard key or click the \"Jump\" button on the web page to send the requested jump to the server. You will see several changes: The jump input box will have a white background and the jump button will be disabled. The pattern display will show the new thread group, with a dotted box around it. Advance to the next group by pressing the loom's pedal. Until you advance to the next group, you may request a different jump (in case you got it wrong the first time) or cancel the jump. To cancel the jump you may do any of the following: Press the \"Reset\" button to the right of \"Jump\". Reload the page. Select a new pattern. Group Size The \"Group size\" menu selects how many warp ends are in a group, All shafts for a group are raised at once. You can change the group size whenever you like; the change takes effect for the next thread group (next time you push the pedal to advance). Repeating The software will automatically repeat threading if you thread beyond the end. However, like Weaving , the transition depends on the Separate repeats checkbox: \"On\" (checked): you must advance twice when you reach an end, before the next set of shafts is raised. The first advance will lower all shafts, as a signal that you have finished threading or unthreading one pattern repeat. That is the \"separator\". \"Off\" (unchecked): there is no indication that you have reached the end of threading. The next advance will start the next repeat of threading or unthreading. The default value of Separate repeats is \"on\" if the pattern has more than 20 warp threads, \"off\" otherwise. The idea behind this is that frequent separator picks are annoying for short threading sequences, but having a separator pick is useful for long sequences. Note that the value of the Weaving and Threading Separate repeats checkboxes are independent of each other, and may also be different for different patterns. They are saved in the pattern database.","title":"Threading"},{"location":"threading/#threading","text":"The threading mode helps you correctly thread warp strings through the heddles. Every time you press the pedal, the loom will raise the next group of shafts and a display will show you which threads belong on which shaft. This page assumes you have done all the basics : Connected your web browser to the loom server Uploaded at least one pattern, and selected a pattern from the pattern menu Selected the Threading mode.","title":"Threading"},{"location":"threading/#threading-direction","text":"The [Settings][settings.md] panel contains several settings specific to threading. In particular, you can choose whether to thread right-to-left or left-to-right, and whether to display threading for front-to-back or back-to-front.","title":"Threading Direction"},{"location":"threading/#threading-display","text":"Threading is displayed as a picture that shows a group of threads (vertical colored bars) and the shaft they go through (numbers that interrupt the colored bars). It also shows warp end numbers above some threads. Warp end 0 is special: it has no shafts and no warp thread. It is the first pick when starting to thread a pattern. It is also an intermediate step when repeating a threading sequence, unless \"Separate repeats\" is unchecked. Special cases that may only be supported by WIF files: Ends that are threaded through heddles on more than one shaft are only shown threaded on the lowest-numbered shaft, ignoring 0. Ends that are only threaded on shaft 0 (meaning not threaded through heddles on any shaft) are displayed without a shaft number.","title":"Threading Display"},{"location":"threading/#threading-direction_1","text":"See Weave Direction for information on changing between threading and unthreading. If you are using a Toika loom, you must specify whether Software or the Loom controls threading direction in Settings . If you thread front-to-back, consider specifying Software, because it may be difficult to reach the REVERSE button on the dobby head from behind the castle.","title":"Threading Direction"},{"location":"threading/#jumping","text":"You can jump to a different group of warp ends, specified by the smaller warp end number. For example if the group size is 4 and you jump to end 21, the new ends will be 21, 22, 23, 24, and 25 (or fewer, if the warp has fewer than 25 threads), regardless of the threading direction. Jumping is a two-step process: first you request the jump, then you advance to it by pressing the loom's pedal. (Two steps are necessary because most looms will not accept an unsolicited command to raise shafts.) In detail: Enter the desired warp end number in the box to the right of \"Jump to end\". The box will turn pink and the Jump button will be enabled. Press the \"return\" keyboard key or click the \"Jump\" button on the web page to send the requested jump to the server. You will see several changes: The jump input box will have a white background and the jump button will be disabled. The pattern display will show the new thread group, with a dotted box around it. Advance to the next group by pressing the loom's pedal. Until you advance to the next group, you may request a different jump (in case you got it wrong the first time) or cancel the jump. To cancel the jump you may do any of the following: Press the \"Reset\" button to the right of \"Jump\". Reload the page. Select a new pattern.","title":"Jumping"},{"location":"threading/#group-size","text":"The \"Group size\" menu selects how many warp ends are in a group, All shafts for a group are raised at once. You can change the group size whenever you like; the change takes effect for the next thread group (next time you push the pedal to advance).","title":"Group Size"},{"location":"threading/#repeating","text":"The software will automatically repeat threading if you thread beyond the end. However, like Weaving , the transition depends on the Separate repeats checkbox: \"On\" (checked): you must advance twice when you reach an end, before the next set of shafts is raised. The first advance will lower all shafts, as a signal that you have finished threading or unthreading one pattern repeat. That is the \"separator\". \"Off\" (unchecked): there is no indication that you have reached the end of threading. The next advance will start the next repeat of threading or unthreading. The default value of Separate repeats is \"on\" if the pattern has more than 20 warp threads, \"off\" otherwise. The idea behind this is that frequent separator picks are annoying for short threading sequences, but having a separator pick is useful for long sequences. Note that the value of the Weaving and Threading Separate repeats checkboxes are independent of each other, and may also be different for different patterns. They are saved in the pattern database.","title":"Repeating"},{"location":"translations/","text":"Translations base_loom_server supports foreign language translations (for the web display, but not this documentation). At present only one translation available: is a rather poor French translation. Help from others to add and improve language support would be most welcome. Each language is supported by a separate yaml file in src/locales . Each translation file must have name language_code .js, where language_code is a standard language code as reported by the Python locale library. Here is one list of codes . On macOS and unix you can see a list of supported locales with terminal command locale -a . The file src/locales/default.yaml lists all the words and phrases for which translations are wanted. Note that the values are ignored in this file. Other than that, the format is the same as for a language file. Thus a good way to start is to copy src/locales/default.yaml to the new language file, then replace each null with the translated string. An incomplete file is better than none; missing entries will be shown in English. It is possible to have two files for a given language: one that uses a more general language code, and the other that uses a more specific code. If you do this, the more general file is read first, then the more specific file. Thus the more specific file need only have entries that differ from the general file.","title":"Translations"},{"location":"translations/#translations","text":"base_loom_server supports foreign language translations (for the web display, but not this documentation). At present only one translation available: is a rather poor French translation. Help from others to add and improve language support would be most welcome. Each language is supported by a separate yaml file in src/locales . Each translation file must have name language_code .js, where language_code is a standard language code as reported by the Python locale library. Here is one list of codes . On macOS and unix you can see a list of supported locales with terminal command locale -a . The file src/locales/default.yaml lists all the words and phrases for which translations are wanted. Note that the values are ignored in this file. Other than that, the format is the same as for a language file. Thus a good way to start is to copy src/locales/default.yaml to the new language file, then replace each null with the translated string. An incomplete file is better than none; missing entries will be shown in English. It is possible to have two files for a given language: one that uses a more general language code, and the other that uses a more specific code. If you do this, the more general file is read first, then the more specific file. Thus the more specific file need only have entries that differ from the general file.","title":"Translations"},{"location":"version_history/","text":"Version History 0.19.3 2025-06-07 Improve the display of the tab bar at the top of the window. 0.19.2 2025-06-07 Improve the display of direction controls. 0.19.1 2025-06-04 Add missing translation strings. 0.19.0 2025-06-3 Add a new Settings panel which allows you to specify loom name, direction control, and new threading settings. Enhance threading support by adding settings for: Thread right-to-left or left-to-right. Thread back-to-front or front-to-back. The defalt threading group size for newly loaded patterns. Automatically reset the pattern database if it changes in an incompatible way. Store the pattern database and new settings file in your home directory, instead of a temporary directory, so that the files will survive a reboot. Breaking change : remove command-line arguments \"name\" and \"direction-control\". Use the new Settings panel, instead. 0.18.3 2025-05-25 Expand unit tests. 0.18.2 2025-05-03 Add API documentation. 0.18.1 2025-04-28 Show the correct threading group size when you connect. 0.18.0 2025-04-28 Improve the threading display: Center the current group, even for patterns with short threading repeats. For ends not threaded on any shaft just show the thread without a shaft number. Formerly a truncated 0 was shown. Showing a whole 0 is possible, but likely more confusing. Remove a source of flicker by only updating the visible pattern. 0.17.0 2025-04-27 Try to prevent an unwanted stale next-pick request when the loom server connects to the loom (which is when a user connects to the server). Do this by purging the read buffer. 0.16.0 2025-04-25 Display total picks in Weaving and total ends in Threading. Also jump to total picks in Weaving and total ends in Threading. 0.15.0 2025-04-19 Save threading group size with each pattern. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database. Add a version history to the documentation. 0.14.0 2025-04-18 Display improvements: Avoid scroll bars, if possible. Make font size vary somewhat with window size. Avoid the search bar and tab controls at the bottom of the iPhone. In Threading move Group size to the right of Direction, to save space. 0.13.0 2025-04-18 Display improvements: Resize the weaving and threading pattern display to fill available space. Move the direction control and (for weaving) pick color, for easier access. 0.12.1 2025-04-14 Small display improvements. 0.12.0 2025-04-03 Support WeavePoint .wpo files. Improve the display of white threads. 0.11.0 2025-04-02 Add a preliminary Finnish translation. Fix a few issues with the installation instructions (especially those related to finding the loom's USB port on unix and macOS). Thanks to Kalle Pihlajasaari for the translation and the doc bug reports. 0.10.0 2025-03-18 Add a Separate repeats checkbox to Weaving and Threading to control whether to include a separator pick (all shafts down) between repeats of weaving or threading. The weaving and threading values are independent of each other, and are saved per pattern in the database. The intial value for weaving/threading is \"on\" if the number of picks/ends > 20, else \"off\". The idea being that the extra advance is helpful for long sequenced, but annoying for short sequences. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database. 0.9.1 2025-03-18 Display loom name and # shafts. Improve error handling if a pattern file cannot be parsed. 0.9.0 2025-03-14 Add required command-line argument num_shafts. This is needed in order for toika_loom_server to work correctly. 0.8.1 2025-03-05 Improve the fix for the Windows encoding issue. 0.8.0 2025-03-05 Work around an encoding issue on Windows. 0.7.1 2026-02-21 Fix a bug in the first threading group when threading high to low. Improve the threading display. 0.7.0 2025-02-21 Add support for unterminated loom I/O. This is needed for Toika looms. 0.6.0 2025-02-17 Improve support for Toika looms, and others that do not report direction. Improve server unit tests. 0.5.2 2025-02-21 Update URLS in pyproject.toml. 0.5.1 2025-02-16 Add mkdocs-based documentation. 0.5.0 2025-02-16 Add support for threading. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database. 0.4.0 2025-02-13 Fix a bug that showed up with 32 or more shafts: JavaScript bitwise operations were failing for large values of shaft_word (due to a notorious misfeature of JavaScript). 0.3.0 2025-02-08 Add threading fields to the pattern database. This is preliminary work to add a user interface to assist in threading the loom. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database. 0.2.1 2025-02-06 Improve dependencies to properly bring in uvicorn. Improve the README to suggest that developers install with '[dev]'. 0.2 2025-02-05 Fix a display bug: patterns at pick 0 could not be displayed, due to an undefined variable. 0.1 2025-02-03 Initial prerelease.","title":"Version Histsory"},{"location":"version_history/#version-history","text":"","title":"Version History"},{"location":"version_history/#0193-2025-06-07","text":"Improve the display of the tab bar at the top of the window.","title":"0.19.3 2025-06-07"},{"location":"version_history/#0192-2025-06-07","text":"Improve the display of direction controls.","title":"0.19.2 2025-06-07"},{"location":"version_history/#0191-2025-06-04","text":"Add missing translation strings.","title":"0.19.1 2025-06-04"},{"location":"version_history/#0190-2025-06-3","text":"Add a new Settings panel which allows you to specify loom name, direction control, and new threading settings. Enhance threading support by adding settings for: Thread right-to-left or left-to-right. Thread back-to-front or front-to-back. The defalt threading group size for newly loaded patterns. Automatically reset the pattern database if it changes in an incompatible way. Store the pattern database and new settings file in your home directory, instead of a temporary directory, so that the files will survive a reboot. Breaking change : remove command-line arguments \"name\" and \"direction-control\". Use the new Settings panel, instead.","title":"0.19.0 2025-06-3"},{"location":"version_history/#0183-2025-05-25","text":"Expand unit tests.","title":"0.18.3 2025-05-25"},{"location":"version_history/#0182-2025-05-03","text":"Add API documentation.","title":"0.18.2 2025-05-03"},{"location":"version_history/#0181-2025-04-28","text":"Show the correct threading group size when you connect.","title":"0.18.1 2025-04-28"},{"location":"version_history/#0180-2025-04-28","text":"Improve the threading display: Center the current group, even for patterns with short threading repeats. For ends not threaded on any shaft just show the thread without a shaft number. Formerly a truncated 0 was shown. Showing a whole 0 is possible, but likely more confusing. Remove a source of flicker by only updating the visible pattern.","title":"0.18.0 2025-04-28"},{"location":"version_history/#0170-2025-04-27","text":"Try to prevent an unwanted stale next-pick request when the loom server connects to the loom (which is when a user connects to the server). Do this by purging the read buffer.","title":"0.17.0 2025-04-27"},{"location":"version_history/#0160-2025-04-25","text":"Display total picks in Weaving and total ends in Threading. Also jump to total picks in Weaving and total ends in Threading.","title":"0.16.0 2025-04-25"},{"location":"version_history/#0150-2025-04-19","text":"Save threading group size with each pattern. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database. Add a version history to the documentation.","title":"0.15.0 2025-04-19"},{"location":"version_history/#0140-2025-04-18","text":"Display improvements: Avoid scroll bars, if possible. Make font size vary somewhat with window size. Avoid the search bar and tab controls at the bottom of the iPhone. In Threading move Group size to the right of Direction, to save space.","title":"0.14.0 2025-04-18"},{"location":"version_history/#0130-2025-04-18","text":"Display improvements: Resize the weaving and threading pattern display to fill available space. Move the direction control and (for weaving) pick color, for easier access.","title":"0.13.0 2025-04-18"},{"location":"version_history/#0121-2025-04-14","text":"Small display improvements.","title":"0.12.1 2025-04-14"},{"location":"version_history/#0120-2025-04-03","text":"Support WeavePoint .wpo files. Improve the display of white threads.","title":"0.12.0 2025-04-03"},{"location":"version_history/#0110-2025-04-02","text":"Add a preliminary Finnish translation. Fix a few issues with the installation instructions (especially those related to finding the loom's USB port on unix and macOS). Thanks to Kalle Pihlajasaari for the translation and the doc bug reports.","title":"0.11.0 2025-04-02"},{"location":"version_history/#0100-2025-03-18","text":"Add a Separate repeats checkbox to Weaving and Threading to control whether to include a separator pick (all shafts down) between repeats of weaving or threading. The weaving and threading values are independent of each other, and are saved per pattern in the database. The intial value for weaving/threading is \"on\" if the number of picks/ends > 20, else \"off\". The idea being that the extra advance is helpful for long sequenced, but annoying for short sequences. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database.","title":"0.10.0 2025-03-18"},{"location":"version_history/#091-2025-03-18","text":"Display loom name and # shafts. Improve error handling if a pattern file cannot be parsed.","title":"0.9.1 2025-03-18"},{"location":"version_history/#090-2025-03-14","text":"Add required command-line argument num_shafts. This is needed in order for toika_loom_server to work correctly.","title":"0.9.0 2025-03-14"},{"location":"version_history/#081-2025-03-05","text":"Improve the fix for the Windows encoding issue.","title":"0.8.1 2025-03-05"},{"location":"version_history/#080-2025-03-05","text":"Work around an encoding issue on Windows.","title":"0.8.0 2025-03-05"},{"location":"version_history/#071-2026-02-21","text":"Fix a bug in the first threading group when threading high to low. Improve the threading display.","title":"0.7.1 2026-02-21"},{"location":"version_history/#070-2025-02-21","text":"Add support for unterminated loom I/O. This is needed for Toika looms.","title":"0.7.0 2025-02-21"},{"location":"version_history/#060-2025-02-17","text":"Improve support for Toika looms, and others that do not report direction. Improve server unit tests.","title":"0.6.0 2025-02-17"},{"location":"version_history/#052-2025-02-21","text":"Update URLS in pyproject.toml.","title":"0.5.2 2025-02-21"},{"location":"version_history/#051-2025-02-16","text":"Add mkdocs-based documentation.","title":"0.5.1 2025-02-16"},{"location":"version_history/#050-2025-02-16","text":"Add support for threading. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database.","title":"0.5.0 2025-02-16"},{"location":"version_history/#040-2025-02-13","text":"Fix a bug that showed up with 32 or more shafts: JavaScript bitwise operations were failing for large values of shaft_word (due to a notorious misfeature of JavaScript).","title":"0.4.0 2025-02-13"},{"location":"version_history/#030-2025-02-08","text":"Add threading fields to the pattern database. This is preliminary work to add a user interface to assist in threading the loom. Warning : the database for this version is not compatible with older versions, so run the software with --reset-db if you have an older database.","title":"0.3.0 2025-02-08"},{"location":"version_history/#021-2025-02-06","text":"Improve dependencies to properly bring in uvicorn. Improve the README to suggest that developers install with '[dev]'.","title":"0.2.1 2025-02-06"},{"location":"version_history/#02-2025-02-05","text":"Fix a display bug: patterns at pick 0 could not be displayed, due to an undefined variable.","title":"0.2 2025-02-05"},{"location":"version_history/#01-2025-02-03","text":"Initial prerelease.","title":"0.1 2025-02-03"},{"location":"weaving/","text":"Weaving How to weave fabric. This page assumes you have done all the basics : Connected your web browser to the loom server Uploaded at least one pattern, and selected a pattern from the pattern menu Selected the Weaving mode. Pattern Display The pattern is displayed as a picture that shows woven fabric below and potential future fabric above. (This is the opposite of the usual US drawdown). Note that the display is a bit naive, in that it shows all threads as the same thickness and does not display multi-layer patterns (such as doubleweave) correctly. Weave Direction The Weaving \"Direction\" button shows \"Weave\" (in black) or \"Unweave\" (in red). Threading also has a direction button that shows \"Thread\" (in black) or \"Unthread\" (in red), prefixed by an arrow showing the direction of the next group of warp ends. How you change direction depends on the loom: S\u00e9guin looms allow you to change direction by pressing the direction button in web browser display, or pressing the UNW button on the dobby unit. Both work. Use whichever you prefer. Toika looms can be operated in one of two ways, specified by Direction control in the Settings panel: Software : push the direction button (Weave/Unweave if weaving, Thread/Unthread if threading) in the web browser display to change direction. The physical REVERSE button on the dobby head is ignored . Loom : press the physical REVERSE button on the dobby head to change direction. Warning: the displayed direction does not update until you command the next pick! . This is because Toika looms only report direction when requesting a pick. For other looms, see the loom-specific documentation with the software package. Pick Color The long colored rectangle to the right of Pick shows the color of the current pick (blank for pick 0), or, if you have specified a pick to jump to, then it is the color of that pending pick. Jumping You can jump to a different pick. Jumping is a two-step process: first you request the jump, then you advance to it by pressing the loom's pedal. (Two steps are necessary because most looms will not accept an unsolicited command to raise shafts.) In detail: Enter the desired pick in the box on the \"Jump to pick\" line. The box will turn pink and the Jump button will be enabled. Press the \"return\" keyboard key or click the \"Jump\" button on the web page to send the requested jump to the server. You will see several changes: The jump input box will have a white background and the jump button will be disabled. The pattern display will show the new pick in the center row, with a dotted box around it. Advance to the next pick by pressing the loom's pedal. Until you advance to the next pick, you may request a different jump (in case you got it wrong the first time) or cancel it. To cancel the jump you may do any of the following: Press the \"Reset\" button to the right of \"Jump\". Reload the page. Select a new pattern. Repeating The software will automatically repeat patterns if you weave or unweave beyond the end. The exact behavior is controlled by the Separate repeats checkbox: \"On\" (checked): you must advance twice when you reach an end, before the next set of shafts is raised. The first advance will lower all shafts, as a signal that you have finished weaving or unweaving one pattern repeat. That is the \"separator\". \"Off\" (unchecked): there is no indication that you have reached the end of the pattern. The next pick will be pick 1 of the pattern, if weaving, or the last pick, if unweaving. The default value of Separate repeats is \"on\" if the pattern has more than 20 picks, \"off\" otherwise. The idea behind this is that frequent separator picks are annoying for short patterns, but having a separator pick is useful for long patterns. Threading has a checkbox with the same name that does the same basic thing. However, the value of the Weaving and Threading Separate repeats checkboxes are independent of each other, and may also be different for different patterns. They are saved in the pattern database.","title":"Weaving"},{"location":"weaving/#weaving","text":"How to weave fabric. This page assumes you have done all the basics : Connected your web browser to the loom server Uploaded at least one pattern, and selected a pattern from the pattern menu Selected the Weaving mode.","title":"Weaving"},{"location":"weaving/#pattern-display","text":"The pattern is displayed as a picture that shows woven fabric below and potential future fabric above. (This is the opposite of the usual US drawdown). Note that the display is a bit naive, in that it shows all threads as the same thickness and does not display multi-layer patterns (such as doubleweave) correctly.","title":"Pattern Display"},{"location":"weaving/#weave-direction","text":"The Weaving \"Direction\" button shows \"Weave\" (in black) or \"Unweave\" (in red). Threading also has a direction button that shows \"Thread\" (in black) or \"Unthread\" (in red), prefixed by an arrow showing the direction of the next group of warp ends. How you change direction depends on the loom: S\u00e9guin looms allow you to change direction by pressing the direction button in web browser display, or pressing the UNW button on the dobby unit. Both work. Use whichever you prefer. Toika looms can be operated in one of two ways, specified by Direction control in the Settings panel: Software : push the direction button (Weave/Unweave if weaving, Thread/Unthread if threading) in the web browser display to change direction. The physical REVERSE button on the dobby head is ignored . Loom : press the physical REVERSE button on the dobby head to change direction. Warning: the displayed direction does not update until you command the next pick! . This is because Toika looms only report direction when requesting a pick. For other looms, see the loom-specific documentation with the software package.","title":"Weave Direction"},{"location":"weaving/#pick-color","text":"The long colored rectangle to the right of Pick shows the color of the current pick (blank for pick 0), or, if you have specified a pick to jump to, then it is the color of that pending pick.","title":"Pick Color"},{"location":"weaving/#jumping","text":"You can jump to a different pick. Jumping is a two-step process: first you request the jump, then you advance to it by pressing the loom's pedal. (Two steps are necessary because most looms will not accept an unsolicited command to raise shafts.) In detail: Enter the desired pick in the box on the \"Jump to pick\" line. The box will turn pink and the Jump button will be enabled. Press the \"return\" keyboard key or click the \"Jump\" button on the web page to send the requested jump to the server. You will see several changes: The jump input box will have a white background and the jump button will be disabled. The pattern display will show the new pick in the center row, with a dotted box around it. Advance to the next pick by pressing the loom's pedal. Until you advance to the next pick, you may request a different jump (in case you got it wrong the first time) or cancel it. To cancel the jump you may do any of the following: Press the \"Reset\" button to the right of \"Jump\". Reload the page. Select a new pattern.","title":"Jumping"},{"location":"weaving/#repeating","text":"The software will automatically repeat patterns if you weave or unweave beyond the end. The exact behavior is controlled by the Separate repeats checkbox: \"On\" (checked): you must advance twice when you reach an end, before the next set of shafts is raised. The first advance will lower all shafts, as a signal that you have finished weaving or unweaving one pattern repeat. That is the \"separator\". \"Off\" (unchecked): there is no indication that you have reached the end of the pattern. The next pick will be pick 1 of the pattern, if weaving, or the last pick, if unweaving. The default value of Separate repeats is \"on\" if the pattern has more than 20 picks, \"off\" otherwise. The idea behind this is that frequent separator picks are annoying for short patterns, but having a separator pick is useful for long patterns. Threading has a checkbox with the same name that does the same basic thing. However, the value of the Weaving and Threading Separate repeats checkboxes are independent of each other, and may also be different for different patterns. They are saved in the pattern database.","title":"Repeating"},{"location":"api/base_loom_server/","text":"base_loom_server source package base_loom_server Modules base_loom_server.app_runner base_loom_server.base_loom_server base_loom_server.base_mock_loom base_loom_server.client_replies base_loom_server.constants base_loom_server.enums base_loom_server.example_loom_server base_loom_server.example_mock_loom base_loom_server.main base_loom_server.mock_streams base_loom_server.pattern_database base_loom_server.reduced_pattern base_loom_server.testutils base_loom_server.utils base_loom_server.version","title":"base_loom_server"},{"location":"src/base_loom_server/","text":"base_loom_server docs package base_loom_server","title":"base_loom_server"},{"location":"api/base_loom_server/app_runner/","text":"base_loom_server.app_runner source module base_loom_server.app_runner Classes AppRunner \u2014 Run the loom server application. source class AppRunner ( app : FastAPI , server_class : Type [ BaseLoomServer ] , favicon : bytes , app_package_name : str ) Run the loom server application. This contains the web server's endpoints, the lifespan context manager, and a method to create the argument parser. In order to use this you must create an instance on import (i.e. at the module level), typically in `main.py'. If you defer creation, the web server will not see the endpoints! See main.py for an example. Construct endpoints for FastAPI Parameters app : FastAPI \u2014 The application, generated with app = FastAPI() server_class : Type [ BaseLoomServer ] \u2014 The loom server class (not an instance, but the class itself). favicon : bytes \u2014 A 32x32 or so favicon. No favicon if empty. app_package_name : str \u2014 The name of the python package for your loom server, e.g. \"toika_loom_server\". This is used by the run method, as an argument to uvicorn.run . Methods create_argument_parser \u2014 Create the argument parser. lifespan \u2014 Lifespan context manager for fastAPI. get_translation_dict \u2014 Get the translation dict for the current locale get \u2014 Endpoint to get the main page. get_favicon \u2014 Endpoint to get the favicon websocket_endpoint \u2014 Websocket endpoint. run \u2014 Parse command-line arguments and run the web server. source method AppRunner . create_argument_parser ( ) \u2192 argparse . ArgumentParser Create the argument parser. Subclasses may override this to add more options. source async method AppRunner . lifespan ( self , app : FastAPI ) \u2192 AsyncGenerator [None, FastAPI ] Lifespan context manager for fastAPI. Load the translation dict and create the sole instance of the loom server class. That loom server instance persists for the entire time the web server is running. This is because the loom server speaks to one loom and serves at most one user. source method AppRunner . get_translation_dict ( ) \u2192 dict[str, str] Get the translation dict for the current locale source async method AppRunner . get ( self ) \u2192 HTMLResponse Endpoint to get the main page. source async method AppRunner . get_favicon ( self ) \u2192 Response Endpoint to get the favicon source async method AppRunner . websocket_endpoint ( self , websocket : WebSocket ) \u2192 None Websocket endpoint. source method AppRunner . run ( ) \u2192 None Parse command-line arguments and run the web server.","title":"base_loom_server.app_runner"},{"location":"src/base_loom_server/app_runner/","text":"base_loom_server.app_runner docs module base_loom_server.app_runner 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 import argparse import importlib.resources import json import locale import logging import pathlib from contextlib import asynccontextmanager from typing import AsyncGenerator , Type import uvicorn from fastapi import APIRouter , FastAPI , WebSocket from fastapi.responses import HTMLResponse , Response from .base_loom_server import DEFAULT_DATABASE_PATH , BaseLoomServer from .constants import LOG_NAME from .enums import DirectionControlEnum PKG_FILES = importlib . resources . files ( \"base_loom_server\" ) LOCALE_FILES = PKG_FILES . joinpath ( \"locales\" ) class AppRunner : docs \"\"\"Run the loom server application. This contains the web server's endpoints, the lifespan context manager, and a method to create the argument parser. In order to use this you *must* create an instance on import (i.e. at the module level), typically in `main.py'. If you defer creation, the web server will not see the endpoints! See ``main.py`` for an example. Args: app: The application, generated with ``app = FastAPI()`` server_class: The loom server class (not an instance, but the class itself). favicon: A 32x32 or so favicon. No favicon if empty. app_package_name: The name of the python package for your loom server, e.g. \"toika_loom_server\". This is used by the `run` method, as an argument to `uvicorn.run`. \"\"\" DirectionControlMap = { item . name . lower (): item for item in DirectionControlEnum } def __init__ ( self , app : FastAPI , server_class : Type [ BaseLoomServer ], favicon : bytes , app_package_name : str , ) -> None : \"\"\"Construct endpoints for FastAPI\"\"\" self . log = logging . getLogger ( LOG_NAME ) self . server_class = server_class self . favicon = favicon self . app_package_name = app_package_name self . loom_server : BaseLoomServer | None = None self . translation_dict : dict [ str , str ] = {} # There must be a better way to do this, # but everything I have tried fails, # including using an APIRouter with add_api_route @asynccontextmanager async def lifespan_wrapper ( * args ): async with self . lifespan ( app ): yield # The only rason we need a router is to set the lifespan # but once we have it we may as well use it to add endpoints as well router = APIRouter ( lifespan = lifespan_wrapper ) @router . get ( \"/\" ) async def get_wrapper (): return await self . get () if self . favicon : @router . get ( \"/favicon.ico\" , include_in_schema = False ) async def get_favicon (): return await self . get_favicon () @router . websocket ( \"/ws\" ) async def websocket_endpoint_wrapper ( websocket : WebSocket ): return await self . websocket_endpoint ( websocket ) app . include_router ( router ) def create_argument_parser ( self ) -> argparse . ArgumentParser : docs \"\"\"Create the argument parser. Subclasses may override this to add more options. \"\"\" parser = argparse . ArgumentParser () parser . add_argument ( \"num_shafts\" , type = int , help = \"The number of shafts the loom has.\" ) parser . add_argument ( \"serial_port\" , help = \"Serial port connected to the loom, \" \"typically of the form /dev/tty... \" \"Specify 'mock' to run a mock (simulated) loom\" , ) parser . add_argument ( \"-r\" , \"--reset-db\" , action = \"store_true\" , help = \"Reset the pattern database, erasing all patterns.\" , ) parser . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , help = \"Log extra diagnostic information.\" , ) parser . add_argument ( \"--db-path\" , default = DEFAULT_DATABASE_PATH , type = pathlib . Path , help = \"Path for the pattern database. \" \"Specify this if you plan to run more than one loom server on this computer.\" , ) parser . add_argument ( \"--host\" , default = \"0.0.0.0\" , help = \"Server host. 0.0.0.0 is standard. Don't change this unless you know what you are doing.\" , ) parser . add_argument ( \"--port\" , type = int , default = 8000 , help = \"Server port. Specify this if you wish to run more than one web server on this computer.\" , ) parser . add_argument ( \"--log-level\" , choices = ( \"critical\" , \"error\" , \"warning\" , \"info\" , \"debug\" , \"trace\" ), default = \"info\" , help = \"Logging level.\" , ) return parser @asynccontextmanager docs async def lifespan ( self , app : FastAPI ) -> AsyncGenerator [ None , FastAPI ]: \"\"\"Lifespan context manager for fastAPI. Load the translation dict and create the sole instance of the loom server class. That loom server instance persists for the entire time the web server is running. This is because the loom server speaks to one loom and serves at most one user. \"\"\" self . translation_dict = self . get_translation_dict () parser = self . create_argument_parser () args = parser . parse_args () for uvicorn_arg in ( \"host\" , \"port\" , \"log_level\" ): if getattr ( args , uvicorn_arg , None ) is not None : delattr ( args , uvicorn_arg ) async with self . server_class ( ** vars ( args ), translation_dict = self . translation_dict , ) as self . loom_server : # Store the server as state for unit tests app . state . loom_server = self . loom_server yield def get_translation_dict ( self ) -> dict [ str , str ]: docs \"\"\"Get the translation dict for the current locale\"\"\" # Read a dict of key: None and turn into a dict of key: key default_dict = json . loads ( LOCALE_FILES . joinpath ( \"default.json\" ) . read_text ( encoding = \"utf_8\" ) ) translation_dict = { key : key for key in default_dict } language_code = locale . getlocale ( locale . LC_CTYPE )[ 0 ] self . log . info ( f \"Locale: { language_code !r} \" ) if language_code is not None : short_language_code = language_code . split ( \"_\" )[ 0 ] for lc in ( short_language_code , language_code ): translation_name = lc + \".json\" translation_file = LOCALE_FILES . joinpath ( translation_name ) if translation_file . is_file (): self . log . info ( f \"Loading translation file { translation_name !r} \" ) locale_dict = json . loads ( translation_file . read_text ( encoding = \"utf_8\" ) ) purged_locale_dict = { key : value for key , value in locale_dict . items () if value is not None } if purged_locale_dict != locale_dict : self . log . warning ( f \"Some entries in translation file { translation_name !r} \" \"have null entries\" ) translation_dict . update ( purged_locale_dict ) return translation_dict async def get ( self ) -> HTMLResponse : docs \"\"\"Endpoint to get the main page.\"\"\" assert self . loom_server is not None # make mypy happy display_html = PKG_FILES . joinpath ( \"display.html\" ) . read_text ( encoding = \"utf_8\" ) display_css = PKG_FILES . joinpath ( \"display.css\" ) . read_text ( encoding = \"utf_8\" ) display_js = PKG_FILES . joinpath ( \"display.js\" ) . read_text ( encoding = \"utf_8\" ) js_translation_str = json . dumps ( self . translation_dict , indent = 4 ) display_js = display_js . replace ( \"{ translation_dict }\" , js_translation_str ) assert self . loom_server is not None is_mock = self . loom_server . mock_loom is not None display_debug_controls = \"block\" if is_mock else \"none\" display_html = display_html . format ( display_css = display_css , display_js = display_js , display_debug_controls = display_debug_controls , ** self . translation_dict , ) return HTMLResponse ( display_html ) async def get_favicon ( self ) -> Response : docs \"\"\"Endpoint to get the favicon\"\"\" return Response ( content = self . favicon , media_type = \"image/x-icon\" ) async def websocket_endpoint ( self , websocket : WebSocket ) -> None : docs \"\"\"Websocket endpoint.\"\"\" assert self . loom_server is not None await self . loom_server . run_client ( websocket = websocket ) def run ( self ) -> None : docs \"\"\"Parse command-line arguments and run the web server.\"\"\" # Handle the help argument and also catch parsing errors right away arg_parser = self . create_argument_parser () args = arg_parser . parse_args () uvicorn . run ( self . app_package_name , host = args . host , port = args . port , log_level = args . log_level , reload = False , )","title":"base_loom_server.app_runner"},{"location":"api/base_loom_server/base_loom_server/","text":"base_loom_server.base_loom_server source module base_loom_server.base_loom_server Classes BaseLoomServer \u2014 Base class for a web server that controls a dobby loom. CloseCode \u2014 WebSocket close codes CommandError source class BaseLoomServer ( * , num_shafts : int , serial_port : str , translation_dict : dict[str, str] , reset_db : bool , verbose : bool , db_path : pathlib . Path | None = None ) Base class for a web server that controls a dobby loom. Subclasses should not only provide implementations for the abstract methods, but should also override the class constants, as appropriate. Parameters num_shafts : int \u2014 The number of shafts the loom has. serial_port : str \u2014 The name of the serial port, e.g. \"/dev/tty0\". If the name is \"mock\" then use a mock loom. translation_dict : dict[str, str] \u2014 Language translation dict. reset_db : bool \u2014 If True, delete the old database and create a new one. verbose : bool \u2014 If True, log diagnostic information. db_path : pathlib . Path | None \u2014 Path to the pattern database. Specify None for the default path. Unit tests specify a non-None value, to avoid stomping on the real database. Attributes thread_low_to_high : bool \u2014 Return True if threading (or unthreading) is currently low to high. loom_connected : bool \u2014 Return True if connected to the loom. Methods handle_loom_reply \u2014 Process one reply from the loom. write_shafts_to_loom \u2014 Write the shaft word to the loom. start close \u2014 Disconnect from client and loom and stop all tasks. add_pattern \u2014 Add a pattern to pattern database. close_websocket \u2014 Close a websocket using best effort and a short timeout. get_initial_loom_state \u2014 Obtain the loom state. connect_to_loom \u2014 Connect to the loom. run_client \u2014 Run a client connection, closing any existing connection. disconnect_client disconnect_from_loom \u2014 Disconnect from the loom. A no-op if already disconnected. basic_read_loom \u2014 Read one reply from the loom. clear_jump_end \u2014 Clear self.jump_end and report value if changed or force_output clear_jump_pick \u2014 Clear self.jump_pick and report value if changed or force_output clear_jumps \u2014 Clear all jumps and report values if changed or force_output. cmd_clear_pattern_names cmd_direction cmd_file cmd_jump_to_end cmd_jump_to_pick cmd_mode cmd_select_pattern cmd_separate_threading_repeats cmd_separate_weaving_repeats cmd_settings cmd_thread_group_size cmd_oobcommand get_threading_shaft_word handle_next_pick_request \u2014 Handle next pick request from loom. increment_pick_number \u2014 Increment pick_number in the current direction. increment_end_number \u2014 Increment end_number0 in the current direction. read_client_loop \u2014 Read and process commands from the client. read_loom_loop \u2014 Read and process replies from the loom. report_command_done \u2014 Report completion of a command report_command_problem \u2014 Report a CommandProblem to the client. report_current_pattern \u2014 Report pattern to the client report_initial_server_state \u2014 Report server state. report_loom_connection_state \u2014 Report LoomConnectionState to the client. report_pattern_names \u2014 Report PatternNames to the client. report_current_pick_number \u2014 Report CurrentPickNumber to the client. report_current_end_numbers \u2014 Report CurrentEndNumber to the client. report_jump_end \u2014 Report JumpEndNumber to the client. report_jump_pick \u2014 Report JumpPickNumber to the client. report_shaft_state \u2014 Report ShaftState to the client. report_mode \u2014 Report the current mode to the client. report_separate_threading_repeats report_separate_weaving_repeats report_settings report_status_message \u2014 Report a status message to the client. report_thread_group_size \u2014 Report ThreadGroupSize report_direction \u2014 Report Direction reset_database save_settings \u2014 Save the settings file. select_pattern t \u2014 Translate a phrase, if possible. write_to_client \u2014 Send a reply to the client. write_to_loom \u2014 Send data to the loom. source async method BaseLoomServer . handle_loom_reply ( self , reply_bytes : bytes ) \u2192 None Process one reply from the loom. Raises NotImplementedError source async method BaseLoomServer . write_shafts_to_loom ( self , shaft_word : int ) \u2192 None Write the shaft word to the loom. Raises NotImplementedError source property BaseLoomServer . enable_software_direction : bool source property BaseLoomServer . thread_low_to_high : bool Return True if threading (or unthreading) is currently low to high. Takes into account forward_direction (threading or unthreading) and threading settings, but not jump_to_end. source property BaseLoomServer . loom_connected : bool Return True if connected to the loom. source async method BaseLoomServer . start ( self ) \u2192 None source async method BaseLoomServer . close ( self , stop_read_loom : bool = True , stop_read_client : bool = True ) \u2192 None Disconnect from client and loom and stop all tasks. source async method BaseLoomServer . add_pattern ( self , pattern : ReducedPattern ) \u2192 None Add a pattern to pattern database. Also purge the MAX_PATTERNS oldest entries (excluding the current pattern, if any) and report the new list of pattern names to the client. source async method BaseLoomServer . close_websocket ( self , ws : WebSocket , code : CloseCode = CloseCode . NORMAL , reason : str = '' ) \u2192 None Close a websocket using best effort and a short timeout. source async method BaseLoomServer . get_initial_loom_state ( self ) \u2192 None Obtain the loom state. Called just after the server connects to the loom. Usually a no-op, because a well designed loom automatically reports its own state when software connects to it. source async method BaseLoomServer . connect_to_loom ( self ) \u2192 None Connect to the loom. If already connected to loom, disconnect first, since connecting again may indicate that something is wrong. source async method BaseLoomServer . run_client ( self , websocket : WebSocket ) \u2192 None Run a client connection, closing any existing connection. Also open a connection to the loom, if that was closed. Parameters websocket : WebSocket \u2014 Connection to the client. source async method BaseLoomServer . disconnect_client ( self , cancel_read_client_loop : bool = True ) \u2192 None source async method BaseLoomServer . disconnect_from_loom ( self ) \u2192 None Disconnect from the loom. A no-op if already disconnected. source async method BaseLoomServer . basic_read_loom ( self ) \u2192 bytes Read one reply from the loom. Perform no error checking, except that self.loom_reader exists. source async method BaseLoomServer . clear_jump_end ( self , force_output = False ) Clear self.jump_end and report value if changed or force_output Parameters force_output \u2014 If true, report JumpEndNumber , even if it has not changed. source async method BaseLoomServer . clear_jump_pick ( self , force_output = False ) Clear self.jump_pick and report value if changed or force_output Parameters force_output \u2014 If true, report JumpPickNumber , even if it has not changed. source async method BaseLoomServer . clear_jumps ( self , force_output = False ) Clear all jumps and report values if changed or force_output. source async method BaseLoomServer . cmd_clear_pattern_names ( self , command : SimpleNamespace ) \u2192 None source async method BaseLoomServer . cmd_direction ( self , command : SimpleNamespace ) \u2192 None source async method BaseLoomServer . cmd_file ( self , command : SimpleNamespace ) \u2192 None Raises CommandError source async method BaseLoomServer . cmd_jump_to_end ( self , command : SimpleNamespace ) \u2192 None Raises CommandError source async method BaseLoomServer . cmd_jump_to_pick ( self , command : SimpleNamespace ) \u2192 None Raises CommandError source async method BaseLoomServer . cmd_mode ( self , command : SimpleNamespace ) \u2192 None source async method BaseLoomServer . cmd_select_pattern ( self , command : SimpleNamespace ) \u2192 None source async method BaseLoomServer . cmd_separate_threading_repeats ( self , command : SimpleNamespace ) \u2192 None source async method BaseLoomServer . cmd_separate_weaving_repeats ( self , command : SimpleNamespace ) \u2192 None source async method BaseLoomServer . cmd_settings ( self , command : SimpleNamespace ) \u2192 None Raises CommandError source async method BaseLoomServer . cmd_thread_group_size ( self , command : SimpleNamespace ) \u2192 None source async method BaseLoomServer . cmd_oobcommand ( self , command : SimpleNamespace ) \u2192 None source method BaseLoomServer . get_threading_shaft_word ( ) \u2192 int source async method BaseLoomServer . handle_next_pick_request ( self ) \u2192 None Handle next pick request from loom. Call this from handle_loom_reply. Figure out the next pick, send it to the loom, and report the information to the client. Raises RuntimeError source method BaseLoomServer . increment_pick_number ( ) \u2192 int Increment pick_number in the current direction. Increment pick_repeat_number as well, if appropriate. Return the new pick number. This will be 0 if pick_repeat_number changed, or if unweaving and pick_repeat_number would be decremented to 0. source method BaseLoomServer . increment_end_number ( ) \u2192 None Increment end_number0 in the current direction. source async method BaseLoomServer . read_client_loop ( self ) \u2192 None Read and process commands from the client. source async method BaseLoomServer . read_loom_loop ( self ) \u2192 None Read and process replies from the loom. Raises RuntimeError source async method BaseLoomServer . report_command_done ( self , cmd_type : str , success : bool , message : str = '' ) \u2192 None Report completion of a command source async method BaseLoomServer . report_command_problem ( self , message : str , severity : MessageSeverityEnum ) \u2192 None Report a CommandProblem to the client. source async method BaseLoomServer . report_current_pattern ( self ) \u2192 None Report pattern to the client source async method BaseLoomServer . report_initial_server_state ( self ) \u2192 None Report server state. Called just after a client connects to the server. source async method BaseLoomServer . report_loom_connection_state ( self , reason : str = '' ) \u2192 None Report LoomConnectionState to the client. source async method BaseLoomServer . report_pattern_names ( self ) \u2192 None Report PatternNames to the client. source async method BaseLoomServer . report_current_pick_number ( self ) \u2192 None Report CurrentPickNumber to the client. Also update pick information in the database. source async method BaseLoomServer . report_current_end_numbers ( self ) \u2192 None Report CurrentEndNumber to the client. Also update threading information the database. source async method BaseLoomServer . report_jump_end ( self ) \u2192 None Report JumpEndNumber to the client. source async method BaseLoomServer . report_jump_pick ( self ) \u2192 None Report JumpPickNumber to the client. source async method BaseLoomServer . report_shaft_state ( self ) \u2192 None Report ShaftState to the client. source async method BaseLoomServer . report_mode ( self ) \u2192 None Report the current mode to the client. source async method BaseLoomServer . report_separate_threading_repeats ( self ) \u2192 None source async method BaseLoomServer . report_separate_weaving_repeats ( self ) \u2192 None source async method BaseLoomServer . report_settings ( self ) \u2192 None source async method BaseLoomServer . report_status_message ( self , message : str , severity : MessageSeverityEnum ) \u2192 None Report a status message to the client. source async method BaseLoomServer . report_thread_group_size ( self ) \u2192 None Report ThreadGroupSize source async method BaseLoomServer . report_direction ( self ) \u2192 None Report Direction source method BaseLoomServer . reset_database ( ) source method BaseLoomServer . save_settings ( ) Save the settings file. source async method BaseLoomServer . select_pattern ( self , name : str ) \u2192 None Raises CommandError source method BaseLoomServer . t ( phrase : str ) \u2192 str Translate a phrase, if possible. source async method BaseLoomServer . write_to_client ( self , reply : Any ) \u2192 None Send a reply to the client. Parameters reply : Any \u2014 The reply to write, as a dataclass. It should have a \"type\" field whose value is a string. source async method BaseLoomServer . write_to_loom ( self , data : bytes | bytearray | str ) \u2192 None Send data to the loom. Parameters data : bytes | bytearray | str \u2014 The data to send, without a terminator. (This method will append the terminator). Raises RuntimeError source enum CloseCode ( * args , ** kwds ) Bases : enum . IntEnum WebSocket close codes A small subset of https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4 Attributes NORMAL GOING_AWAY ERROR source class CommandError ( ) Bases : Exception","title":"base_loom_server.base_loom_server"},{"location":"src/base_loom_server/base_loom_server/","text":"base_loom_server.base_loom_server docs module base_loom_server.base_loom_server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 from __future__ import annotations __all__ = [ \"BaseLoomServer\" , \"DEFAULT_DATABASE_PATH\" , \"MOCK_PORT_NAME\" , ] import abc import asyncio import copy import dataclasses import enum import json import logging import pathlib from types import SimpleNamespace , TracebackType from typing import Any , Type from dtx_to_wif import read_pattern_data from fastapi import WebSocket , WebSocketDisconnect from fastapi.websockets import WebSocketState from serial_asyncio import open_serial_connection # type: ignore from . import client_replies from .base_mock_loom import BaseMockLoom from .constants import LOG_NAME from .enums import DirectionControlEnum , MessageSeverityEnum , ModeEnum , ShaftStateEnum from .mock_streams import StreamReaderType , StreamWriterType from .pattern_database import PatternDatabase from .reduced_pattern import ReducedPattern , reduced_pattern_from_pattern_data from .utils import compute_num_within_and_repeats , compute_total_num # The maximum number of patterns that can be in the history MAX_PATTERNS = 25 DEFAULT_DATABASE_PATH = pathlib . Path . home () / \"loom_server_database.sqlite\" SETTINGS_FILE_NAME = \"loom_server_settings.json\" MOCK_PORT_NAME = \"mock\" class CloseCode ( enum . IntEnum ): docs \"\"\"WebSocket close codes A small subset of https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4 \"\"\" NORMAL = 1000 GOING_AWAY = 1001 ERROR = 1011 class CommandError ( Exception ): docs pass class BaseLoomServer : docs \"\"\"Base class for a web server that controls a dobby loom. Subclasses should not only provide implementations for the abstract methods, but should also override the class constants, as appropriate. Args: num_shafts: The number of shafts the loom has. serial_port: The name of the serial port, e.g. \"/dev/tty0\". If the name is \"mock\" then use a mock loom. translation_dict: Language translation dict. reset_db: If True, delete the old database and create a new one. verbose: If True, log diagnostic information. db_path: Path to the pattern database. Specify None for the default path. Unit tests specify a non-None value, to avoid stomping on the real database. \"\"\" # Subclasses should override these, as necesary. # Definitely overide `default_name` and `mock_loom_type`. baud_rate = 9600 default_name = \"base\" loom_reports_direction = True loom_reports_motion = True mock_loom_type : type [ BaseMockLoom ] | None = None supports_full_direction_control = True def __init__ ( self , * , num_shafts : int , serial_port : str , translation_dict : dict [ str , str ], reset_db : bool , verbose : bool , db_path : pathlib . Path | None = None , ) -> None : if self . mock_loom_type is None : raise RuntimeError ( \"Subclasses must set class variable 'mock_loom_type'\" ) self . terminator = self . mock_loom_type . terminator self . log = logging . getLogger ( LOG_NAME ) if verbose : self . log . info ( f \" { self } ( { serial_port =!r} , { reset_db =!r} , { verbose =!r} , { db_path =!r} )\" ) self . serial_port = serial_port self . translation_dict = translation_dict self . verbose = verbose self . loom_info = client_replies . LoomInfo ( num_shafts = num_shafts , serial_port = serial_port ) self . db_path : pathlib . Path = ( DEFAULT_DATABASE_PATH if db_path is None else db_path ) if reset_db : self . log . info ( f \"Resetting database { self . db_path } by request\" ) self . reset_database () try : self . pattern_db = PatternDatabase ( self . db_path ) except Exception as e : self . log . warning ( f \"Resetting database { self . db_path } because open failed: { e !r} \" ) self . reset_database () # Compute initial value for direction_control. # This value will be overridden by the settings file, if it exists. if self . supports_full_direction_control : direction_control = DirectionControlEnum . FULL elif self . loom_reports_direction : # We have to pick something for the initial default, # and it may as well be the loom. direction_control = DirectionControlEnum . LOOM else : # This value is required for unit tests, which want immediate # notification when the direction changes. direction_control = DirectionControlEnum . SOFTWARE settings = client_replies . Settings ( loom_name = self . default_name , direction_control = direction_control , thread_group_size = 4 , thread_right_to_left = True , thread_back_to_front = True , ) self . settings_path = self . db_path . parent / SETTINGS_FILE_NAME if self . settings_path . exists (): try : with open ( self . settings_path , \"r\" ) as f : settings_dict = json . load ( f ) for key , value in settings_dict . items (): if key == \"type\" : continue default_value = getattr ( settings , key , None ) if default_value is None : self . log . warning ( f \"Ignoring setting { key } = { value !r} ; uknown key\" ) else : try : cast_value = type ( default_value )( value ) except Exception : self . log . warning ( f \"Ignoring setting { key } = { value !r} ; wrong type or invalid enum value\" ) else : setattr ( settings , key , cast_value ) except Exception as e : self . log . warning ( f \"Deleting settings file { self . settings_path } because read failed: { e !r} \" ) self . settings_path . unlink () else : self . log . info ( f \"Settings file { self . settings_path } does not exist\" ) self . settings = settings self . save_settings () self . websocket : WebSocket | None = None self . loom_connecting = False self . loom_disconnecting = False self . client_connected = False self . shaft_state : ShaftStateEnum = ShaftStateEnum . UNKNOWN self . shaft_word = 0 self . mock_loom : BaseMockLoom | None = None self . loom_reader : StreamReaderType | None = None self . loom_writer : StreamWriterType | None = None self . read_client_task : asyncio . Future = asyncio . Future () self . read_loom_task : asyncio . Future = asyncio . Future () self . done_task : asyncio . Future = asyncio . Future () self . current_pattern : ReducedPattern | None = None self . jump_pick = client_replies . JumpPickNumber () self . jump_end = client_replies . JumpEndNumber () self . mode = ModeEnum . WEAVE self . direction_forward = True @abc . abstractmethod async def handle_loom_reply ( self , reply_bytes : bytes ) -> None : docs \"\"\"Process one reply from the loom.\"\"\" raise NotImplementedError @abc . abstractmethod async def write_shafts_to_loom ( self , shaft_word : int ) -> None : docs \"\"\"Write the shaft word to the loom.\"\"\" raise NotImplementedError () @property def enable_software_direction ( self ) -> bool : docs return self . settings . direction_control in { DirectionControlEnum . FULL , DirectionControlEnum . SOFTWARE , } @property def thread_low_to_high ( self ) -> bool : docs \"\"\"Return True if threading (or unthreading) is currently low to high. Takes into account forward_direction (threading or unthreading) and threading settings, but not jump_to_end. \"\"\" low_to_high_if_forward = ( self . settings . thread_back_to_front == self . settings . thread_right_to_left ) return ( low_to_high_if_forward if self . direction_forward else not low_to_high_if_forward ) @property def loom_connected ( self ) -> bool : docs \"\"\"Return True if connected to the loom.\"\"\" return not ( self . loom_writer is None or self . loom_reader is None or self . loom_writer . is_closing () or self . loom_reader . at_eof () ) async def start ( self ) -> None : docs await self . pattern_db . init () if not await self . pattern_db . check_schema (): self . log . warning ( f \"Resetting database { self . db_path } because the schema is outdated\" ) self . reset_database () await self . clear_jumps () # Restore current pattern, if any names = await self . pattern_db . get_pattern_names () if len ( names ) > 0 : await self . select_pattern ( names [ - 1 ]) await self . connect_to_loom () async def close ( docs self , stop_read_loom : bool = True , stop_read_client : bool = True ) -> None : \"\"\"Disconnect from client and loom and stop all tasks.\"\"\" if self . loom_writer is not None : if stop_read_loom : self . read_loom_task . cancel () if stop_read_client : self . read_client_task . cancel () self . loom_writer . close () if self . mock_loom is not None : await self . mock_loom . close () if not self . done_task . done (): self . done_task . set_result ( None ) async def add_pattern ( self , pattern : ReducedPattern ) -> None : docs \"\"\"Add a pattern to pattern database. Also purge the MAX_PATTERNS oldest entries (excluding the current pattern, if any) and report the new list of pattern names to the client. \"\"\" await self . pattern_db . add_pattern ( pattern = pattern , max_entries = MAX_PATTERNS ) await self . report_pattern_names () async def close_websocket ( docs self , ws : WebSocket , code : CloseCode = CloseCode . NORMAL , reason : str = \"\" ) -> None : \"\"\"Close a websocket using best effort and a short timeout.\"\"\" if ws . client_state == WebSocketState . DISCONNECTED : return try : async with asyncio . timeout ( 0.1 ): await ws . close ( code , reason ) except Exception as e : self . log . warning ( f \" { self } : failed to close websocket: { e !r} \" ) async def get_initial_loom_state ( self ) -> None : docs \"\"\"Obtain the loom state. Called just after the server connects to the loom. Usually a no-op, because a well designed loom automatically reports its own state when software connects to it. \"\"\" pass async def connect_to_loom ( self ) -> None : docs \"\"\"Connect to the loom. If already connected to loom, disconnect first, since connecting again may indicate that something is wrong. \"\"\" if self . loom_connected : await self . disconnect_from_loom () try : self . loom_connecting = True await self . report_loom_connection_state () if self . loom_info . serial_port == MOCK_PORT_NAME : assert self . mock_loom_type is not None # make mypy happy self . mock_loom = self . mock_loom_type ( num_shafts = self . loom_info . num_shafts , verbose = self . verbose ) assert self . mock_loom is not None # make mypy happy self . loom_reader , self . loom_writer = ( await self . mock_loom . open_client_connection () ) else : self . loom_reader , self . loom_writer = await open_serial_connection ( url = self . loom_info . serial_port , baudrate = self . baud_rate ) # try to purge input buffer transport = getattr ( self . loom_writer , \"transport\" , None ) if transport is None : self . log . warning ( f \" { self } : Could not flush read buffer; no transport found\" ) else : serial_instance = getattr ( transport , \"_serial\" , None ) if serial_instance is None : self . log . warning ( f \" { self } : Could not flush read buffer; no serial instance found in transport\" ) elif serial_instance . in_waiting > 0 : serial_instance . reset_input_buffer () self . log . info ( f \" { self } : Read buffer flushed\" ) else : self . log . info ( f \" { self } : Read buffer did not need to be flushed; it was empty\" ) self . loom_connecting = False await self . report_loom_connection_state () await self . get_initial_loom_state () except Exception as e : self . loom_connecting = False await self . report_loom_connection_state ( reason = str ( e )) raise finally : self . loom_connecting = False self . read_loom_task = asyncio . create_task ( self . read_loom_loop ()) async def run_client ( self , websocket : WebSocket ) -> None : docs \"\"\"Run a client connection, closing any existing connection. Also open a connection to the loom, if that was closed. Args: websocket: Connection to the client. \"\"\" if self . client_connected : self . log . info ( f \" { self } : a client was already connected; closing that connection\" ) await self . disconnect_client () await websocket . accept () self . websocket = websocket self . read_client_task = asyncio . create_task ( self . read_client_loop ()) if not self . loom_connected : try : await self . connect_to_loom () except Exception as e : # Note: connect_to_loom already reported the # (lack of) connection state, including the reason. # But log it here. self . log . exception ( f \" { self } : failed to reconnect to the loom: { e !r} \" ) await self . done_task docs async def disconnect_client ( self , cancel_read_client_loop : bool = True ) -> None : self . read_client_task . cancel () websocket = self . websocket self . websocket = None if websocket is not None : await self . close_websocket ( websocket , code = CloseCode . GOING_AWAY , reason = self . t ( \"another client took control\" ), ) async def disconnect_from_loom ( self ) -> None : docs \"\"\"Disconnect from the loom. A no-op if already disconnected.\"\"\" if not self . loom_connected : return self . loom_disconnecting = True await self . report_loom_connection_state () try : if self . loom_writer is not None : self . loom_writer . close () self . loom_reader = None self . loom_writer = None self . mock_loom = None finally : self . loom_disconnecting = False await self . report_loom_connection_state () async def basic_read_loom ( self ) -> bytes : docs \"\"\"Read one reply from the loom. Perform no error checking, except that self.loom_reader exists. \"\"\" assert self . loom_reader is not None return await self . loom_reader . readuntil ( self . terminator ) async def clear_jump_end ( self , force_output = False ): docs \"\"\"Clear self.jump_end and report value if changed or force_output Args: force_output: If true, report `JumpEndNumber`, even if it has not changed. \"\"\" null_jump_end = client_replies . JumpEndNumber () do_report = force_output or self . jump_end != null_jump_end self . jump_end = null_jump_end if do_report : await self . report_jump_end () async def clear_jump_pick ( self , force_output = False ): docs \"\"\"Clear self.jump_pick and report value if changed or force_output Args: force_output: If true, report `JumpPickNumber`, even if it has not changed. \"\"\" null_jump_pick = client_replies . JumpPickNumber () do_report = force_output or self . jump_pick != null_jump_pick self . jump_pick = null_jump_pick if do_report : await self . report_jump_pick () async def clear_jumps ( self , force_output = False ): docs \"\"\"Clear all jumps and report values if changed or force_output.\"\"\" await self . clear_jump_end ( force_output = force_output ) await self . clear_jump_pick ( force_output = force_output ) docs async def cmd_clear_pattern_names ( self , command : SimpleNamespace ) -> None : # Clear the pattern database # Then add the current pattern (if any) await self . pattern_db . clear_database () if self . current_pattern is not None : await self . add_pattern ( self . current_pattern ) else : await self . report_pattern_names () async def cmd_direction ( self , command : SimpleNamespace ) -> None : docs self . direction_forward = command . forward await self . report_direction () async def cmd_file ( self , command : SimpleNamespace ) -> None : docs suffix = command . name [ - 4 :] if self . verbose : self . log . info ( f \" { self } : read weaving pattern { command . name !r} : data= { command . data [ 0 : 80 ] !r} ...\" , ) pattern_data = read_pattern_data ( command . data , suffix = suffix , name = command . name ) pattern = reduced_pattern_from_pattern_data ( name = command . name , data = pattern_data ) # max_shaft_num needs +1 because pattern.threading is 0-based max_shaft_num = max ( pattern . threading ) + 1 if max_shaft_num > self . loom_info . num_shafts : raise CommandError ( f \"Pattern { command . name !r} max shaft { max_shaft_num } > { self . loom_info . num_shafts } \" ) pattern . thread_group_size = self . settings . thread_group_size await self . add_pattern ( pattern ) async def cmd_jump_to_end ( self , command : SimpleNamespace ) -> None : docs if self . current_pattern is None : raise CommandError ( self . t ( \"cannot jump to an end\" ) + \": \" + self . t ( \"no pattern\" ) ) if command . total_end_number0 is None : self . jump_end = client_replies . JumpEndNumber () else : total_end_number0 = command . total_end_number0 end_number0 , end_repeat_number = compute_num_within_and_repeats ( total_num = total_end_number0 , repeat_len = self . current_pattern . num_ends , ) end_number1 = self . current_pattern . compute_end_number1 ( end_number0 = end_number0 ) total_end_number1 = compute_total_num ( num_within = end_number1 , repeat_number = end_repeat_number , repeat_len = self . current_pattern . num_ends , ) self . jump_end = client_replies . JumpEndNumber ( total_end_number0 = total_end_number0 , total_end_number1 = total_end_number1 , end_number0 = end_number0 , end_number1 = end_number1 , end_repeat_number = end_repeat_number , ) await self . report_jump_end () async def cmd_jump_to_pick ( self , command : SimpleNamespace ) -> None : docs if self . current_pattern is None : raise CommandError ( self . t ( \"cannot jump to a pick\" ) + \": \" + self . t ( \"no pattern\" ) ) if command . total_picks is None : self . jump_pick = client_replies . JumpPickNumber () else : pick_number , pick_repeat_number = compute_num_within_and_repeats ( total_num = command . total_picks , repeat_len = self . current_pattern . num_picks ) self . jump_pick = client_replies . JumpPickNumber ( total_picks = command . total_picks , pick_number = pick_number , pick_repeat_number = pick_repeat_number , ) await self . report_jump_pick () async def cmd_mode ( self , command : SimpleNamespace ) -> None : docs self . mode = ModeEnum ( command . mode ) await self . report_mode () docs async def cmd_select_pattern ( self , command : SimpleNamespace ) -> None : name = command . name if self . current_pattern is not None and self . current_pattern . name == name : return await self . select_pattern ( name ) await self . clear_jumps () docs async def cmd_separate_threading_repeats ( self , command : SimpleNamespace ) -> None : if self . current_pattern is None : return await self . pattern_db . update_separate_threading_repeats ( pattern_name = self . current_pattern . name , separate_threading_repeats = command . separate , ) self . current_pattern . separate_threading_repeats = command . separate await self . report_separate_threading_repeats () docs async def cmd_separate_weaving_repeats ( self , command : SimpleNamespace ) -> None : if self . current_pattern is None : return await self . pattern_db . update_separate_weaving_repeats ( pattern_name = self . current_pattern . name , separate_weaving_repeats = command . separate , ) self . current_pattern . separate_weaving_repeats = command . separate await self . report_separate_weaving_repeats () async def cmd_settings ( self , command : SimpleNamespace ) -> None : docs bad_keys = list () new_settings = copy . copy ( self . settings ) for key , value in vars ( command ) . items (): if key == \"type\" : continue old_value = getattr ( self . settings , key , ... ) if old_value is ... : bad_keys . append ( key ) continue try : cast_value = type ( old_value )( value ) except Exception as e : raise CommandError ( f \"Invalid { key } = { value !r} : { e } \" ) setattr ( new_settings , key , cast_value ) if bad_keys : raise CommandError ( f \"Settings command failed: invalid keys { bad_keys } \" ) self . settings = new_settings await self . report_settings () self . save_settings () docs async def cmd_thread_group_size ( self , command : SimpleNamespace ) -> None : if self . current_pattern is None : return await self . pattern_db . update_thread_group_size ( pattern_name = self . current_pattern . name , thread_group_size = command . group_size , ) self . current_pattern . thread_group_size = command . group_size await self . report_thread_group_size () async def cmd_oobcommand ( self , command : SimpleNamespace ) -> None : docs if self . mock_loom is not None : await self . mock_loom . oob_command ( command . command ) else : self . log . warning ( f \"Ignoring oob command { command . command !r} : no mock loom\" ) def get_threading_shaft_word ( self ) -> int : docs if self . current_pattern is None : return 0 return self . current_pattern . get_threading_shaft_word () async def handle_next_pick_request ( self ) -> None : docs \"\"\"Handle next pick request from loom. Call this from handle_loom_reply. Figure out the next pick, send it to the loom, and report the information to the client. \"\"\" if not self . current_pattern : return match self . mode : case ModeEnum . WEAVE : # Command a new pick, if there is one. if self . jump_pick . pick_number is not None : self . current_pattern . set_current_pick_number ( self . jump_pick . pick_number ) else : self . increment_pick_number () if self . jump_pick . pick_repeat_number is not None : self . current_pattern . pick_repeat_number = ( self . jump_pick . pick_repeat_number ) pick = self . current_pattern . get_current_pick () await self . write_shafts_to_loom ( pick . shaft_word ) await self . clear_jumps () await self . report_current_pick_number () case ModeEnum . THREAD : # Advance to the next thread group, if there is one if self . jump_end . end_number0 is not None : self . current_pattern . set_current_end_number ( end_number0 = self . jump_end . end_number0 , end_number1 = self . jump_end . end_number1 , end_repeat_number = self . jump_end . end_repeat_number , ) else : self . increment_end_number () shaft_word = self . get_threading_shaft_word () await self . write_shafts_to_loom ( shaft_word ) await self . clear_jumps () await self . report_current_end_numbers () case ModeEnum . SETTINGS : self . log . warning ( \"Mode SETTINGS not yet supported\" ) case ModeEnum . TEST : raise RuntimeError ( \"Test mode is not yet supported\" ) case _ : raise RuntimeError ( f \"Invalid mode= { self . mode !r} .\" ) def increment_pick_number ( self ) -> int : docs \"\"\"Increment pick_number in the current direction. Increment pick_repeat_number as well, if appropriate. Return the new pick number. This will be 0 if pick_repeat_number changed, or if unweaving and pick_repeat_number would be decremented to 0. \"\"\" if self . current_pattern is None : return 0 return self . current_pattern . increment_pick_number ( direction_forward = self . direction_forward ) def increment_end_number ( self ) -> None : docs \"\"\"Increment end_number0 in the current direction.\"\"\" if self . current_pattern is None : return self . current_pattern . increment_end_number ( thread_low_to_high = self . thread_low_to_high ) async def read_client_loop ( self ) -> None : docs \"\"\"Read and process commands from the client.\"\"\" # report loom connection state # and (if connected) request loom status try : self . client_connected = True await self . report_initial_server_state () if not self . loom_connected : await self . connect_to_loom () while self . client_connected : assert self . websocket is not None try : data = await self . websocket . receive_json () except json . JSONDecodeError : self . log . info ( f \" { self } : ignoring invalid command: not json-encoded\" ) # Parse the command try : cmd_type = data . get ( \"type\" ) if cmd_type is None : await self . report_command_problem ( message = f \"Invalid command; no 'type' field: { data !r} \" , severity = MessageSeverityEnum . WARNING , ) continue command = SimpleNamespace ( ** data ) if self . verbose : msg_summary = str ( command ) if len ( msg_summary ) > 80 : msg_summary = msg_summary [ 0 : 80 ] + \"...\" self . log . info ( f \" { self } : read command { msg_summary } \" ) cmd_handler = getattr ( self , f \"cmd_ { cmd_type } \" , None ) except Exception as e : message = f \"command { data } failed: { e !r} \" self . log . exception ( f \" { self } : { message } \" ) await self . report_command_done ( cmd_type = cmd_type , success = False , message = message ) # Execute the command try : if cmd_handler is None : await self . report_command_done ( cmd_type = cmd_type , success = False , message = f \"Invalid command; unknown type { cmd_type !r} \" , ) continue await cmd_handler ( command ) await self . report_command_done ( cmd_type = cmd_type , success = True ) except CommandError as e : await self . report_command_done ( cmd_type = cmd_type , success = False , message = str ( e ) ) except Exception as e : message = f \"command { command } unexpectedly failed: { e !r} \" self . log . exception ( f \" { self } : { message } \" ) await self . report_command_done ( cmd_type = cmd_type , success = False , message = message ) except asyncio . CancelledError : return except WebSocketDisconnect : self . log . info ( f \" { self } : client disconnected\" ) return except Exception as e : self . log . exception ( f \" { self } : bug: client read looop failed: { e !r} \" ) await self . report_command_problem ( message = \"Client read loop failed; try refreshing\" , severity = MessageSeverityEnum . ERROR , ) self . client_connected = False if self . websocket is not None : await self . close_websocket ( self . websocket , code = CloseCode . ERROR , reason = repr ( e ) ) async def read_loom_loop ( self ) -> None : docs \"\"\"Read and process replies from the loom.\"\"\" try : if self . loom_reader is None : raise RuntimeError ( \"No loom reader\" ) await self . get_initial_loom_state () while True : reply_bytes = await self . basic_read_loom () if self . verbose : self . log . info ( f \" { self } : read loom reply: { reply_bytes !r} \" ) if not reply_bytes : self . log . warning ( \"Reader closed; quit read_loom_loop\" ) return await self . handle_loom_reply ( reply_bytes ) except asyncio . CancelledError : pass except Exception as e : message = f \"Server stopped listening to the loom: { e !r} \" self . log . exception ( f \" { self } : { message } \" ) await self . report_command_problem ( message = message , severity = MessageSeverityEnum . ERROR , ) await self . disconnect_from_loom () async def report_command_done ( docs self , cmd_type : str , success : bool , message : str = \"\" ) -> None : \"\"\"Report completion of a command\"\"\" reply = client_replies . CommandDone ( cmd_type = cmd_type , success = success , message = message ) await self . write_to_client ( reply ) async def report_command_problem ( docs self , message : str , severity : MessageSeverityEnum ) -> None : \"\"\"Report a CommandProblem to the client.\"\"\" reply = client_replies . CommandProblem ( message = message , severity = severity ) await self . write_to_client ( reply ) async def report_current_pattern ( self ) -> None : docs \"\"\"Report pattern to the client\"\"\" if self . current_pattern is not None : await self . write_to_client ( self . current_pattern ) async def report_initial_server_state ( self ) -> None : docs \"\"\"Report server state. Called just after a client connects to the server. \"\"\" await self . report_loom_connection_state () await self . write_to_client ( self . loom_info ) await self . report_settings () await self . report_mode () await self . report_pattern_names () await self . report_direction () await self . clear_jumps ( force_output = True ) await self . report_current_pattern () await self . report_current_end_numbers () await self . report_current_pick_number () await self . report_separate_threading_repeats () await self . report_separate_weaving_repeats () await self . report_shaft_state () await self . report_thread_group_size () docs async def report_loom_connection_state ( self , reason : str = \"\" ) -> None : \"\"\"Report LoomConnectionState to the client.\"\"\" if self . loom_connecting : state = client_replies . ConnectionStateEnum . CONNECTING elif self . loom_disconnecting : state = client_replies . ConnectionStateEnum . DISCONNECTING elif self . loom_connected : state = client_replies . ConnectionStateEnum . CONNECTED else : state = client_replies . ConnectionStateEnum . DISCONNECTED reply = client_replies . LoomConnectionState ( state = state , reason = reason ) await self . write_to_client ( reply ) async def report_pattern_names ( self ) -> None : docs \"\"\"Report PatternNames to the client.\"\"\" names = await self . pattern_db . get_pattern_names () reply = client_replies . PatternNames ( names = names ) await self . write_to_client ( reply ) async def report_current_pick_number ( self ) -> None : docs \"\"\"Report CurrentPickNumber to the client. Also update pick information in the database.\"\"\" if self . current_pattern is None : return await self . pattern_db . update_pick_number ( pattern_name = self . current_pattern . name , pick_number = self . current_pattern . pick_number , pick_repeat_number = self . current_pattern . pick_repeat_number , ) reply = client_replies . CurrentPickNumber ( total_picks = compute_total_num ( num_within = self . current_pattern . pick_number , repeat_number = self . current_pattern . pick_repeat_number , repeat_len = self . current_pattern . num_picks , ), pick_number = self . current_pattern . pick_number , pick_repeat_number = self . current_pattern . pick_repeat_number , ) await self . write_to_client ( reply ) async def report_current_end_numbers ( self ) -> None : docs \"\"\"Report CurrentEndNumber to the client. Also update threading information the database. \"\"\" if self . current_pattern is None : return await self . pattern_db . update_end_number ( pattern_name = self . current_pattern . name , end_number0 = self . current_pattern . end_number0 , end_number1 = self . current_pattern . end_number1 , end_repeat_number = self . current_pattern . end_repeat_number , ) total_end_number0 = compute_total_num ( num_within = self . current_pattern . end_number0 , repeat_number = self . current_pattern . end_repeat_number , repeat_len = self . current_pattern . num_ends , ) total_end_number1 = compute_total_num ( num_within = self . current_pattern . end_number1 , repeat_number = self . current_pattern . end_repeat_number , repeat_len = self . current_pattern . num_ends , ) reply = client_replies . CurrentEndNumber ( total_end_number0 = total_end_number0 , total_end_number1 = total_end_number1 , end_number0 = self . current_pattern . end_number0 , end_number1 = self . current_pattern . end_number1 , end_repeat_number = self . current_pattern . end_repeat_number , ) await self . write_to_client ( reply ) async def report_jump_end ( self ) -> None : docs \"\"\"Report JumpEndNumber to the client.\"\"\" await self . write_to_client ( self . jump_end ) async def report_jump_pick ( self ) -> None : docs \"\"\"Report JumpPickNumber to the client.\"\"\" await self . write_to_client ( self . jump_pick ) async def report_shaft_state ( self ) -> None : docs \"\"\"Report ShaftState to the client.\"\"\" await self . write_to_client ( client_replies . ShaftState ( state = self . shaft_state , shaft_word = self . shaft_word ) ) async def report_mode ( self ) -> None : docs \"\"\"Report the current mode to the client.\"\"\" await self . write_to_client ( client_replies . Mode ( mode = self . mode )) async def report_separate_threading_repeats ( self ) -> None : docs if self . current_pattern is None : return await self . write_to_client ( client_replies . SeparateThreadingRepeats ( separate = self . current_pattern . separate_threading_repeats ) ) async def report_separate_weaving_repeats ( self ) -> None : docs if self . current_pattern is None : return await self . write_to_client ( client_replies . SeparateWeavingRepeats ( separate = self . current_pattern . separate_weaving_repeats ) ) async def report_settings ( self ) -> None : docs await self . write_to_client ( self . settings ) async def report_status_message ( docs self , message : str , severity : MessageSeverityEnum ) -> None : \"\"\"Report a status message to the client.\"\"\" await self . write_to_client ( client_replies . StatusMessage ( message = message , severity = severity ) ) async def report_thread_group_size ( self ) -> None : docs \"\"\"Report ThreadGroupSize\"\"\" if self . current_pattern is None : return client_reply = client_replies . ThreadGroupSize ( group_size = self . current_pattern . thread_group_size ) await self . write_to_client ( client_reply ) async def report_direction ( self ) -> None : docs \"\"\"Report Direction\"\"\" await self . write_to_client ( client_replies . Direction ( forward = self . direction_forward , ) ) def reset_database ( self ): docs self . db_path . unlink ( missing_ok = True ) self . pattern_db = PatternDatabase ( self . db_path ) def save_settings ( self ): docs \"\"\"Save the settings file.\"\"\" datadict = dataclasses . asdict ( self . settings ) del datadict [ \"type\" ] try : with open ( self . settings_path , \"w\" ) as f : json . dump ( datadict , f ) except Exception as e : self . log . error ( f \"Could not write settings file { self . settings_path } : { e !r} \" ) async def select_pattern ( self , name : str ) -> None : docs try : pattern = await self . pattern_db . get_pattern ( name ) except LookupError : raise CommandError ( f \"select_pattern failed: no such pattern: { name } \" ) self . current_pattern = pattern await self . report_current_pattern () await self . report_current_end_numbers () await self . report_current_pick_number () await self . report_separate_threading_repeats () await self . report_separate_weaving_repeats () await self . report_thread_group_size () def t ( self , phrase : str ) -> str : docs \"\"\"Translate a phrase, if possible.\"\"\" if phrase not in self . translation_dict : self . log . warning ( f \" { phrase !r} not in translation dict\" ) return self . translation_dict . get ( phrase , phrase ) async def write_to_client ( self , reply : Any ) -> None : docs \"\"\"Send a reply to the client. Args: reply: The reply to write, as a dataclass. It should have a \"type\" field whose value is a string. \"\"\" if self . client_connected : assert self . websocket is not None reply_dict = dataclasses . asdict ( reply ) if self . verbose : reply_str = str ( reply_dict ) if len ( reply_str ) > 120 : reply_str = reply_str [ 0 : 120 ] + \"...\" self . log . info ( f \" { self } : reply to client: { reply_str } \" ) await self . websocket . send_json ( reply_dict ) else : if self . verbose : reply_str = str ( reply ) if len ( reply_str ) > 120 : reply_str = reply_str [ 0 : 120 ] + \"...\" self . log . info ( f \" { self } : do not send reply { reply_str } ; not connected\" ) docs async def write_to_loom ( self , data : bytes | bytearray | str ) -> None : \"\"\"Send data to the loom. Args: data: The data to send, without a terminator. (This method will append the terminator). \"\"\" if self . loom_writer is None or self . loom_writer . is_closing (): raise RuntimeError ( \"Cannot write to the loom: no connection.\" ) data_bytes = data . encode () if isinstance ( data , str ) else bytes ( data ) if self . verbose : self . log . info ( f \" { self } : sending command to loom: { data_bytes + self . terminator !r} \" ) self . loom_writer . write ( data_bytes + self . terminator ) await self . loom_writer . drain () def __repr__ ( self ) -> str : return type ( self ) . __name__ async def __aenter__ ( self ) -> BaseLoomServer : await self . start () return self async def __aexit__ ( self , type : Type [ BaseException ] | None , value : BaseException | None , traceback : TracebackType | None , ) -> None : await self . close ()","title":"base_loom_server.base_loom_server"},{"location":"api/base_loom_server/base_mock_loom/","text":"base_loom_server.base_mock_loom source module base_loom_server.base_mock_loom Classes BaseMockLoom \u2014 Base class for a dobby loom similator. source class BaseMockLoom ( num_shafts : int , verbose : bool = True ) Bases : abc . ABC Base class for a dobby loom similator. Parameters num_shafts : int \u2014 The number of shafts; must be positive. verbose : bool \u2014 If True, log diagnostic information. Methods start close handle_read_bytes \u2014 Handle one command from the web server. report_direction report_motion_state report_pick_wanted report_shafts basic_read \u2014 Read one command to the loom. oob_command \u2014 Run an oob_command, specified by cmd[0] oob_command_c \u2014 Close the connection oob_command_d \u2014 Toggle weave direction oob_command_n \u2014 Request next pick open_client_connection connected move read_loop \u2014 Read commands from the loom server. report_initial_status \u2014 Report initial status. set_shaft_word \u2014 Set shafts to raise set_direction_forward write \u2014 Issue the specified data, which should not be terminated source async method BaseMockLoom . start ( self ) \u2192 None source async method BaseMockLoom . close ( self , cancel_read_loop = True ) \u2192 None source async method BaseMockLoom . handle_read_bytes ( self , read_bytes : bytes ) \u2192 None Handle one command from the web server. Raises NotImplementedError source async method BaseMockLoom . report_direction ( self ) \u2192 None Raises NotImplementedError source async method BaseMockLoom . report_motion_state ( self ) \u2192 None Raises NotImplementedError source async method BaseMockLoom . report_pick_wanted ( self ) \u2192 None Raises NotImplementedError source async method BaseMockLoom . report_shafts ( self ) \u2192 None Raises NotImplementedError source async method BaseMockLoom . basic_read ( self ) \u2192 bytes Read one command to the loom. Perform no error checking, except that self.reader exists. source async method BaseMockLoom . oob_command ( self , cmd : str ) Run an oob_command, specified by cmd[0] source async method BaseMockLoom . oob_command_c ( self , cmd : str ) Close the connection source async method BaseMockLoom . oob_command_d ( self , cmd : str ) Toggle weave direction source async method BaseMockLoom . oob_command_n ( self , cmd : str ) Request next pick source async method BaseMockLoom . open_client_connection ( self ) \u2192 tuple[ StreamReaderType , StreamWriterType ] Raises RuntimeError source method BaseMockLoom . connected ( ) \u2192 bool source async method BaseMockLoom . move ( self , shaft_word : int ) \u2192 None source async method BaseMockLoom . read_loop ( self ) \u2192 None Read commands from the loom server. source async method BaseMockLoom . report_initial_status ( self ) \u2192 None Report initial status. source async method BaseMockLoom . set_shaft_word ( self , shaft_word : int ) \u2192 None Set shafts to raise source async method BaseMockLoom . set_direction_forward ( self , direction_forward : bool ) \u2192 None source async method BaseMockLoom . write ( self , data : bytes | bytearray | str ) \u2192 None Issue the specified data, which should not be terminated","title":"base_loom_server.base_mock_loom"},{"location":"src/base_loom_server/base_mock_loom/","text":"base_loom_server.base_mock_loom docs module base_loom_server.base_mock_loom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 from __future__ import annotations __all__ = [ \"BaseMockLoom\" ] import abc import asyncio import logging import threading from types import TracebackType from typing import Type from .constants import LOG_NAME from .mock_streams import ( MockStreamReader , MockStreamWriter , StreamReaderType , StreamWriterType , open_mock_connection , ) DIRECTION_NAMES = { True : \"weave\" , False : \"unweave\" } class BaseMockLoom ( abc . ABC ): docs \"\"\"Base class for a dobby loom similator. Args: num_shafts: The number of shafts; must be positive. verbose: If True, log diagnostic information. Notes: To control a mock loom: * Call `reader.create_writer` to create a command writer. * Call `writer.create_reader` to create a reply reader. * Read replies from the reply reader. * Write commands to the command writer. \"\"\" terminator = b \" \\n \" motion_duration : float = 1 # seconds def __init__ ( self , num_shafts : int , verbose : bool = True ) -> None : if num_shafts <= 0 : raise ValueError ( f \" { num_shafts =} must be positive\" ) self . num_shafts = num_shafts self . log = logging . getLogger ( LOG_NAME ) self . verbose = verbose self . moving = False self . pick_wanted = False self . shaft_word = 0 self . direction_forward = True self . writer : StreamWriterType | None = None self . reader : StreamReaderType | None = None self . done_task : asyncio . Future = asyncio . Future () self . move_task : asyncio . Future = asyncio . Future () self . read_loop_task : asyncio . Future = asyncio . Future () self . start_task = asyncio . create_task ( self . start ()) # This event is set whenever a command is received. # It is solely intended for tests, and is used as follows: # * Clear the event # * Send a command to the loom # * Wait for the event before checking loom state # It is needed for testing looms that do not output # state information, such as Toika ES. self . command_event = asyncio . Event () # A threading version for use with fastapi.testclient.TestClient # which is, alas, synchronous. self . command_threading_event = threading . Event () async def start ( self ) -> None : docs self . reader , self . writer = open_mock_connection ( terminator = self . terminator ) self . read_loop_task = asyncio . create_task ( self . read_loop ()) async def close ( self , cancel_read_loop = True ) -> None : docs self . start_task . cancel () if cancel_read_loop : self . read_loop_task . cancel () if self . writer is not None : self . writer . close () await self . writer . wait_closed () if not self . done_task . done (): self . done_task . set_result ( None ) @abc . abstractmethod async def handle_read_bytes ( self , read_bytes : bytes ) -> None : docs \"\"\"Handle one command from the web server.\"\"\" raise NotImplementedError () @abc . abstractmethod async def report_direction ( self ) -> None : docs raise NotImplementedError @abc . abstractmethod async def report_motion_state ( self ) -> None : docs raise NotImplementedError @abc . abstractmethod async def report_pick_wanted ( self ) -> None : docs raise NotImplementedError @abc . abstractmethod async def report_shafts ( self ) -> None : docs raise NotImplementedError async def basic_read ( self ) -> bytes : docs \"\"\"Read one command to the loom. Perform no error checking, except that self.reader exists. \"\"\" assert self . reader is not None # make mypy happy return await self . reader . readuntil ( self . terminator ) async def oob_command ( self , cmd : str ): docs \"\"\"Run an oob_command, specified by cmd[0]\"\"\" if not cmd : return cmdchar = cmd [ 0 ] method = getattr ( self , f \"oob_command_ { cmdchar } \" , None ) if method is None : self . log . warning ( f \" { self } : unrecognized oob command: { cmd !r} \" ) return await method ( cmd ) async def oob_command_c ( self , cmd : str ): docs \"\"\"Close the connection\"\"\" if self . verbose : self . log . info ( f \" { self } : oob close command\" ) asyncio . create_task ( self . close ()) async def oob_command_d ( self , cmd : str ): docs \"\"\"Toggle weave direction\"\"\" self . direction_forward = not self . direction_forward await self . report_direction () if self . verbose : self . log . info ( f \" { self } : oob toggle weave direction to: \" f \" { DIRECTION_NAMES [ self . direction_forward ] } \" ) async def oob_command_n ( self , cmd : str ): docs \"\"\"Request next pick\"\"\" if self . verbose : self . log . info ( f \" { self } : oob request next pick\" ) self . pick_wanted = True await self . report_pick_wanted () docs async def open_client_connection ( self ) -> tuple [ StreamReaderType , StreamWriterType ]: await self . start_task assert self . writer is not None assert self . reader is not None # The isinstance tests make mypy happy, and might catch # a future bug if I figure out how to use virtual serial ports. if isinstance ( self . writer , MockStreamWriter ) and isinstance ( self . reader , MockStreamReader ): await self . report_initial_status () return ( self . writer . create_reader (), self . reader . create_writer (), ) else : raise RuntimeError ( f \"Bug: { self . reader =} and { self . writer =} must both be mock streams\" ) def connected ( self ) -> bool : docs return ( self . reader is not None and self . writer is not None and not self . reader . at_eof () and not self . writer . is_closing () ) async def move ( self , shaft_word : int ) -> None : docs self . moving = True await self . report_motion_state () await asyncio . sleep ( self . motion_duration ) self . moving = False self . shaft_word = shaft_word await self . report_shafts () await self . report_motion_state () async def read_loop ( self ) -> None : docs \"\"\"Read commands from the loom server.\"\"\" try : while self . connected (): assert self . reader is not None # make mypy happy cmd_bytes = await self . basic_read () if not cmd_bytes : # Connection has closed break self . command_event . set () self . command_threading_event . set () await self . handle_read_bytes ( cmd_bytes ) except Exception : self . log . exception ( f \" { self } : read_loop failed; giving up\" ) await self . close ( cancel_read_loop = False ) async def report_initial_status ( self ) -> None : docs \"\"\"Report initial status.\"\"\" await self . report_direction () await self . report_motion_state () await self . report_pick_wanted () async def set_shaft_word ( self , shaft_word : int ) -> None : docs \"\"\"Set shafts to raise\"\"\" # Ignore the command unless a pick is wanted if not self . pick_wanted : return self . pick_wanted = False await self . report_pick_wanted () self . move_task . cancel () if self . verbose : self . log . info ( f \" { self } : raise shafts { self . shaft_word : 08x } \" ) self . move_task = asyncio . create_task ( self . move ( shaft_word = shaft_word )) docs async def set_direction_forward ( self , direction_forward : bool ) -> None : self . direction_forward = bool ( direction_forward ) if self . verbose : self . log . info ( f \" { self } : set { direction_forward =} by software\" ) await self . report_direction () async def write ( self , data : bytes | bytearray | str ) -> None : docs \"\"\"Issue the specified data, which should not be terminated\"\"\" if self . verbose : self . log . info ( f \" { self } : send reply { data !r} \" ) if self . connected (): data_bytes : bytes = data . encode () if isinstance ( data , str ) else bytes ( data ) assert self . writer is not None self . writer . write ( data_bytes + self . terminator ) await self . writer . drain () def __repr__ ( self ) -> str : return type ( self ) . __name__ async def __aenter__ ( self ) -> BaseMockLoom : await self . start () return self async def __aexit__ ( self , type : Type [ BaseException ] | None , value : BaseException | None , traceback : TracebackType | None , ) -> None : await self . close ()","title":"base_loom_server.base_mock_loom"},{"location":"api/base_loom_server/client_replies/","text":"base_loom_server.client_replies source module base_loom_server.client_replies Classes CommandDone \u2014 Report completion or failure of a command CommandProblem \u2014 A problem with a command from the client CurrentEndNumber \u2014 The current threading end numbers and repeat number CurrentPickNumber \u2014 The current total_picks, pick_number and pick_repeat_number Direction \u2014 The weaving and threading direction JumpEndNumber \u2014 Pending end and repeat numbers JumpPickNumber \u2014 Pending total_picks, pick_number, and pick_repeat_number LoomConnectionState \u2014 The state of the server's connection to the loom LoomInfo \u2014 Information about the loom Mode \u2014 The mode of the server SeparateThreadingRepeats \u2014 Separate weaving repeats? SeparateWeavingRepeats \u2014 Separate weaving repeats? Settings ShaftState \u2014 Shaft status StatusMessage \u2014 Status message PatternNames \u2014 The list of loaded patterns (including the current pattern) ThreadGroupSize \u2014 The threading group size source dataclass CommandDone ( cmd_type : str , success : bool , message : str ) Report completion or failure of a command source dataclass CommandProblem ( message : str , severity : MessageSeverityEnum ) A problem with a command from the client source dataclass CurrentEndNumber ( total_end_number0 : int , total_end_number1 : int , end_number0 : int , end_number1 : int , end_repeat_number : int ) The current threading end numbers and repeat number The range of end numbers is [end_number0, end_number1). If end_number0 is 0 then end_number1 will also be zero (no threads in range). source dataclass CurrentPickNumber ( total_picks : int , pick_number : int , pick_repeat_number : int ) The current total_picks, pick_number and pick_repeat_number source dataclass Direction ( forward : bool ) The weaving and threading direction source dataclass JumpEndNumber ( total_end_number0 : int | None = None , total_end_number1 : int | None = None , end_number0 : int | None = None , end_number1 : int | None = None , end_repeat_number : int | None = None ) Pending end and repeat numbers source dataclass JumpPickNumber ( total_picks : int | None = None , pick_number : int | None = None , pick_repeat_number : int | None = None ) Pending total_picks, pick_number, and pick_repeat_number If total_picks is not None then pick_number and pick_repeat_number must also not be None. source dataclass LoomConnectionState ( state : ConnectionStateEnum , reason : str = '' ) The state of the server's connection to the loom source dataclass LoomInfo ( num_shafts : int , serial_port : str ) Information about the loom source dataclass Mode ( mode : ModeEnum ) The mode of the server source dataclass SeparateThreadingRepeats ( separate : bool ) Separate weaving repeats? source dataclass SeparateWeavingRepeats ( separate : bool ) Separate weaving repeats? source dataclass Settings ( loom_name : str , direction_control : DirectionControlEnum , thread_group_size : int , thread_right_to_left : bool , thread_back_to_front : bool ) source dataclass ShaftState ( state : ShaftStateEnum , shaft_word : int ) Shaft status shaft_word is a bitmask: bit 0 = shaft 1, etc. bit value is 0 if shaft is up shaft_word is only meaningful if state = ShaftStateEnum.DONE source dataclass StatusMessage ( message : str , severity : MessageSeverityEnum ) Status message source dataclass PatternNames ( names : list[str] ) The list of loaded patterns (including the current pattern) source dataclass ThreadGroupSize ( group_size : int ) The threading group size","title":"base_loom_server.client_replies"},{"location":"src/base_loom_server/client_replies/","text":"base_loom_server.client_replies docs module base_loom_server.client_replies 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 import dataclasses from .enums import ( ConnectionStateEnum , DirectionControlEnum , MessageSeverityEnum , ModeEnum , ShaftStateEnum , ) @dataclasses . dataclass class CommandDone : docs \"\"\"Report completion or failure of a command\"\"\" type : str = dataclasses . field ( init = False , default = \"CommandDone\" ) cmd_type : str success : bool message : str @dataclasses . dataclass class CommandProblem : docs \"\"\"A problem with a command from the client\"\"\" type : str = dataclasses . field ( init = False , default = \"CommandProblem\" ) message : str severity : MessageSeverityEnum @dataclasses . dataclass class CurrentEndNumber : docs \"\"\"The current threading end numbers and repeat number The range of end numbers is [end_number0, end_number1). If end_number0 is 0 then end_number1 will also be zero (no threads in range). \"\"\" type : str = dataclasses . field ( init = False , default = \"CurrentEndNumber\" ) total_end_number0 : int total_end_number1 : int end_number0 : int end_number1 : int end_repeat_number : int @dataclasses . dataclass class CurrentPickNumber : docs \"\"\"The current total_picks, pick_number and pick_repeat_number\"\"\" type : str = dataclasses . field ( init = False , default = \"CurrentPickNumber\" ) total_picks : int pick_number : int pick_repeat_number : int @dataclasses . dataclass class Direction : docs \"\"\"The weaving and threading direction\"\"\" type : str = dataclasses . field ( init = False , default = \"Direction\" ) forward : bool @dataclasses . dataclass class JumpEndNumber : docs \"\"\"Pending end and repeat numbers\"\"\" type : str = dataclasses . field ( init = False , default = \"JumpEndNumber\" ) total_end_number0 : int | None = None total_end_number1 : int | None = None end_number0 : int | None = None end_number1 : int | None = None end_repeat_number : int | None = None @dataclasses . dataclass class JumpPickNumber : docs \"\"\"Pending total_picks, pick_number, and pick_repeat_number If total_picks is not None then pick_number and pick_repeat_number must also not be None. \"\"\" type : str = dataclasses . field ( init = False , default = \"JumpPickNumber\" ) total_picks : int | None = None pick_number : int | None = None pick_repeat_number : int | None = None def __post_init__ ( self ) -> None : if self . total_picks is not None and ( self . pick_number is None or self . pick_repeat_number is None ): raise ValueError ( f \" { self . pick_number =} and { self . pick_repeat_number =} must not be None \" f \"if { self . total_picks =} is not None\" ) @dataclasses . dataclass class LoomConnectionState : docs \"\"\"The state of the server's connection to the loom\"\"\" type : str = dataclasses . field ( init = False , default = \"LoomConnectionState\" ) state : ConnectionStateEnum reason : str = \"\" @dataclasses . dataclass class LoomInfo : docs \"\"\"Information about the loom\"\"\" type : str = dataclasses . field ( init = False , default = \"LoomInfo\" ) num_shafts : int serial_port : str @dataclasses . dataclass class Mode : docs \"\"\"The mode of the server\"\"\" type : str = dataclasses . field ( init = False , default = \"Mode\" ) mode : ModeEnum @dataclasses . dataclass class SeparateThreadingRepeats : docs \"\"\"Separate weaving repeats?\"\"\" type : str = dataclasses . field ( init = False , default = \"SeparateThreadingRepeats\" ) separate : bool @dataclasses . dataclass class SeparateWeavingRepeats : docs \"\"\"Separate weaving repeats?\"\"\" type : str = dataclasses . field ( init = False , default = \"SeparateWeavingRepeats\" ) separate : bool @dataclasses . dataclass class Settings : docs type : str = dataclasses . field ( init = False , default = \"Settings\" ) loom_name : str direction_control : DirectionControlEnum thread_group_size : int thread_right_to_left : bool thread_back_to_front : bool @dataclasses . dataclass class ShaftState : docs \"\"\"Shaft status shaft_word is a bitmask: * bit 0 = shaft 1, etc. * bit value is 0 if shaft is up shaft_word is only meaningful if state = ShaftStateEnum.DONE \"\"\" type : str = dataclasses . field ( init = False , default = \"ShaftState\" ) state : ShaftStateEnum shaft_word : int @dataclasses . dataclass class StatusMessage : docs \"\"\"Status message\"\"\" type : str = dataclasses . field ( init = False , default = \"StatusMessage\" ) message : str severity : MessageSeverityEnum @dataclasses . dataclass class PatternNames : docs \"\"\"The list of loaded patterns (including the current pattern)\"\"\" type : str = dataclasses . field ( init = False , default = \"PatternNames\" ) names : list [ str ] @dataclasses . dataclass class ThreadGroupSize : docs \"\"\"The threading group size\"\"\" type : str = dataclasses . field ( init = False , default = \"ThreadGroupSize\" ) group_size : int","title":"base_loom_server.client_replies"},{"location":"api/base_loom_server/constants/","text":"base_loom_server.constants source module base_loom_server.constants","title":"base_loom_server.constants"},{"location":"src/base_loom_server/constants/","text":"base_loom_server.constants docs module base_loom_server.constants 1 2 3 4 5 6 __all__ = [ \"LOG_NAME\" ] # Name of the primary log used by uvicorn. # This value is from https://stackoverflow.com/a/77007723 LOG_NAME = \"uvicorn.error\"","title":"base_loom_server.constants"},{"location":"api/base_loom_server/enums/","text":"base_loom_server.enums source module base_loom_server.enums Classes ConnectionStateEnum \u2014 Client websocket connection state. DirectionControlEnum \u2014 What controls the direction (weave/unweave). MessageSeverityEnum \u2014 Severity for text messages ModeEnum ShaftStateEnum \u2014 Shaft state source enum ConnectionStateEnum ( * args , ** kwds ) Bases : enum . IntEnum Client websocket connection state. Attributes DISCONNECTED CONNECTED CONNECTING DISCONNECTING source enum DirectionControlEnum ( * args , ** kwds ) Bases : enum . IntEnum What controls the direction (weave/unweave). FULL: The direction can be changed by both the web interface and the direction button on the loom. If the loom supports this (e.g. S\u00e9guin), it is the only allowed value. If the loom does not (e.g. Toika), this value is prohibited. LOOM: The direction can only be changed by the unweave button on the loom. The web browser only displays the direction. SOFTWARE: The direction can only be changed by the web interface. The unweave button on the loom is ignored. Attributes FULL LOOM SOFTWARE source enum MessageSeverityEnum ( * args , ** kwds ) Bases : enum . IntEnum Severity for text messages Attributes INFO WARNING ERROR source enum ModeEnum ( * args , ** kwds ) Bases : enum . IntEnum Attributes WEAVE THREAD SETTINGS TEST source enum ShaftStateEnum ( * args , ** kwds ) Bases : enum . IntEnum Shaft state Attributes UNKNOWN DONE MOVING ERROR","title":"base_loom_server.enums"},{"location":"src/base_loom_server/enums/","text":"base_loom_server.enums docs module base_loom_server.enums 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import enum class ConnectionStateEnum ( enum . IntEnum ): docs \"\"\"Client websocket connection state.\"\"\" DISCONNECTED = 0 CONNECTED = 1 CONNECTING = 2 DISCONNECTING = 3 class DirectionControlEnum ( enum . IntEnum ): docs \"\"\"What controls the direction (weave/unweave). * FULL: The direction can be changed by both the web interface and the direction button on the loom. If the loom supports this (e.g. S\u00e9guin), it is the only allowed value. If the loom does not (e.g. Toika), this value is prohibited. * LOOM: The direction can only be changed by the unweave button on the loom. The web browser only displays the direction. * SOFTWARE: The direction can only be changed by the web interface. The unweave button on the loom is ignored. \"\"\" FULL = 1 LOOM = 2 SOFTWARE = 3 class MessageSeverityEnum ( enum . IntEnum ): docs \"\"\"Severity for text messages\"\"\" INFO = 1 WARNING = 2 ERROR = 3 class ModeEnum ( enum . IntEnum ): docs WEAVE = 1 THREAD = 2 SETTINGS = 3 TEST = 4 class ShaftStateEnum ( enum . IntEnum ): docs \"\"\"Shaft state\"\"\" UNKNOWN = 0 DONE = 1 MOVING = 2 ERROR = 3","title":"base_loom_server.enums"},{"location":"api/base_loom_server/example_loom_server/","text":"base_loom_server.example_loom_server source module base_loom_server.example_loom_server Classes ExampleLoomServer \u2014 Example loom server. source class ExampleLoomServer ( * , num_shafts : int , serial_port : str , translation_dict : dict[str, str] , reset_db : bool , verbose : bool , db_path : pathlib.Path | None = None ) Bases : BaseLoomServer Example loom server. Parameters num_shafts : int \u2014 The number of shafts the loom has. serial_port : str \u2014 The name of the serial port, e.g. \"/dev/tty0\". If the name is \"mock\" then use a mock loom. translation_dict : dict[str, str] \u2014 Language translation dict. reset_db : bool \u2014 If True, delete the old database and create a new one. verbose : bool \u2014 If True, log diagnostic information. name \u2014 User-assigned loom name. db_path : pathlib. Path | None \u2014 Path to the pattern database. Specify None for the default path. Unit tests specify a non-None value, to avoid stomping on the real database. Attributes thread_low_to_high : bool \u2014 Return True if threading (or unthreading) is currently low to high. loom_connected : bool \u2014 Return True if connected to the loom. Methods write_shafts_to_loom \u2014 Send a shaft_word to the loom handle_loom_reply \u2014 Process one reply from the loom. source async method ExampleLoomServer . write_shafts_to_loom ( self , shaft_word : int ) \u2192 None Send a shaft_word to the loom source async method ExampleLoomServer . handle_loom_reply ( self , reply_bytes : bytes ) \u2192 None Process one reply from the loom.","title":"base_loom_server.example_loom_server"},{"location":"src/base_loom_server/example_loom_server/","text":"base_loom_server.example_loom_server docs module base_loom_server.example_loom_server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 __all__ = [ \"ExampleLoomServer\" ] from .base_loom_server import BaseLoomServer from .client_replies import MessageSeverityEnum , ShaftStateEnum from .example_mock_loom import ExampleMockLoom class ExampleLoomServer ( BaseLoomServer ): docs \"\"\"Example loom server. Args: num_shafts: The number of shafts the loom has. serial_port: The name of the serial port, e.g. \"/dev/tty0\". If the name is \"mock\" then use a mock loom. translation_dict: Language translation dict. reset_db: If True, delete the old database and create a new one. verbose: If True, log diagnostic information. name: User-assigned loom name. db_path: Path to the pattern database. Specify None for the default path. Unit tests specify a non-None value, to avoid stomping on the real database. \"\"\" default_name = \"example\" mock_loom_type = ExampleMockLoom async def write_shafts_to_loom ( self , shaft_word : int ) -> None : docs \"\"\"Send a shaft_word to the loom\"\"\" await self . write_to_loom ( f \"C { shaft_word : 08x } \" ) async def handle_loom_reply ( self , reply_bytes : bytes ) -> None : docs \"\"\"Process one reply from the loom.\"\"\" reply = reply_bytes . decode () . strip () if not reply : return reply_char = reply [ 0 ] reply_data = reply [ 1 :] match reply_char : case \"c\" : # Shafts that are up. self . shaft_word = int ( reply_data , base = 16 ) await self . report_shaft_state () case \"m\" : # Loom moving. self . moving = reply_data == \"1\" self . shaft_state = ( ShaftStateEnum . MOVING if reply_data == \"1\" else ShaftStateEnum . DONE ) await self . report_shaft_state () case \"p\" : # Next pick wanted. await self . handle_next_pick_request () case \"u\" : # Weave or thread direction. if reply_data == \"0\" : self . direction_forward = True elif reply_data == \"1\" : self . direction_forward = False else : message = ( f \"invalid loom reply { reply !r} : \" \"direction must be 0 or 1\" ) self . log . warning ( f \"LoomServer: { message } \" ) await self . report_command_problem ( message = message , severity = MessageSeverityEnum . WARNING ) return await self . report_direction ()","title":"base_loom_server.example_loom_server"},{"location":"api/base_loom_server/example_mock_loom/","text":"base_loom_server.example_mock_loom source module base_loom_server.example_mock_loom Classes ExampleMockLoom \u2014 Example dobby loom simulator. source class ExampleMockLoom ( num_shafts : int , verbose : bool = True ) Bases : BaseMockLoom Example dobby loom simulator. This is a slightly simplified version of the S\u00e9guin dobby loom. See the doc string for BaseMockLoom for usage instructions. Parameters verbose : bool \u2014 If True, log diagnostic information. Methods handle_read_bytes \u2014 Handle one command from the web server. report_direction report_motion_state report_pick_wanted report_shafts source async method ExampleMockLoom . handle_read_bytes ( self , read_bytes : bytes ) \u2192 None Handle one command from the web server. source async method ExampleMockLoom . report_direction ( self ) \u2192 None source async method ExampleMockLoom . report_motion_state ( self ) \u2192 None source async method ExampleMockLoom . report_pick_wanted ( self ) \u2192 None source async method ExampleMockLoom . report_shafts ( self ) \u2192 None","title":"base_loom_server.example_mock_loom"},{"location":"src/base_loom_server/example_mock_loom/","text":"base_loom_server.example_mock_loom docs module base_loom_server.example_mock_loom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 __all__ = [ \"BaseMockLoom\" ] from .base_mock_loom import BaseMockLoom class ExampleMockLoom ( BaseMockLoom ): docs \"\"\"Example dobby loom simulator. This is a slightly simplified version of the S\u00e9guin dobby loom. See the doc string for `BaseMockLoom` for usage instructions. Args: verbose: If True, log diagnostic information. \"\"\" async def handle_read_bytes ( self , read_bytes : bytes ) -> None : docs \"\"\"Handle one command from the web server.\"\"\" cmd = read_bytes . decode () . rstrip () if self . verbose : self . log . info ( f \" { self } : process client command { cmd !r} \" ) if len ( cmd ) < 1 : self . log . warning ( f \" { self } : invalid command { cmd !r} : must be at least 1 character\" ) return cmd_char = cmd [ 0 ] cmd_data = cmd [ 1 :] match cmd_char : case \"C\" : # Specify which shafts to raise as a hex value try : shaft_word = int ( cmd_data , base = 16 ) except Exception : self . log . warning ( f \" { self } : invalid command { cmd !r} : data after =C not a hex value\" ) return await self . set_shaft_word ( shaft_word ) case \"U\" : # Client commands unweave on/off # (as opposed to user pushing UNW button on the loom, # in which case the loom changes it and reports it # to the client). if cmd_data not in { \"0\" , \"1\" }: self . log . warning ( f \" { self } : invalid command { cmd !r} : arg must be 0 or 1\" ) return await self . set_direction_forward ( direction_forward = cmd_data == \"0\" ) case _ : self . log . warning ( f \"MockLoom: unrecognized command: { cmd !r} \" ) async def report_direction ( self ) -> None : docs await self . write ( f \"u { int ( not self . direction_forward ) } \" ) async def report_motion_state ( self ) -> None : docs await self . write ( f \"m { int ( self . moving ) } \" ) async def report_pick_wanted ( self ) -> None : docs if self . pick_wanted : await self . write ( \"p\" ) async def report_shafts ( self ) -> None : docs await self . write ( f \"c { self . shaft_word : 08x } \" )","title":"base_loom_server.example_mock_loom"},{"location":"api/base_loom_server/main/","text":"base_loom_server.main source module base_loom_server.main Functions run_example_loom source run_example_loom ( ) \u2192 None","title":"base_loom_server.main"},{"location":"src/base_loom_server/main/","text":"base_loom_server.main docs module base_loom_server.main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import importlib.resources from fastapi import FastAPI from .app_runner import AppRunner from .example_loom_server import ExampleLoomServer PKG_NAME = \"base_loom_server\" PKG_FILES = importlib . resources . files ( PKG_NAME ) app = FastAPI () app_runner = AppRunner ( app = app , server_class = ExampleLoomServer , favicon = PKG_FILES . joinpath ( \"favicon-32x32.png\" ) . read_bytes (), app_package_name = f \" { PKG_NAME } .main:app\" , ) def run_example_loom () -> None : docs app_runner . run ()","title":"base_loom_server.main"},{"location":"api/base_loom_server/mock_streams/","text":"base_loom_server.mock_streams source module base_loom_server.mock_streams Classes MockStreamReader \u2014 Minimal mock stream reader that only supports line-oriented data and fixed-length unterminated messages. MockStreamWriter \u2014 Minimal mock stream writer that only allows writing terminated data. StreamData \u2014 Data contained in a mock stream. BaseMockStream \u2014 Base class for MockStreamReader and MockStreamWriter. Functions open_mock_connection \u2014 Create a mock stream reader, writer pair. source class MockStreamReader ( sd : StreamData | None = None , terminator : bytes = DEFAULT_TERMINATOR ) Bases : BaseMockStream Minimal mock stream reader that only supports line-oriented data and fixed-length unterminated messages. Intended to be created in one of two ways: open_mock_connection to create a reader and writer that are linked in that closing the writer also closes the reader. MockStreamWriter.create_reader to create a reader that reads from the writer. Parameters sd : StreamData | None \u2014 Stream data to use; if None create new. terminator : bytes \u2014 Required terminator. Calls to readuntil will raise AssertionError if the separator is not in the terminator. Methods at_eof \u2014 Return true if closed and all buffered data has been read. readexactly \u2014 Read exactly n bytes (including a terminator, if any). readline \u2014 Read one line of data ending with self.terminator readuntil \u2014 Read until the specified value. create_writer \u2014 Create a MockStreamWriter that writes to this reader source method MockStreamReader . at_eof ( ) \u2192 bool Return true if closed and all buffered data has been read. source async method MockStreamReader . readexactly ( self , n : int ) \u2192 bytes Read exactly n bytes (including a terminator, if any). Unlike asyncio.StreamReader , this assumes the message will be exactly n bytes long, and the terminator is checked if self.terminator != b\"\". Raises AssertionError \u2014 If the message is too long. asyncio.IncompleteReadError \u2014 If the message is too short. AssertionError \u2014 If self.terminator is not blank and the message is not terminated with self.terminator. source async method MockStreamReader . readline ( self ) \u2192 bytes Read one line of data ending with self.terminator Raises AssertionError \u2014 If self.terminator is blank. source async method MockStreamReader . readuntil ( self , separator : bytes = b'\\n' ) \u2192 bytes Read until the specified value. Raises AssertionError \u2014 If separator is blank. AssertionError \u2014 If separator not in self.terminator. source method MockStreamReader . create_writer ( ) \u2192 MockStreamWriter Create a MockStreamWriter that writes to this reader source class MockStreamWriter ( sd : StreamData | None = None , terminator : bytes = DEFAULT_TERMINATOR ) Bases : BaseMockStream Minimal mock stream writer that only allows writing terminated data. Intended to be created in one of two ways: open_mock_connection to create a reader and writer that are linked in that closing the writer also closes the reader. MockStreamReader.create_writer to create a writer that writes to the reader. Parameters sd : StreamData | None \u2014 Stream data to use; if None create new. terminator : bytes \u2014 Required terminator. Calls to write with data that is not correctly terminated will raise AssertionError . Methods close \u2014 Close the writer. is_closing \u2014 Return true if the writer is closed or being closed. drain \u2014 Push the current data to the reader. wait_closed \u2014 Wait for closing to finish. A no-op if closed. write \u2014 Write the specified data. create_reader \u2014 Create a MockStreamReader that reads from this writer. source method MockStreamWriter . close ( ) \u2192 None Close the writer. source method MockStreamWriter . is_closing ( ) \u2192 bool Return true if the writer is closed or being closed. source async method MockStreamWriter . drain ( self ) \u2192 None Push the current data to the reader. source async method MockStreamWriter . wait_closed ( self ) \u2192 None Wait for closing to finish. A no-op if closed. source method MockStreamWriter . write ( data : bytes ) \u2192 None Write the specified data. Raises AssertionError \u2014 If self.terminator is not empty and data is not properly terminated. source method MockStreamWriter . create_reader ( ) \u2192 MockStreamReader Create a MockStreamReader that reads from this writer. source open_mock_connection ( terminator = DEFAULT_TERMINATOR ) \u2192 tuple[ MockStreamReader , MockStreamWriter ] Create a mock stream reader, writer pair. To create a stream that writes to the returned reader, call reader.create_writer, and similarly for the returned writer. source class StreamData ( ) Data contained in a mock stream. Contains a queue of data and asyncio events to track data available and stream closing. source class BaseMockStream ( sd : StreamData | None = None , terminator : bytes = DEFAULT_TERMINATOR ) Base class for MockStreamReader and MockStreamWriter. Parameters sd : StreamData | None \u2014 Stream data to use; if None create new. terminator : bytes \u2014 Required terminator.","title":"base_loom_server.mock_streams"},{"location":"src/base_loom_server/mock_streams/","text":"base_loom_server.mock_streams docs module base_loom_server.mock_streams 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 from __future__ import annotations __all__ = [ \"MockStreamReader\" , \"MockStreamWriter\" , \"open_mock_connection\" , \"StreamReaderType\" , \"StreamWriterType\" , ] import asyncio import collections import weakref from typing import Deque , TypeAlias DEFAULT_TERMINATOR = b \" \\n \" class StreamData : docs \"\"\"Data contained in a mock stream. Contains a queue of data and asyncio events to track data available and stream closing. \"\"\" def __init__ ( self ) -> None : self . closed_event = asyncio . Event () self . data_available_event = asyncio . Event () self . queue : Deque [ bytes ] = collections . deque () def _is_closed ( self ): \"\"\"Return true if this stream has been closed.\"\"\" return self . closed_event . is_set () class BaseMockStream : docs \"\"\"Base class for MockStreamReader and MockStreamWriter. Args: sd: Stream data to use; if None create new. terminator: Required terminator. \"\"\" def __init__ ( self , sd : StreamData | None = None , terminator : bytes = DEFAULT_TERMINATOR ): if sd is None : sd = StreamData () self . sd = sd self . terminator = terminator self . sibling_sd : weakref . ProxyType [ StreamData ] | None = None class MockStreamReader ( BaseMockStream ): docs \"\"\"Minimal mock stream reader that only supports line-oriented data and fixed-length unterminated messages. Intended to be created in one of two ways: * `open_mock_connection` to create a reader and writer that are linked in that closing the writer also closes the reader. * `MockStreamWriter.create_reader` to create a reader that reads from the writer. Args: sd: Stream data to use; if None create new. terminator: Required terminator. Calls to `readuntil` will raise `AssertionError` if the separator is not in the terminator. \"\"\" def at_eof ( self ) -> bool : docs \"\"\"Return true if closed and all buffered data has been read.\"\"\" return not self . sd . queue and self . sd . _is_closed () async def readexactly ( self , n : int ) -> bytes : docs \"\"\"Read exactly n bytes (including a terminator, if any). Unlike `asyncio.StreamReader`, this assumes the message will be exactly n bytes long, and the terminator is checked if self.terminator != b\"\". Raises: AssertionError: If the message is too long. asyncio.IncompleteReadError: If the message is too short. AssertionError: If self.terminator is not blank and the message is not terminated with self.terminator. \"\"\" while not self . sd . queue : if self . sd . _is_closed (): return b \"\" self . sd . data_available_event . clear () await self . sd . data_available_event . wait () data = self . sd . queue . popleft () if not self . sd . queue : self . sd . data_available_event . clear () if len ( data ) != n : if len ( data ) < n : raise asyncio . IncompleteReadError ( expected = n , partial = data ) else : raise AssertionError ( f \"Read len( { data =} )= { len ( data ) } > { n =} \" ) if self . terminator and not data . endswith ( self . terminator ): raise AssertionError ( f \"Data { data =} does not end with { self . terminator =!r} \" ) return data async def readline ( self ) -> bytes : docs \"\"\"Read one line of data ending with self.terminator Raises: AssertionError: If self.terminator is blank. \"\"\" if not self . terminator : raise AssertionError ( \"readline not allowed: self.terminator is blank\" ) while not self . sd . queue : if self . sd . _is_closed (): return b \"\" self . sd . data_available_event . clear () await self . sd . data_available_event . wait () data = self . sd . queue . popleft () if not self . sd . queue : self . sd . data_available_event . clear () return data async def readuntil ( self , separator : bytes = b \" \\n \" ) -> bytes : docs \"\"\"Read until the specified value. Raises: AssertionError: If `separator` is blank. AssertionError: If `separator` not in self.terminator. \"\"\" if separator == b \"\" : raise AssertionError ( \"readuntil must have a non-blank separator\" ) if separator not in self . terminator : raise AssertionError ( f \"readuntil { separator =} not in required terminator { self . terminator !r} \" ) return await self . readline () def create_writer ( self ) -> MockStreamWriter : docs \"\"\"Create a MockStreamWriter that writes to this reader\"\"\" return MockStreamWriter ( sd = self . sd , terminator = self . terminator ) class MockStreamWriter ( BaseMockStream ): docs \"\"\"Minimal mock stream writer that only allows writing terminated data. Intended to be created in one of two ways: * `open_mock_connection` to create a reader and writer that are linked in that closing the writer also closes the reader. * `MockStreamReader.create_writer` to create a writer that writes to the reader. Args: sd: Stream data to use; if None create new. terminator: Required terminator. Calls to `write` with data that is not correctly terminated will raise `AssertionError`. \"\"\" def close ( self ) -> None : docs \"\"\"Close the writer.\"\"\" self . sd . closed_event . set () if self . sibling_sd and not self . sibling_sd . _is_closed (): self . sibling_sd . closed_event . set () def is_closing ( self ) -> bool : docs \"\"\"Return true if the writer is closed or being closed.\"\"\" return self . sd . _is_closed () async def drain ( self ) -> None : docs \"\"\"Push the current data to the reader.\"\"\" if self . is_closing (): return self . sd . data_available_event . set () async def wait_closed ( self ) -> None : docs \"\"\"Wait for closing to finish. A no-op if closed.\"\"\" await self . sd . closed_event . wait () def write ( self , data : bytes ) -> None : docs \"\"\"Write the specified data. Raises: AssertionError: If self.terminator is not empty and `data` is not properly terminated. \"\"\" if self . terminator and not data . endswith ( self . terminator ): raise AssertionError ( f \"Cannot write { data =} : it must end with { self . terminator =!r} \" ) if self . is_closing (): return self . sd . queue . append ( data ) def _set_sibling_data ( self , reader : MockStreamReader ) -> None : self . sibling_sd = weakref . proxy ( reader . sd ) def create_reader ( self ) -> MockStreamReader : docs \"\"\"Create a MockStreamReader that reads from this writer.\"\"\" return MockStreamReader ( sd = self . sd , terminator = self . terminator ) StreamReaderType : TypeAlias = asyncio . StreamReader | MockStreamReader StreamWriterType : TypeAlias = asyncio . StreamWriter | MockStreamWriter def open_mock_connection ( docs terminator = DEFAULT_TERMINATOR , ) -> tuple [ MockStreamReader , MockStreamWriter ]: \"\"\"Create a mock stream reader, writer pair. To create a stream that writes to the returned reader, call reader.create_writer, and similarly for the returned writer. \"\"\" reader = MockStreamReader ( terminator = terminator ) writer = MockStreamWriter ( terminator = terminator ) writer . _set_sibling_data ( reader = reader ) return ( reader , writer )","title":"base_loom_server.mock_streams"},{"location":"api/base_loom_server/pattern_database/","text":"base_loom_server.pattern_database source module base_loom_server.pattern_database Classes PatternDatabase \u2014 sqlite database to hold ReducedPattern instances Functions create_pattern_database make_insert_str source class PatternDatabase ( dbpath : pathlib . Path ) sqlite database to hold ReducedPattern instances The patterns are stored as json strings, but the the associated cache fields are saved in separate fields so they can be updated as they change (the values in the json strings are ignored during pattern retrieval). Methods init check_schema \u2014 Return True if the patterns table schema is as expected. add_pattern \u2014 Add a new pattern to the database. clear_database \u2014 Remove all patterns from the database. get_pattern get_pattern_names update_pick_number \u2014 Update weaving pick and repeat numbers for the specified pattern. update_end_number \u2014 Update threading end & repeat numbers for the specified pattern. update_separate_threading_repeats \u2014 Update separate_threading_repeats for the specified pattern. update_separate_weaving_repeats \u2014 Update separate_weaving_repeats for the specified pattern. update_thread_group_size \u2014 Update thread_group_size for the specified pattern. set_timestamp \u2014 Set the timestamp for the specified pattern. source async method PatternDatabase . init ( self ) \u2192 None source async method PatternDatabase . check_schema ( self ) Return True if the patterns table schema is as expected. Extra fields in the table are ignored. source async method PatternDatabase . add_pattern ( self , pattern : ReducedPattern , max_entries : int = 0 ) \u2192 None Add a new pattern to the database. Add the specified pattern to the database, overwriting any existing pattern by that name (with a new id number, so the new pattern is the most recent). Prune excess patterns and return the resulting pattern names. Parameters pattern : ReducedPattern \u2014 The pattern to add. The associated cache fields are set to default values: pick_number pick_repeat_number end_number0 end_number1 end_repeat_number thread_group_size separate_weaving_repeats separate_threading_repeats max_patterns \u2014 Maximum number of patterns to keep; no limit if 0. If >0 and there are more patterns in the database, the oldest are purged. source async method PatternDatabase . clear_database ( self ) \u2192 None Remove all patterns from the database. source async method PatternDatabase . get_pattern ( self , pattern_name : str ) \u2192 ReducedPattern Raises LookupError source async method PatternDatabase . get_pattern_names ( self ) \u2192 list[str] source async method PatternDatabase . update_pick_number ( self , pattern_name : str , pick_number : int , pick_repeat_number : int ) \u2192 None Update weaving pick and repeat numbers for the specified pattern. source async method PatternDatabase . update_end_number ( self , pattern_name : str , end_number0 : int , end_number1 : int , end_repeat_number : int ) \u2192 None Update threading end & repeat numbers for the specified pattern. source async method PatternDatabase . update_separate_threading_repeats ( self , pattern_name : str , separate_threading_repeats : bool ) \u2192 None Update separate_threading_repeats for the specified pattern. source async method PatternDatabase . update_separate_weaving_repeats ( self , pattern_name : str , separate_weaving_repeats : bool ) \u2192 None Update separate_weaving_repeats for the specified pattern. source async method PatternDatabase . update_thread_group_size ( self , pattern_name : str , thread_group_size : int ) \u2192 None Update thread_group_size for the specified pattern. source async method PatternDatabase . set_timestamp ( self , pattern_name : str , timestamp : float ) \u2192 None Set the timestamp for the specified pattern. Parameters pattern_name : str \u2014 Pattern name. timestamp : float \u2014 Timestamp in unix seconds, e.g. from time.time(). source async create_pattern_database ( dbpath : pathlib . Path ) \u2192 PatternDatabase source make_insert_str ( field_type_dict )","title":"base_loom_server.pattern_database"},{"location":"src/base_loom_server/pattern_database/","text":"base_loom_server.pattern_database docs module base_loom_server.pattern_database 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 __all__ = [ \"PatternDatabase\" , \"create_pattern_database\" ] import dataclasses import json import pathlib import time import aiosqlite from .reduced_pattern import ReducedPattern FIELD_TYPE_DICT = dict ( id = \"integer primary key\" , pattern_name = \"text\" , pattern_json = \"text\" , pick_number = \"integer\" , pick_repeat_number = \"integer\" , end_number0 = \"integer\" , end_number1 = \"integer\" , end_repeat_number = \"integer\" , thread_group_size = \"integer\" , separate_weaving_repeats = \"integer\" , separate_threading_repeats = \"integer\" , timestamp_sec = \"real\" , ) FIELDS_STR = \", \" . join ( f \" { key } { value } \" for key , value in FIELD_TYPE_DICT . items ()) def make_insert_str ( field_type_dict ): docs field_names = [ field_name for field_name in FIELD_TYPE_DICT if field_name != \"id\" ] field_names_str = \", \" . join ( field_names ) placeholders_str = \", \" . join ([ \"?\" ] * len ( field_names )) return f \"insert into patterns ( { field_names_str } ) values ( { placeholders_str } )\" INSERT_STR = make_insert_str ( FIELD_TYPE_DICT ) CACHE_FIELD_NAMES = ( \"pick_number\" , \"pick_repeat_number\" , \"end_number0\" , \"end_number1\" , \"end_repeat_number\" , \"thread_group_size\" , \"separate_weaving_repeats\" , \"separate_threading_repeats\" , ) class PatternDatabase : docs \"\"\"sqlite database to hold ReducedPattern instances The patterns are stored as json strings, but the the associated cache fields are saved in separate fields so they can be updated as they change (the values in the json strings are ignored during pattern retrieval). \"\"\" def __init__ ( self , dbpath : pathlib . Path ) -> None : self . dbpath = dbpath async def init ( self ) -> None : docs async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( f \"create table if not exists patterns ( { FIELDS_STR } )\" ) await conn . commit () async def check_schema ( self ): docs \"\"\"Return True if the patterns table schema is as expected. Extra fields in the table are ignored. \"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : async with conn . execute ( \"pragma table_info(patterns)\" ) as cursor : field_info_list = await cursor . fetchall () field_info_dict = { field_info [ 1 ]: ( field_info [ 2 ] . lower (), bool ( field_info [ - 1 ])) for field_info in field_info_list } for field_name , expected_field_type in FIELD_TYPE_DICT . items (): field_type_is_primary = field_info_dict . get ( field_name ) if field_type_is_primary is None : return False if field_name == \"id\" : if field_type_is_primary != ( \"integer\" , True ): return False elif field_type_is_primary != ( expected_field_type , False ): return False return True async def add_pattern ( docs self , pattern : ReducedPattern , max_entries : int = 0 , ) -> None : \"\"\"Add a new pattern to the database. Add the specified pattern to the database, overwriting any existing pattern by that name (with a new id number, so the new pattern is the most recent). Prune excess patterns and return the resulting pattern names. Args: pattern: The pattern to add. The associated cache fields are set to default values: * pick_number * pick_repeat_number * end_number0 * end_number1 * end_repeat_number * thread_group_size * separate_weaving_repeats * separate_threading_repeats max_patterns: Maximum number of patterns to keep; no limit if 0. If >0 and there are more patterns in the database, the oldest are purged. \"\"\" pattern_json = json . dumps ( dataclasses . asdict ( pattern )) cache_values = tuple ( getattr ( pattern , field ) for field in CACHE_FIELD_NAMES ) current_time = time . time () async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"delete from patterns where pattern_name = ?\" , ( pattern . name ,) ) # If limiting the number of entries, make sure to allow # at least two, to save the most recent pattern, # since it is likely to be the current pattern. if max_entries > 0 : max_entries = max ( max_entries , 2 ) await conn . execute ( INSERT_STR , ( pattern . name , pattern_json ) + cache_values + ( current_time ,), ) await conn . commit () pattern_names = await self . get_pattern_names () names_to_delete = pattern_names [ 0 : - max_entries ] if len ( names_to_delete ) > 0 : # Purge old patterns for pattern_name in names_to_delete : await conn . execute ( \"delete from patterns where pattern_name = ?\" , ( pattern_name ,) ) await conn . commit () async def clear_database ( self ) -> None : docs \"\"\"Remove all patterns from the database.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"delete from patterns\" ) await conn . commit () async def get_pattern ( self , pattern_name : str ) -> ReducedPattern : docs async with aiosqlite . connect ( self . dbpath ) as conn : conn . row_factory = aiosqlite . Row async with conn . execute ( \"select * from patterns where pattern_name = ?\" , ( pattern_name ,) ) as cursor : row = await cursor . fetchone () if row is None : raise LookupError ( f \" { pattern_name } not found\" ) pattern_dict = json . loads ( row [ \"pattern_json\" ]) pattern = ReducedPattern . from_dict ( pattern_dict ) for field_name in CACHE_FIELD_NAMES : setattr ( pattern , field_name , row [ field_name ]) return pattern async def get_pattern_names ( self ) -> list [ str ]: docs async with aiosqlite . connect ( self . dbpath ) as conn : async with conn . execute ( \"select pattern_name from patterns order by timestamp_sec asc, id asc\" ) as cursor : rows = await cursor . fetchall () return [ row [ 0 ] for row in rows ] async def update_pick_number ( docs self , pattern_name : str , pick_number : int , pick_repeat_number : int ) -> None : \"\"\"Update weaving pick and repeat numbers for the specified pattern.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"update patterns \" \"set pick_number = ?, pick_repeat_number = ?, timestamp_sec = ?\" \"where pattern_name = ?\" , ( pick_number , pick_repeat_number , time . time (), pattern_name ), ) await conn . commit () async def update_end_number ( docs self , pattern_name : str , end_number0 : int , end_number1 : int , end_repeat_number : int , ) -> None : \"\"\"Update threading end & repeat numbers for the specified pattern.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"update patterns \" \"set end_number0 = ?, end_number1 = ?, end_repeat_number = ?, timestamp_sec = ?\" \"where pattern_name = ?\" , ( end_number0 , end_number1 , end_repeat_number , time . time (), pattern_name , ), ) await conn . commit () async def update_separate_threading_repeats ( docs self , pattern_name : str , separate_threading_repeats : bool , ) -> None : \"\"\"Update separate_threading_repeats for the specified pattern.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"update patterns \" \"set separate_threading_repeats = ?, timestamp_sec = ?\" \"where pattern_name = ?\" , ( int ( separate_threading_repeats ), time . time (), pattern_name ), ) await conn . commit () async def update_separate_weaving_repeats ( docs self , pattern_name : str , separate_weaving_repeats : bool , ) -> None : \"\"\"Update separate_weaving_repeats for the specified pattern.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"update patterns \" \"set separate_weaving_repeats = ?, timestamp_sec = ?\" \"where pattern_name = ?\" , ( int ( separate_weaving_repeats ), time . time (), pattern_name ), ) await conn . commit () async def update_thread_group_size ( docs self , pattern_name : str , thread_group_size : int ) -> None : \"\"\"Update thread_group_size for the specified pattern.\"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"update patterns \" \"set thread_group_size = ?, timestamp_sec = ?\" \"where pattern_name = ?\" , ( thread_group_size , time . time (), pattern_name ), ) await conn . commit () docs async def set_timestamp ( self , pattern_name : str , timestamp : float ) -> None : \"\"\"Set the timestamp for the specified pattern. Args: pattern_name: Pattern name. timestamp: Timestamp in unix seconds, e.g. from time.time(). \"\"\" async with aiosqlite . connect ( self . dbpath ) as conn : await conn . execute ( \"update patterns set timestamp_sec = ? where pattern_name = ?\" , ( timestamp , pattern_name ), ) await conn . commit () docs async def create_pattern_database ( dbpath : pathlib . Path ) -> PatternDatabase : db = PatternDatabase ( dbpath = dbpath ) await db . init () return db","title":"base_loom_server.pattern_database"},{"location":"api/base_loom_server/reduced_pattern/","text":"base_loom_server.reduced_pattern source module base_loom_server.reduced_pattern Classes Pick \u2014 One pick of a pattern ReducedPattern \u2014 A weaving pattern reduced to the bare essentials. Functions reduced_pattern_from_pattern_data \u2014 Convert a dtx_to_wif.PatternData to a ReducedPattern. pop_and_check_type_field shaft_word_from_shaft_set \u2014 Convert a shaft set to a shaft word. shaft_set_from_shaft_word \u2014 Convert a shaft word to a shaft set. source dataclass Pick ( color : int , shaft_word : int ) One pick of a pattern Parameters color : int \u2014 Weft color, as an index into the color table. shaft_word : int \u2014 A bit mask, with bit 1 = shaft 0. The shaft is up if the bit is set. Methods from_dict \u2014 Construct a Pick from a dict representation. source classmethod Pick . from_dict ( datadict : dict[str, Any ] ) \u2192 Pick Construct a Pick from a dict representation. The \"type\" field is optional, but checked if present. source dataclass ReducedPattern ( name : str , color_table : list[str] , warp_colors : list[int] , threading : list[int] , picks : list[ Pick ] , pick0 : Pick , pick_number : int = 0 , pick_repeat_number : int = 1 , end_number0 : int = 0 , end_number1 : int = 0 , end_repeat_number : int = 1 , _thread_group_size : int = DEFAULT_THREAD_GROUP_SIZE , separate_weaving_repeats : bool = False , separate_threading_repeats : bool = False ) A weaving pattern reduced to the bare essentials. Contains just enough information to allow loom control, with a simple display. Picks are accessed by pick number, which is 1-based. 0 indicates that nothing has been woven. Attributes num_ends : int \u2014 How many warp ends are in the pattern num_picks : int \u2014 How many weft picks are in the pattern Methods from_dict \u2014 Construct a ReducedPattern from a dict. check_end_number \u2014 Raise IndexError if end_number0 out of range. check_pick_number \u2014 Raise IndexError if pick_number out of range. get_current_pick \u2014 Get the current pick. get_pick \u2014 Get the specified pick. get_threading_shaft_word \u2014 Get current threading shaft word. increment_end_number \u2014 Increment self.end_number0 in the specified direction. Increment end_repeat_number as well, if appropriate. increment_pick_number \u2014 Increment pick_number in the specified direction. compute_end_number1 set_current_end_number \u2014 Set end_number0. set_current_pick_number \u2014 Set pick_number. source classmethod ReducedPattern . from_dict ( datadict : dict[str, Any ] ) \u2192 ReducedPattern Construct a ReducedPattern from a dict. source property ReducedPattern . num_ends : int How many warp ends are in the pattern source property ReducedPattern . num_picks : int How many weft picks are in the pattern source property ReducedPattern . thread_group_size source method ReducedPattern . check_end_number ( end_number0 : int ) \u2192 None Raise IndexError if end_number0 out of range. The allowed range is 0 to self.len(self.threading), inclusive. See get_end_number for more information. Raises IndexError source method ReducedPattern . check_pick_number ( pick_number : int ) \u2192 None Raise IndexError if pick_number out of range. The allowed range is 0 to self.len(self.picks), inclusive. See get_pick_number for more information. Raises IndexError source method ReducedPattern . get_current_pick ( ) \u2192 Pick Get the current pick. source method ReducedPattern . get_pick ( pick_number : int ) \u2192 Pick Get the specified pick. Return self.pick0 if pick_number = 0, else return self.picks[pick_number-1] if pick_number in range. Raises IndexError \u2014 If pick_number < 0 or > len(self.picks). source method ReducedPattern . get_threading_shaft_word ( ) \u2192 int Get current threading shaft word. source method ReducedPattern . increment_end_number ( thread_low_to_high : bool ) \u2192 None Increment self.end_number0 in the specified direction. Increment end_repeat_number as well, if appropriate. End number is 1-based, but 0 means at start or end (in which case there are no threads in the group). source method ReducedPattern . increment_pick_number ( direction_forward : bool ) \u2192 int Increment pick_number in the specified direction. Increment pick_repeat_number as well, if appropriate. Return the new pick number. source method ReducedPattern . compute_end_number1 ( end_number0 : int ) \u2192 int source method ReducedPattern . set_current_end_number ( end_number0 : int , end_number1 : int | None = None , end_repeat_number : int | None = None ) \u2192 None Set end_number0. Parameters end_number0 : int \u2014 New value for end_number0, the starting end number for a group of ends to thread. Must be in range 0 \u2264 end_number0 \u2264 num_shafts. end_number1 : int | None \u2014 New value for end_number1. If None, compute it. If not None then the value must be: 0, if end_number0 = 0. In range end_number0 < end_number1 \u2264 1 + num shafts, if end_number0 \u2260 0. end_repeat_number : int | None \u2014 New value for end_repeat_number. If None, use the current value. Raises IndexError \u2014 If end_number0 < 0 or > len(self.threading). IndexError \u2014 If end_number1 not None and not valid. source method ReducedPattern . set_current_pick_number ( pick_number : int ) \u2192 None Set pick_number. Parameters pick_number : int \u2014 The pick number. Raise IndexError if pick_number < 0 or > num picks. source reduced_pattern_from_pattern_data ( name : str , data : dtx_to_wif . PatternData ) \u2192 ReducedPattern Convert a dtx_to_wif.PatternData to a ReducedPattern. Parameters name : str \u2014 The name of the pattern to use. data : dtx_to_wif . PatternData \u2014 The pattern read by dtx_to_wif. The name field is ignored. The result is simpler and smaller, and can be sent to easily encoded and sent to JavaScript. Note that all input (PatternData) indices are 1-based and all output (ReducedPattern) indices are 0-based. Raises RuntimeError source pop_and_check_type_field ( typename : str , datadict : dict[str, Any ] ) \u2192 None Raises TypeError source shaft_word_from_shaft_set ( shaft_set : Iterable [int] ) \u2192 int Convert a shaft set to a shaft word. A shaft set is a collection of 1-based shafts numbers for shafts that are up. If 0 is present, it is ignored. A shaft word is a bit mask, with bit 0 = shaft 1; if a bit is high, that shaft is up. source shaft_set_from_shaft_word ( shaft_word : int ) \u2192 set[int] Convert a shaft word to a shaft set. See shaft_word_from_shaft_set for details.","title":"base_loom_server.reduced_pattern"},{"location":"src/base_loom_server/reduced_pattern/","text":"base_loom_server.reduced_pattern docs module base_loom_server.reduced_pattern 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 from __future__ import annotations __all__ = [ \"DEFAULT_THREAD_GROUP_SIZE\" , \"NUM_ITEMS_FOR_REPEAT_SEPARATOR\" , \"Pick\" , \"ReducedPattern\" , \"reduced_pattern_from_pattern_data\" , ] import copy import dataclasses from collections.abc import Iterable from typing import Any import dtx_to_wif DEFAULT_THREAD_GROUP_SIZE = 4 # The number of picks or warp threads above which # the repeat separator is, by default, enabled # (so if the number is <= then no separator) NUM_ITEMS_FOR_REPEAT_SEPARATOR = 20 docs def pop_and_check_type_field ( typename : str , datadict : dict [ str , Any ]) -> None : typestr = datadict . pop ( \"type\" , typename ) if typestr != typename : raise TypeError ( f \"Wrong type: { typestr =!r} != { typename !r} \" ) @dataclasses . dataclass class Pick : docs \"\"\"One pick of a pattern Args: color: Weft color, as an index into the color table. shaft_word: A bit mask, with bit 1 = shaft 0. The shaft is up if the bit is set. \"\"\" color : int shaft_word : int @classmethod def from_dict ( cls , datadict : dict [ str , Any ]) -> Pick : docs \"\"\"Construct a Pick from a dict representation. The \"type\" field is optional, but checked if present. \"\"\" pop_and_check_type_field ( \"Pick\" , datadict ) return cls ( ** datadict ) @dataclasses . dataclass class ReducedPattern : docs \"\"\"A weaving pattern reduced to the bare essentials. Contains just enough information to allow loom control, with a simple display. Picks are accessed by pick number, which is 1-based. 0 indicates that nothing has been woven. \"\"\" type : str = dataclasses . field ( init = False , default = \"ReducedPattern\" ) name : str color_table : list [ str ] warp_colors : list [ int ] threading : list [ int ] picks : list [ Pick ] pick0 : Pick # Keep track of where we are in weaving pick_number : int = 0 pick_repeat_number : int = 1 # keep track of where we are in threading end_number0 : int = 0 end_number1 : int = 0 end_repeat_number : int = 1 _thread_group_size : int = DEFAULT_THREAD_GROUP_SIZE separate_weaving_repeats : bool = False separate_threading_repeats : bool = False @classmethod def from_dict ( cls , datadict : dict [ str , Any ]) -> ReducedPattern : docs \"\"\"Construct a ReducedPattern from a dict.\"\"\" # Make a copy, so the caller doesn't see the picks field change datadict = copy . deepcopy ( datadict ) pop_and_check_type_field ( typename = \"ReducedPattern\" , datadict = datadict ) datadict [ \"picks\" ] = [ Pick . from_dict ( pickdict ) for pickdict in datadict [ \"picks\" ]] datadict [ \"pick0\" ] = Pick . from_dict ( datadict [ \"pick0\" ]) return cls ( ** datadict ) @property def num_ends ( self ) -> int : docs \"\"\"How many warp ends are in the pattern\"\"\" return len ( self . threading ) @property def num_picks ( self ) -> int : docs \"\"\"How many weft picks are in the pattern\"\"\" return len ( self . picks ) @property def thread_group_size ( self ): docs return self . _thread_group_size @thread_group_size . setter def thread_group_size ( self , value : int ) -> None : value = int ( value ) if value < 1 : raise ValueError ( f \" { value =} must be positive\" ) self . _thread_group_size = value def check_end_number ( self , end_number0 : int ) -> None : docs \"\"\"Raise IndexError if end_number0 out of range. The allowed range is 0 to self.len(self.threading), inclusive. See get_end_number for more information. \"\"\" if end_number0 < 0 : raise IndexError ( f \" { end_number0 =} < 0\" ) if end_number0 > len ( self . threading ): raise IndexError ( f \" { end_number0 =} > { len ( self . threading ) } \" ) def check_pick_number ( self , pick_number : int ) -> None : docs \"\"\"Raise IndexError if pick_number out of range. The allowed range is 0 to self.len(self.picks), inclusive. See get_pick_number for more information. \"\"\" if pick_number < 0 : raise IndexError ( f \" { pick_number =} < 0\" ) if pick_number > len ( self . picks ): raise IndexError ( f \" { pick_number =} > { len ( self . picks ) } \" ) def get_current_pick ( self ) -> Pick : docs \"\"\"Get the current pick.\"\"\" return self . get_pick ( self . pick_number ) def get_pick ( self , pick_number : int ) -> Pick : docs \"\"\"Get the specified pick. Return self.pick0 if pick_number = 0, else return self.picks[pick_number-1] if pick_number in range. Raises: IndexError: If `pick_number` < 0 or > len(self.picks). \"\"\" self . check_pick_number ( pick_number ) if pick_number == 0 : return self . pick0 return self . picks [ pick_number - 1 ] def get_threading_shaft_word ( self ) -> int : docs \"\"\"Get current threading shaft word.\"\"\" if self . end_number0 == 0 : return 0 shaft_set = { self . threading [ i ] for i in range ( self . end_number0 - 1 , self . end_number1 - 1 ) } shaft_word = sum ( 1 << shaft for shaft in shaft_set if shaft >= 0 ) return shaft_word def increment_end_number ( self , thread_low_to_high : bool ) -> None : docs \"\"\"Increment self.end_number0 in the specified direction. Increment end_repeat_number as well, if appropriate. End number is 1-based, but 0 means at start or end (in which case there are no threads in the group). \"\"\" self . check_end_number ( self . end_number0 ) max_end_number = len ( self . threading ) new_end_number0 = 0 # Initialize new_end_number1 to None to allow set_current_end_number # to compute it, by default; there's at least one case where # it is simpler to compute it here new_end_number1 = None new_end_repeat_number = self . end_repeat_number if thread_low_to_high : if self . end_number0 == 0 : new_end_number0 = 1 elif self . end_number1 > max_end_number : new_end_number0 = 0 if self . separate_threading_repeats else 1 new_end_repeat_number += 1 else : new_end_number0 = self . end_number1 else : if self . end_number0 == 0 or ( self . end_number0 == 1 and not self . separate_threading_repeats ): new_end_number1 = max_end_number + 1 new_end_number0 = max ( new_end_number1 - self . thread_group_size , 1 ) new_end_repeat_number -= 1 elif self . end_number0 == 1 : new_end_number0 = 0 else : new_end_number0 = max ( self . end_number0 - self . thread_group_size , 1 ) new_end_number1 = self . end_number0 self . set_current_end_number ( end_number0 = new_end_number0 , end_number1 = new_end_number1 , end_repeat_number = new_end_repeat_number , ) def increment_pick_number ( self , direction_forward : bool ) -> int : docs \"\"\"Increment pick_number in the specified direction. Increment pick_repeat_number as well, if appropriate. Return the new pick number. \"\"\" self . check_pick_number ( self . pick_number ) next_pick_number = self . pick_number + ( 1 if direction_forward else - 1 ) if next_pick_number < 0 or ( next_pick_number == 0 and not self . separate_weaving_repeats ): self . pick_repeat_number -= 1 next_pick_number = len ( self . picks ) elif next_pick_number > len ( self . picks ): self . pick_repeat_number += 1 next_pick_number = 0 if self . separate_weaving_repeats else 1 self . pick_number = next_pick_number return next_pick_number def compute_end_number1 ( self , end_number0 : int ) -> int : docs self . check_end_number ( end_number0 ) max_end_number = len ( self . threading ) if end_number0 == 0 : return 0 return min ( end_number0 + self . thread_group_size , max_end_number + 1 ) def set_current_end_number ( docs self , end_number0 : int , end_number1 : int | None = None , end_repeat_number : int | None = None , ) -> None : \"\"\"Set end_number0. Args: end_number0: New value for end_number0, the starting end number for a group of ends to thread. Must be in range 0 \u2264 end_number0 \u2264 num_shafts. end_number1: New value for end_number1. If None, compute it. If not None then the value must be: * 0, if end_number0 = 0. * In range end_number0 < end_number1 \u2264 1 + num shafts, if end_number0 \u2260 0. end_repeat_number: New value for end_repeat_number. If None, use the current value. Raises: IndexError: If end_number0 < 0 or > len(self.threading). IndexError: If end_number1 not None and not valid. \"\"\" self . check_end_number ( end_number0 ) max_end_number = len ( self . threading ) if end_number1 is not None : if end_number0 == 0 : if end_number1 != 0 : raise IndexError ( f \" { end_number1 =} must be 0, since end_number0=0\" ) elif end_number1 > max_end_number + 1 : raise IndexError ( f \" { end_number1 =} must be <= { max_end_number + 1 } \" ) elif end_number1 <= end_number0 : raise IndexError ( f \" { end_number1 =} must be > { end_number0 =} \" ) self . end_number1 = end_number1 else : self . end_number1 = self . compute_end_number1 ( end_number0 = end_number0 ) self . end_number0 = end_number0 if end_repeat_number is not None : self . end_repeat_number = end_repeat_number def set_current_pick_number ( self , pick_number : int ) -> None : docs \"\"\"Set pick_number. Args: pick_number: The pick number. Raise IndexError if pick_number < 0 or > num picks. \"\"\" self . check_pick_number ( pick_number ) self . pick_number = pick_number def _smallest_shaft ( shafts : set [ int ]) -> int : \"\"\"Return the smallest non-zero shaft from a set of shafts. Return 0 if no non-zero shafts\"\"\" pruned_shafts = shafts - { 0 } if pruned_shafts : return list ( sorted ( shafts ))[ 0 ] return 0 def reduced_pattern_from_pattern_data ( docs name : str , data : dtx_to_wif . PatternData ) -> ReducedPattern : \"\"\"Convert a dtx_to_wif.PatternData to a ReducedPattern. Args: name: The name of the pattern to use. data: The pattern read by dtx_to_wif. The `name` field is ignored. The result is simpler and smaller, and can be sent to easily encoded and sent to JavaScript. Note that all input (PatternData) indices are 1-based and all output (ReducedPattern) indices are 0-based. \"\"\" if data . color_table : # Note: PatternData promises to have color_range # if color_table is present. if data . color_range is None : raise RuntimeError ( \"color_table specified, but color_range is None\" ) # Compute a scaled version of the color table, where each # scaled r,g,b value is in range 0-255 (0-0xff) inclusive min_color = data . color_range [ 0 ] color_scale = 255 / ( data . color_range [ 1 ] - min_color ) # Note: PatternData promises that color_table # keys are 1, 2, ...N, with no missing keys, # so we can ignore the keys and just use the values. scaled_color_rgbs = ( [ int (( value - min_color ) * color_scale ) for value in color_rgb ] for color_rgb in data . color_table . values () ) color_strs = [ f \"# { r : 02x }{ g : 02x }{ b : 02x } \" for r , g , b in scaled_color_rgbs ] if len ( color_strs ) < 1 : # Make sure we have at least 2 entries color_strs += [ \"#ffffff\" , \"#000000\" ] else : color_strs = [ \"#ffffff\" , \"#000000\" ] num_warps = max ( data . threading . keys ()) warps_from1 = list ( range ( 1 , num_warps + 1 )) num_wefts = ( max ( data . liftplan . keys ()) if data . liftplan else max ( data . treadling . keys ()) ) wefts_from1 = list ( range ( 1 , num_wefts + 1 )) default_warp_color = data . warp . color if data . warp . color is not None else 1 warp_colors = [ data . warp_colors . get ( warp , default_warp_color ) - 1 for warp in warps_from1 ] default_weft_color = data . weft . color if data . weft . color is not None else 2 weft_colors = [ data . weft_colors . get ( weft , default_weft_color ) - 1 for weft in wefts_from1 ] if data . liftplan : shaft_sets = list ( data . liftplan . get ( weft , {}) - { 0 } for weft in wefts_from1 ) # type: ignore else : shaft_sets = [] for weft in wefts_from1 : treadle_set = data . treadling . get ( weft , {}) - { 0 } # type: ignore shaft_sets . append ( set . union ( * ( data . tieup [ treadle ] for treadle in treadle_set )) - { 0 } ) if len ( shaft_sets ) != len ( weft_colors ): raise RuntimeError ( f \" { len ( shaft_sets ) =} != { len ( weft_colors ) =} \\n { shaft_sets =} \\n { weft_colors =} \" ) try : num_shafts = max ( max ( shaft_set ) for shaft_set in shaft_sets if shaft_set ) except ( ValueError , TypeError ): raise RuntimeError ( \"No shafts are raised\" ) threading = [ _smallest_shaft ( data . threading . get ( warp , { 0 })) - 1 for warp in warps_from1 ] all_shafts = set ( range ( 1 , num_shafts + 1 )) if data . is_rising_shed : shaft_words = [ shaft_word_from_shaft_set ( shaft_set ) for shaft_set in shaft_sets ] else : shaft_words = [ shaft_word_from_shaft_set ( all_shafts - shaft_set ) for shaft_set in shaft_sets ] picks = [ Pick ( shaft_word = shaft_word , color = weft_color ) for shaft_word , weft_color in zip ( shaft_words , weft_colors ) ] result = ReducedPattern ( color_table = color_strs , name = name , warp_colors = warp_colors , threading = threading , picks = picks , pick0 = Pick ( shaft_word = 0 , color = default_weft_color ), separate_weaving_repeats = len ( picks ) > NUM_ITEMS_FOR_REPEAT_SEPARATOR , separate_threading_repeats = len ( threading ) > NUM_ITEMS_FOR_REPEAT_SEPARATOR , ) return result def shaft_word_from_shaft_set ( shaft_set : Iterable [ int ]) -> int : docs \"\"\"Convert a shaft set to a shaft word. A shaft set is a collection of 1-based shafts numbers for shafts that are up. If 0 is present, it is ignored. A shaft word is a bit mask, with bit 0 = shaft 1; if a bit is high, that shaft is up. \"\"\" return sum ( 1 << shaft - 1 for shaft in shaft_set if shaft > 0 ) def shaft_set_from_shaft_word ( shaft_word : int ) -> set [ int ]: docs \"\"\"Convert a shaft word to a shaft set. See shaft_word_from_shaft_set for details. \"\"\" bin_str = bin ( shaft_word )[ 2 :] return { i + 1 for i , bit in enumerate ( reversed ( bin_str )) if bit == \"1\" }","title":"base_loom_server.reduced_pattern"},{"location":"api/base_loom_server/testutils/","text":"base_loom_server.testutils source module base_loom_server.testutils Classes Client BaseTestLoomServer \u2014 Base class for server tests. Functions assert_replies_equal change_direction \u2014 Command the loom to weave or thread in the opposite direction, and read and check the reply, if one is expected. command_next_end \u2014 Command the next threading end group and test the replies. command_next_pick \u2014 Command the next pick and test the replies. select_pattern \u2014 Tell the loom server to select a pattern. send_command \u2014 Issue a command and return all replies. upload_pattern \u2014 Upload a pattern to the loom server. source assert_replies_equal ( reply : dict[str, Any ] , expected_reply : dict[str, Any ] ) \u2192 None Raises AssertionError source dataclass Client ( test_client : TestClient , loom_server : BaseLoomServer , mock_loom : BaseMockLoom , websocket : WebSocketType ) Methods send_dict \u2014 Write a dict as json receive_dict \u2014 Read json as a dict source method Client . send_dict ( datadict : dict[str, Any ] ) Write a dict as json source method Client . receive_dict ( ) \u2192 dict[str, Any ] Read json as a dict source change_direction ( client : Client ) \u2192 None Command the loom to weave or thread in the opposite direction, and read and check the reply, if one is expected. Use a software command, if the loom supports that, else an oob command. Parameters client : Client \u2014 Client fixture. source command_next_end ( client : Client , expected_end_number0 : int , expected_end_number1 : int , expected_repeat_number : int , jump_pending : bool = False ) \u2192 None Command the next threading end group and test the replies. Ignore info-level StatusMessage Parameters client : Client \u2014 Client fixture. expected_end_number0 : int \u2014 Expected end number of the next end group. expected_repeat_number : int \u2014 Expected repeat number of the next end group. jump_pending : bool \u2014 Is a jump pending? source command_next_pick ( client : Client , expected_pick_number : int , expected_repeat_number : int , expected_shaft_word : int , jump_pending : bool = False ) \u2192 None Command the next pick and test the replies. Ignore info-level StatusMessage Parameters client : Client \u2014 Client fixture. expected_pick_number : int \u2014 Expected pick number of the next pick. expected_repeat_number : int \u2014 Expected repeat number of the next pick. expected_shaft_word : int \u2014 Expected shaft_word of the next pick. jump_pending : bool \u2014 Is a jump pending? source select_pattern ( client : Client , pattern_name : str , check_defaults : bool = True ) \u2192 ReducedPattern Tell the loom server to select a pattern. Read and check the expected replies and return the pattern. Parameters client : Client \u2014 Client test fixture. pattern_name : str \u2014 Pattern name. check_defaults : bool \u2014 If true (the default), check that all pattern fields, that are updated as one weaves or threads (such as pick_value) have the expected default value. This is only appropriate for patterns \u2014 that are newly loaded, or have not been woven on or threaded once loaded. Returns current_pattern \u2014 the actual current_pattern in the loom server (rather than the one reconstructed from the ReducedPattern reply, so you can monitor internal changes). Raises AssertionError source send_command ( client : Client , cmd_dict : dict[str, Any ] , should_fail : bool = False ) \u2192 list[dict[str, Any ]] Issue a command and return all replies. The final reply will be CommandDone and its success flag is checked Raises AssertionError source upload_pattern ( client : Client , filepath : Traversable , expected_names : Iterable [str] , should_fail = False ) \u2192 None Upload a pattern to the loom server. Check expected replies. Parameters client : Client \u2014 Test client. filepath : Traversable \u2014 Path to pattern file. expected_names : Iterable [str] \u2014 Expected pattern names. should_fail \u2014 If true, upload should fail (and expected_names is ignored). source class BaseTestLoomServer ( ) Base class for server tests. Subclasses must Set class property app to the FastAPI app for your loom server. Have a name beginning with Test Not have an __init__ method Methods test_jump_to_end test_jump_to_pick test_next_end test_next_pick test_pattern_persistence test_select_pattern test_upload test_upload_too_many_shafts test_weave_direction create_test_client \u2014 Create a test client fixture. source method BaseTestLoomServer . test_jump_to_end ( ) \u2192 None Raises RuntimeError source method BaseTestLoomServer . test_jump_to_pick ( ) \u2192 None Raises RuntimeError source method BaseTestLoomServer . test_next_end ( ) \u2192 None source method BaseTestLoomServer . test_next_pick ( ) \u2192 None source method BaseTestLoomServer . test_pattern_persistence ( ) \u2192 None source method BaseTestLoomServer . test_select_pattern ( ) \u2192 None source method BaseTestLoomServer . test_upload ( ) \u2192 None source method BaseTestLoomServer . test_upload_too_many_shafts ( ) \u2192 None source method BaseTestLoomServer . test_weave_direction ( ) \u2192 None Raises pytest . skip source classmethod BaseTestLoomServer . create_test_client ( app : FastAPI | None , num_shafts : int = 24 , read_initial_state : bool = True , upload_patterns : Iterable [ pathlib . Path ] = () , reset_db : bool = False , db_path : pathlib . Path | str | None = None , expected_status_messages : Iterable [str] = () , expected_pattern_names : Iterable [str] = () , expected_current_pattern : ReducedPattern | None = None ) \u2192 Generator [ Client ] Create a test client fixture. Parameters app : FastAPI | None \u2014 Server application to test. If None, raise an error. num_shafts : int \u2014 The number of shafts that the loom has. read_initial_state : bool \u2014 If true, read and check the initial server replies from the websocket. This is the most common case. upload_patterns : Iterable [ pathlib . Path ] \u2014 Initial patterns to upload, if any. reset_db : bool \u2014 Specify argument --reset-db ? If False, you should also specify expected_pattern_names db_path : pathlib . Path | str | None \u2014 --db-path argument value. If None, use a temp file. If not None and you expect the database to contain any patterns, then also specify expected_pattern_names and expected_current_pattern . expected_status_messages : Iterable [str] \u2014 Expected status messages when the connection is made, in order. All should have severity level INFO. expected_pattern_names : Iterable [str] \u2014 Expected pattern names, in order. Specify if and only if db_path is not None and you expect the database to contain these patterns. expected_current_pattern : ReducedPattern | None \u2014 Expected_current_pattern. Specify if and only if db_path is not None and you expect the database to contain any patterns. Raises AssertionError","title":"base_loom_server.testutils"},{"location":"src/base_loom_server/testutils/","text":"base_loom_server.testutils docs module base_loom_server.testutils 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 import base64 import contextlib import dataclasses import importlib.resources import itertools import pathlib import random import sys import tempfile from collections.abc import Generator , Iterable from importlib.resources.abc import Traversable from types import SimpleNamespace from typing import Any , TypeAlias import pytest from dtx_to_wif import read_pattern_file from fastapi import FastAPI from fastapi.testclient import TestClient from fastapi.websockets import WebSocket from starlette.testclient import WebSocketTestSession from .base_loom_server import BaseLoomServer from .base_mock_loom import BaseMockLoom from .enums import ConnectionStateEnum , MessageSeverityEnum , ModeEnum , ShaftStateEnum from .reduced_pattern import ( DEFAULT_THREAD_GROUP_SIZE , NUM_ITEMS_FOR_REPEAT_SEPARATOR , ReducedPattern , reduced_pattern_from_pattern_data , ) from .utils import compute_total_num WebSocketType : TypeAlias = WebSocket | WebSocketTestSession _PKG_NAME = \"base_loom_server\" TEST_DATA_FILES = importlib . resources . files ( _PKG_NAME ) . joinpath ( \"test_data\" ) # in Python 3.11 mypy complains: \"Traversable\" has no attribute \"glob\" ALL_PATTERN_PATHS = ( list ( TEST_DATA_FILES . glob ( \"*.wif\" )) # type: ignore + list ( TEST_DATA_FILES . glob ( \"*.dtx\" )) # type: ignore + list ( TEST_DATA_FILES . glob ( \"*.wpo\" )) # type: ignore ) docs def assert_replies_equal ( reply : dict [ str , Any ], expected_reply : dict [ str , Any ]) -> None : for key , value in expected_reply . items (): if value is not None and reply . get ( key ) != value : raise AssertionError ( f \" { reply =} != { expected_reply } : failed on field { key !r} \" ) @dataclasses . dataclass class Client : docs test_client : TestClient loom_server : BaseLoomServer mock_loom : BaseMockLoom websocket : WebSocketType def send_dict ( self , datadict : dict [ str , Any ]): docs \"\"\"Write a dict as json\"\"\" self . websocket . send_json ( datadict ) def receive_dict ( self ) -> dict [ str , Any ]: docs \"\"\"Read json as a dict\"\"\" data : Any = self . websocket . receive_json () assert isinstance ( data , dict ) return data def change_direction ( client : Client ) -> None : docs \"\"\"Command the loom to weave or thread in the opposite direction, and read and check the reply, if one is expected. Use a software command, if the loom supports that, else an oob command. Args: client: Client fixture. \"\"\" expected_direction_reply = True client . mock_loom . command_threading_event . clear () if client . loom_server . enable_software_direction : direction_forward = not client . loom_server . direction_forward replies = send_command ( client , dict ( type = \"direction\" , forward = direction_forward ) ) else : expected_direction_reply = client . loom_server . loom_reports_direction direction_forward = not client . mock_loom . direction_forward replies = send_command ( client , dict ( type = \"oobcommand\" , command = \"d\" )) if expected_direction_reply : assert len ( replies ) == 2 assert replies [ 0 ][ \"type\" ] == \"Direction\" assert replies [ 0 ][ \"forward\" ] == direction_forward else : assert len ( replies ) == 1 # Give the loom client time to process the command client . mock_loom . command_threading_event . wait ( timeout = 1 ) def command_next_end ( docs client : Client , expected_end_number0 : int , expected_end_number1 : int , expected_repeat_number : int , jump_pending : bool = False , ) -> None : \"\"\"Command the next threading end group and test the replies. Ignore info-level StatusMessage Args: client: Client fixture. expected_end_number0: Expected end number of the next end group. expected_repeat_number: Expected repeat number of the next end group. jump_pending: Is a jump pending? \"\"\" pattern = client . loom_server . current_pattern assert pattern is not None client . mock_loom . command_threading_event . clear () replies = send_command ( client , dict ( type = \"oobcommand\" , command = \"n\" )) assert len ( replies ) == 1 # Give the loom client time to process the command client . mock_loom . command_threading_event . wait ( timeout = 1 ) expected_shaft_word = pattern . get_threading_shaft_word () expected_replies : list [ dict [ str , Any ]] = [] if jump_pending : expected_replies += [ dict ( type = \"JumpEndNumber\" , end_number = None , end_repeat_number = None , ), ] num_ends_in_pattern = len ( pattern . threading ) expected_total_end_number0 = compute_total_num ( num_within = expected_end_number0 , repeat_number = expected_repeat_number , repeat_len = num_ends_in_pattern , ) expected_total_end_number1 = compute_total_num ( num_within = expected_end_number1 , repeat_number = expected_repeat_number , repeat_len = num_ends_in_pattern , ) expected_replies += [ dict ( type = \"CurrentEndNumber\" , end_number0 = expected_end_number0 , end_number1 = expected_end_number1 , total_end_number0 = expected_total_end_number0 , total_end_number1 = expected_total_end_number1 , end_repeat_number = expected_repeat_number , ), ] if client . loom_server . loom_reports_motion : expected_replies += [ dict ( type = \"ShaftState\" , state = ShaftStateEnum . MOVING , shaft_word = None , ), dict ( type = \"ShaftState\" , state = ShaftStateEnum . MOVING , shaft_word = None , ), ] expected_replies += [ dict ( type = \"ShaftState\" , state = ShaftStateEnum . DONE , shaft_word = expected_shaft_word , ), ] for expected_reply in expected_replies : reply = client . receive_dict () if ( reply [ \"type\" ] == \"ServerMessage\" and reply [ \"severity\" ] == MessageSeverityEnum . INFO ): # Ignore info-level status messages continue assert_replies_equal ( reply , expected_reply ) def command_next_pick ( docs client : Client , expected_pick_number : int , expected_repeat_number : int , expected_shaft_word : int , jump_pending : bool = False , ) -> None : \"\"\"Command the next pick and test the replies. Ignore info-level StatusMessage Args: client: Client fixture. expected_pick_number: Expected pick number of the next pick. expected_repeat_number: Expected repeat number of the next pick. expected_shaft_word: Expected shaft_word of the next pick. jump_pending: Is a jump pending? \"\"\" replies = send_command ( client , dict ( type = \"oobcommand\" , command = \"n\" )) assert len ( replies ) == 1 expected_replies : list [ dict [ str , Any ]] = [] if ( not client . loom_server . enable_software_direction and not client . loom_server . loom_reports_direction and client . loom_server . direction_forward != client . mock_loom . direction_forward ): # Loom only reports direction when it asks for a pick # and the direction has changed expected_replies += [ dict ( type = \"Direction\" , forward = client . mock_loom . direction_forward , ) ] if jump_pending : expected_replies += [ dict ( type = \"JumpPickNumber\" , pick_number = None , pick_repeat_number = None , ), ] expected_replies += [ dict ( type = \"CurrentPickNumber\" , pick_number = expected_pick_number , total_pick_number = None , pick_repeat_number = expected_repeat_number , ), ] if client . loom_server . loom_reports_motion : expected_replies += [ dict ( type = \"ShaftState\" , state = ShaftStateEnum . MOVING , shaft_word = None , ), dict ( type = \"ShaftState\" , state = ShaftStateEnum . MOVING , shaft_word = None , ), ] expected_replies += [ dict ( type = \"ShaftState\" , state = ShaftStateEnum . DONE , shaft_word = expected_shaft_word , ), ] for expected_reply in expected_replies : reply = client . receive_dict () if ( reply [ \"type\" ] == \"ServerMessage\" and reply [ \"severity\" ] == MessageSeverityEnum . INFO ): # Ignore info-level status messages continue assert_replies_equal ( reply , expected_reply ) def select_pattern ( docs client : Client , pattern_name : str , check_defaults : bool = True , ) -> ReducedPattern : \"\"\"Tell the loom server to select a pattern. Read and check the expected replies and return the pattern. Args: client: Client test fixture. pattern_name: Pattern name. check_defaults: If true (the default), check that all pattern fields, that are updated as one weaves or threads (such as pick_value) have the expected default value. This is only appropriate for patterns that are newly loaded, or have not been woven on or threaded once loaded. Returns: current_pattern: the actual current_pattern in the loom server (rather than the one reconstructed from the ReducedPattern reply, so you can monitor internal changes). \"\"\" expected_seen_types = { \"CommandDone\" , \"CurrentPickNumber\" , \"CurrentEndNumber\" , \"ReducedPattern\" , \"SeparateThreadingRepeats\" , \"SeparateWeavingRepeats\" , \"ThreadGroupSize\" , } replies = send_command ( client , dict ( type = \"select_pattern\" , name = pattern_name )) assert len ( replies ) == len ( expected_seen_types ) pattern_reply = replies [ 0 ] assert pattern_reply [ \"type\" ] == \"ReducedPattern\" pattern_in_reply = ReducedPattern . from_dict ( pattern_reply ) if check_defaults : assert pattern_in_reply . pick_number == 0 assert pattern_in_reply . pick_repeat_number == 1 assert pattern_in_reply . end_number0 == 0 assert pattern_in_reply . end_number1 == 0 assert pattern_in_reply . end_repeat_number == 1 assert pattern_in_reply . thread_group_size == DEFAULT_THREAD_GROUP_SIZE assert bool ( pattern_in_reply . separate_threading_repeats ) == ( len ( pattern_in_reply . threading ) > NUM_ITEMS_FOR_REPEAT_SEPARATOR ) assert bool ( pattern_in_reply . separate_weaving_repeats ) == ( len ( pattern_in_reply . picks ) > NUM_ITEMS_FOR_REPEAT_SEPARATOR ) seen_types : set [ str ] = { \"ReducedPattern\" } for reply_dict in replies [ 1 :]: reply = SimpleNamespace ( ** reply_dict ) match reply . type : case \"CommandDone\" : assert reply . cmd_type == \"select_pattern\" assert reply . success case \"CurrentPickNumber\" : assert reply . pick_number == pattern_in_reply . pick_number assert reply . pick_repeat_number == pattern_in_reply . pick_repeat_number assert reply . total_picks == compute_total_num ( num_within = pattern_in_reply . pick_number , repeat_number = pattern_in_reply . pick_repeat_number , repeat_len = len ( pattern_in_reply . picks ), ) case \"CurrentEndNumber\" : assert reply . end_number0 == pattern_in_reply . end_number0 assert reply . end_number1 == pattern_in_reply . end_number1 assert reply . end_repeat_number == pattern_in_reply . end_repeat_number assert reply . total_end_number0 == compute_total_num ( num_within = pattern_in_reply . end_number0 , repeat_number = pattern_in_reply . end_repeat_number , repeat_len = pattern_in_reply . num_ends , ) assert reply . total_end_number1 == compute_total_num ( num_within = pattern_in_reply . end_number1 , repeat_number = pattern_in_reply . end_repeat_number , repeat_len = pattern_in_reply . num_ends , ) case \"SeparateThreadingRepeats\" : assert reply . separate == pattern_in_reply . separate_threading_repeats case \"SeparateWeavingRepeats\" : assert reply . separate == pattern_in_reply . separate_weaving_repeats case \"ThreadGroupSize\" : assert reply . group_size == pattern_in_reply . thread_group_size case _ : raise AssertionError ( f \"Unexpected message type { reply . type } \" ) seen_types . add ( reply . type ) assert seen_types == expected_seen_types assert client . loom_server . current_pattern is not None return client . loom_server . current_pattern def send_command ( docs client : Client , cmd_dict : dict [ str , Any ], should_fail : bool = False ) -> list [ dict [ str , Any ]]: \"\"\"Issue a command and return all replies. The final reply will be CommandDone and its success flag is checked \"\"\" client . send_dict ( cmd_dict ) replies = [] while True : reply = client . receive_dict () replies . append ( reply ) if reply [ \"type\" ] == \"CommandDone\" : if should_fail == reply [ \"success\" ]: if should_fail : raise AssertionError ( f \"Command { cmd_dict } succeeded, but should have failed\" ) else : raise AssertionError ( f \"Command { cmd_dict } failed\" ) break return replies def upload_pattern ( docs client : Client , filepath : Traversable , expected_names : Iterable [ str ], should_fail = False , ) -> None : \"\"\"Upload a pattern to the loom server. Check expected replies. Args: client: Test client. filepath: Path to pattern file. expected_names: Expected pattern names. should_fail: If true, upload should fail (and `expected_names` is ignored). \"\"\" suffix = pathlib . Path ( str ( filepath )) . suffix if suffix == \".wpo\" : raw_data = filepath . read_bytes () data = base64 . b64encode ( raw_data ) . decode ( \"ascii\" ) else : data = filepath . read_text () replies = send_command ( client , dict ( type = \"file\" , name = filepath . name , data = data ), should_fail = should_fail , ) if should_fail : assert len ( replies ) == 1 else : assert len ( replies ) == 2 assert replies [ 0 ] == dict ( type = \"PatternNames\" , names = list ( expected_names )) class BaseTestLoomServer : docs \"\"\"Base class for server tests. Subclasses must: * Set class property `app` to the FastAPI app for your loom server. * Have a name beginning with Test * Not have an `__init__` method \"\"\" expected_status_messages = () app : FastAPI | None = None extra_args = () def test_jump_to_end ( self ) -> None : docs pattern_name = ALL_PATTERN_PATHS [ 4 ] . name with self . create_test_client ( app = self . app , num_shafts = 32 , upload_patterns = ALL_PATTERN_PATHS [ 2 : 5 ], ) as client : pattern = select_pattern ( client = client , pattern_name = pattern_name ) num_ends_in_pattern = len ( pattern . threading ) replies = send_command ( client , dict ( type = \"mode\" , mode = ModeEnum . THREAD )) assert len ( replies ) == 2 assert replies [ 0 ] == dict ( type = \"Mode\" , mode = ModeEnum . THREAD ) # post_action sets what to do after sending the jump_to_end cmd: # * cancel: cancel the jump_to_pick # * next: advance to the next end (thus accepting the jump) # * nothing: do nothing for ( thread_group_size , post_action , end_number0 , end_repeat_number , ) in itertools . product ( ( 1 , 4 ), ( \"cancel\" , \"next\" , \"nothing\" ), ( 0 , 1 , num_ends_in_pattern // 3 , num_ends_in_pattern ), ( - 1 , 0 , 1 , 2 ), ): replies = send_command ( client , dict ( type = \"thread_group_size\" , group_size = thread_group_size ) ) assert len ( replies ) == 2 assert replies [ 0 ] == dict ( type = \"ThreadGroupSize\" , group_size = thread_group_size ) assert pattern . thread_group_size == thread_group_size total_end_number0 = compute_total_num ( num_within = end_number0 , repeat_number = end_repeat_number , repeat_len = num_ends_in_pattern , ) replies = send_command ( client , dict ( type = \"jump_to_end\" , total_end_number0 = total_end_number0 ), ) assert len ( replies ) == 2 jump_end_reply = SimpleNamespace ( ** replies [ 0 ]) if total_end_number0 == 0 : # Jump to end_number0 0, repeat_number 1. assert jump_end_reply == SimpleNamespace ( type = \"JumpEndNumber\" , total_end_number0 = 0 , total_end_number1 = 0 , end_number0 = 0 , end_number1 = 0 , end_repeat_number = 1 , ) elif end_number0 == 0 : # Jump to end_number0 0, repeat_number not 1. # Report the last end of the previous repeat, # rather than the magic \"0\" end_number0 assert jump_end_reply == SimpleNamespace ( type = \"JumpEndNumber\" , total_end_number0 = total_end_number0 , total_end_number1 = total_end_number0 + 1 , end_number0 = num_ends_in_pattern , end_number1 = num_ends_in_pattern + 1 , end_repeat_number = end_repeat_number - 1 , ) else : end_delta = pattern . compute_end_number1 ( end_number0 ) - end_number0 # Jump to a nonzero end_number0. assert jump_end_reply == SimpleNamespace ( type = \"JumpEndNumber\" , total_end_number0 = total_end_number0 , total_end_number1 = total_end_number0 + end_delta , end_number0 = end_number0 , end_number1 = end_number0 + end_delta , end_repeat_number = end_repeat_number , ) match post_action : case \"cancel\" : replies = send_command ( client , dict ( type = \"jump_to_end\" , total_end_number0 = None ) ) assert len ( replies ) == 2 jump_end_cancel_reply = SimpleNamespace ( ** replies [ 0 ]) assert jump_end_cancel_reply == SimpleNamespace ( type = \"JumpEndNumber\" , total_end_number0 = None , total_end_number1 = None , end_number0 = None , end_number1 = None , end_repeat_number = None , ) case \"next\" : # Test against jump_end_reply because we already # checked that against expected values. command_next_end ( client = client , expected_end_number0 = jump_end_reply . end_number0 , expected_end_number1 = jump_end_reply . end_number1 , expected_repeat_number = jump_end_reply . end_repeat_number , jump_pending = True , ) case \"nothing\" : pass case _ : raise RuntimeError ( f \"Unsupported { post_action =!r} \" ) def test_jump_to_pick ( self ) -> None : docs pattern_name = ALL_PATTERN_PATHS [ 3 ] . name with self . create_test_client ( app = self . app , num_shafts = 32 , upload_patterns = ALL_PATTERN_PATHS [ 2 : 5 ], ) as client : pattern = select_pattern ( client = client , pattern_name = pattern_name ) num_picks_in_pattern = len ( pattern . picks ) # post_action sets what to do after sending the jump_to_pick cmd: # * cancel: cancel the jump_to_pick # * next: advance to the next pick (thus accepting the jump) # * nothing: do nothing for post_action , pick_number , pick_repeat_number in itertools . product ( ( \"cancel\" , \"next\" , \"nothing\" ), ( 0 , 1 , num_picks_in_pattern // 3 , num_picks_in_pattern ), ( - 1 , 0 , 1 , 2 ), ): total_picks = compute_total_num ( num_within = pick_number , repeat_number = pick_repeat_number , repeat_len = num_picks_in_pattern , ) replies = send_command ( client , dict ( type = \"jump_to_pick\" , total_picks = total_picks ), ) assert len ( replies ) == 2 jump_pick_reply = SimpleNamespace ( ** replies [ 0 ]) if total_picks == 0 : # Jump to pick_number 0, repeat_number 1. assert jump_pick_reply == SimpleNamespace ( type = \"JumpPickNumber\" , total_picks = 0 , pick_number = 0 , pick_repeat_number = 1 , ) elif pick_number == 0 : # Jump to pick_number 0, repeat_number not 1. # Report the last pick of the previous repeat, # rather than the magic \"0\" pick_number assert jump_pick_reply == SimpleNamespace ( type = \"JumpPickNumber\" , total_picks = total_picks , pick_number = num_picks_in_pattern , pick_repeat_number = pick_repeat_number - 1 , ) else : # Jump to a nonzero pick_number. assert jump_pick_reply == SimpleNamespace ( type = \"JumpPickNumber\" , total_picks = total_picks , pick_number = pick_number , pick_repeat_number = pick_repeat_number , ) match post_action : case \"cancel\" : replies = send_command ( client , dict ( type = \"jump_to_pick\" , total_picks = None ) ) assert len ( replies ) == 2 jump_pick_cancel_reply = SimpleNamespace ( ** replies [ 0 ]) assert jump_pick_cancel_reply == SimpleNamespace ( type = \"JumpPickNumber\" , total_picks = None , pick_number = None , pick_repeat_number = None , ) case \"next\" : command_next_pick ( client = client , expected_pick_number = jump_pick_reply . pick_number , expected_repeat_number = jump_pick_reply . pick_repeat_number , expected_shaft_word = pattern . get_pick ( jump_pick_reply . pick_number ) . shaft_word , jump_pending = True , ) case \"nothing\" : pass case _ : raise RuntimeError ( f \"Unsupported { post_action =!r} \" ) def test_next_end ( self ) -> None : docs pattern_name = ALL_PATTERN_PATHS [ 1 ] . name with self . create_test_client ( app = self . app , upload_patterns = ALL_PATTERN_PATHS [ 0 : 3 ], ) as client : pattern = select_pattern ( client = client , pattern_name = pattern_name ) num_ends_in_pattern = len ( pattern . threading ) replies = send_command ( client , dict ( type = \"mode\" , mode = ModeEnum . THREAD )) assert len ( replies ) == 2 assert replies [ 0 ] == dict ( type = \"Mode\" , mode = ModeEnum . THREAD ) for separate_threading_repeats , thread_group_size in itertools . product ( ( False , True ), ( 1 , 2 , 3 , num_ends_in_pattern - 1 , num_ends_in_pattern , num_ends_in_pattern + 1 , ), ): print ( f \" { separate_threading_repeats =} , { thread_group_size =} \" ) pattern . set_current_end_number ( end_number0 = 0 , end_repeat_number = 1 ) expected_end_number0 = 0 expected_end_number1 = 0 expected_repeat_number = 1 # Start threading low to high assert client . loom_server . thread_low_to_high replies = send_command ( client , dict ( type = \"separate_threading_repeats\" , separate = separate_threading_repeats , ), ) assert len ( replies ) == 2 assert replies [ 0 ] == dict ( type = \"SeparateThreadingRepeats\" , separate = separate_threading_repeats ) assert pattern . separate_threading_repeats == separate_threading_repeats replies = send_command ( client , dict ( type = \"thread_group_size\" , group_size = thread_group_size ) ) assert len ( replies ) == 2 assert replies [ 0 ] == dict ( type = \"ThreadGroupSize\" , group_size = thread_group_size ) assert pattern . thread_group_size == thread_group_size # Make enough low_to_high end advances to get into 3rd repeat expected_end_number0 = 0 expected_repeat_number = 1 while expected_repeat_number < 3 : if expected_end_number1 == 0 : expected_end_number0 = 1 elif expected_end_number1 <= num_ends_in_pattern : expected_end_number0 = expected_end_number1 else : # Wrap around expected_end_number0 = ( 0 if pattern . separate_threading_repeats else 1 ) expected_repeat_number += 1 if expected_end_number0 == 0 : expected_end_number1 = 0 else : expected_end_number1 = min ( expected_end_number0 + thread_group_size , num_ends_in_pattern + 1 , ) command_next_end ( client = client , expected_end_number0 = expected_end_number0 , expected_end_number1 = expected_end_number1 , expected_repeat_number = expected_repeat_number , ) # Change to unthreading (high to low) change_direction ( client ) assert not client . loom_server . thread_low_to_high iter_past_beginning = 0 while iter_past_beginning < 2 : if expected_end_number0 == 0 or ( expected_end_number0 == 1 and not separate_threading_repeats ): # Wrap around expected_end_number1 = num_ends_in_pattern + 1 expected_end_number0 = max ( 1 , num_ends_in_pattern + 1 - thread_group_size ) expected_repeat_number -= 1 elif expected_end_number0 == 1 : expected_end_number0 = 0 expected_end_number1 = 0 else : expected_end_number1 = expected_end_number0 expected_end_number0 = max ( 1 , expected_end_number0 - thread_group_size ) if expected_repeat_number <= 0 : iter_past_beginning += 1 command_next_end ( client = client , expected_end_number0 = expected_end_number0 , expected_end_number1 = expected_end_number1 , expected_repeat_number = expected_repeat_number , ) assert expected_repeat_number <= 0 # Go back to threading change_direction ( client ) assert client . loom_server . thread_low_to_high def test_next_pick ( self ) -> None : docs pattern_name = ALL_PATTERN_PATHS [ 2 ] . name with self . create_test_client ( app = self . app , upload_patterns = ALL_PATTERN_PATHS [ 0 : 3 ], ) as client : pattern = select_pattern ( client = client , pattern_name = pattern_name ) num_picks_in_pattern = len ( pattern . picks ) # Make enough forward picks to get into the 3rd repeat expected_pick_number = 0 expected_repeat_number = 1 i = 0 while not ( expected_repeat_number == 3 and expected_pick_number > 2 ): i += 1 expected_pick_number += 1 if expected_pick_number > num_picks_in_pattern : expected_pick_number = 0 if pattern . separate_weaving_repeats else 1 expected_repeat_number += 1 expected_shaft_word = pattern . get_pick ( expected_pick_number ) . shaft_word command_next_pick ( client = client , expected_pick_number = expected_pick_number , expected_repeat_number = expected_repeat_number , expected_shaft_word = expected_shaft_word , ) change_direction ( client = client ) # Now go backwards at least two picks past the beginning end_pick_number = num_picks_in_pattern - 2 while not ( expected_pick_number == end_pick_number and expected_repeat_number == 0 ): expected_pick_number -= 1 if ( expected_pick_number < 0 ) or ( expected_pick_number == 0 and not pattern . separate_weaving_repeats ): expected_pick_number = num_picks_in_pattern expected_repeat_number -= 1 expected_shaft_word = pattern . get_pick ( expected_pick_number ) . shaft_word command_next_pick ( client = client , expected_pick_number = expected_pick_number , expected_repeat_number = expected_repeat_number , expected_shaft_word = expected_shaft_word , ) assert expected_pick_number == end_pick_number assert expected_repeat_number == 0 # Change direction to forward change_direction ( client ) expected_pick_number += 1 expected_shaft_word = pattern . get_pick ( expected_pick_number ) . shaft_word command_next_pick ( client = client , expected_pick_number = expected_pick_number , expected_repeat_number = expected_repeat_number , expected_shaft_word = expected_shaft_word , ) def test_pattern_persistence ( self ) -> None : docs rnd = random . Random ( 47 ) pattern_list = [] with tempfile . TemporaryDirectory () as temp_dir : db_path = pathlib . Path ( temp_dir ) / \"loom_server_database.sqlite\" with self . create_test_client ( app = self . app , upload_patterns = ALL_PATTERN_PATHS , db_path = db_path , ) as client : # Select a few patterns; for each one jump to some random # pick (including actually going to that pick). assert len ( ALL_PATTERN_PATHS ) > 3 for path in ( ALL_PATTERN_PATHS [ 0 ], ALL_PATTERN_PATHS [ 3 ]): pattern = select_pattern ( client = client , pattern_name = path . name ) pattern_list . append ( pattern ) pattern . pick_number = rnd . randrange ( 2 , len ( pattern . picks )) pattern . pick_repeat_number = rnd . randrange ( - 10 , 10 ) pattern . thread_group_size = rnd . randrange ( 1 , 10 ) num_picks_in_pattern = len ( pattern . picks ) total_picks = compute_total_num ( num_within = pattern . pick_number , repeat_number = pattern . pick_repeat_number , repeat_len = num_picks_in_pattern , ) replies = send_command ( client , dict ( type = \"jump_to_pick\" , total_picks = total_picks ), ) assert len ( replies ) == 2 if total_picks == 0 : assert replies [ 0 ] == dict ( type = \"JumpPickNumber\" , total_picks = 0 , pick_number = 0 , pick_repeat_number = 1 , ) elif pattern . pick_number == 0 and total_picks != 0 : # Special case: report the last pick of the previous # repeat, rather than the magic \"0\" pick_number assert replies [ 0 ] == dict ( type = \"JumpPickNumber\" , total_picks = total_picks , pick_number = num_picks_in_pattern , pick_repeat_number = pattern . pick_repeat_number - 1 , ) else : assert replies [ 0 ] == dict ( type = \"JumpPickNumber\" , total_picks = total_picks , pick_number = pattern . pick_number , pick_repeat_number = pattern . pick_repeat_number , ) expected_pick_number = pattern . pick_number expected_shaft_word = pattern . get_pick ( expected_pick_number ) . shaft_word command_next_pick ( client = client , jump_pending = True , expected_pick_number = expected_pick_number , expected_repeat_number = pattern . pick_repeat_number , expected_shaft_word = expected_shaft_word , ) replies = send_command ( client , dict ( type = \"thread_group_size\" , group_size = pattern . thread_group_size , ), ) assert len ( replies ) == 2 assert replies [ 0 ] == dict ( type = \"ThreadGroupSize\" , group_size = pattern . thread_group_size , ) # This expects that first pattern 0 and then pattern 3 # was selected from ALL_PATTERN_PATHS: all_pattern_names = [ path . name for path in ALL_PATTERN_PATHS ] expected_pattern_names = ( all_pattern_names [ 1 : 3 ] + all_pattern_names [ 4 :] + [ all_pattern_names [ 0 ], all_pattern_names [ 3 ]] ) expected_current_pattern = pattern_list [ 1 ] with self . create_test_client ( app = self . app , reset_db = False , expected_pattern_names = expected_pattern_names , expected_current_pattern = expected_current_pattern , db_path = db_path , ) as client : for pattern in pattern_list : returned_pattern = select_pattern ( client = client , pattern_name = pattern . name , check_defaults = False , ) assert returned_pattern == pattern # Now try again, but this time reset the database with self . create_test_client ( app = self . app , reset_db = True , ) as client : pass def test_select_pattern ( self ) -> None : docs # Read a pattern file in and convert the data to a ReducedPattern pattern_path = ALL_PATTERN_PATHS [ 1 ] pattern_data = read_pattern_file ( pattern_path ) reduced_pattern = reduced_pattern_from_pattern_data ( name = pattern_path . name , data = pattern_data ) with self . create_test_client ( app = self . app , upload_patterns = ALL_PATTERN_PATHS [ 0 : 3 ], ) as client : selected_pattern = select_pattern ( client = client , pattern_name = pattern_path . name ) assert selected_pattern == reduced_pattern def test_upload ( self ) -> None : docs with self . create_test_client ( app = self . app , upload_patterns = ALL_PATTERN_PATHS , ) as _ : pass def test_upload_too_many_shafts ( self ) -> None : docs # Pick a file with 18 shafts filename = \"eighteen shaft liftplan.wif\" filepath = TEST_DATA_FILES / filename with self . create_test_client ( app = self . app , num_shafts = 16 , ) as client : upload_pattern ( client = client , filepath = filepath , expected_names = [ \"\" ], should_fail = True ) def test_weave_direction ( self ) -> None : docs pattern_name = ALL_PATTERN_PATHS [ 1 ] . name with self . create_test_client ( app = self . app , upload_patterns = ALL_PATTERN_PATHS [ 0 : 4 ], ) as client : if not client . loom_server . enable_software_direction : raise pytest . skip ( \"Weave direction cannot be controlled by software\" ) select_pattern ( client = client , pattern_name = pattern_name ) for forward in ( False , True ): replies = send_command ( client , dict ( type = \"direction\" , forward = forward )) assert len ( replies ) == 2 assert replies [ 0 ][ \"type\" ] == \"Direction\" assert replies [ 0 ][ \"forward\" ] == forward @classmethod @contextlib . contextmanager def create_test_client ( docs cls , app : FastAPI | None , num_shafts : int = 24 , read_initial_state : bool = True , upload_patterns : Iterable [ pathlib . Path ] = (), reset_db : bool = False , db_path : pathlib . Path | str | None = None , expected_status_messages : Iterable [ str ] = (), expected_pattern_names : Iterable [ str ] = (), expected_current_pattern : ReducedPattern | None = None , ) -> Generator [ Client ]: \"\"\"Create a test client fixture. Args: app: Server application to test. If None, raise an error. num_shafts: The number of shafts that the loom has. read_initial_state: If true, read and check the initial server replies from the websocket. This is the most common case. upload_patterns: Initial patterns to upload, if any. reset_db: Specify argument `--reset-db`? If False, you should also specify `expected_pattern_names` db_path: `--db-path` argument value. If None, use a temp file. If not None and you expect the database to contain any patterns, then also specify `expected_pattern_names` and `expected_current_pattern`. expected_status_messages: Expected status messages when the connection is made, in order. All should have severity level INFO. expected_pattern_names: Expected pattern names, in order. Specify if and only if `db_path` is not None and you expect the database to contain these patterns. expected_current_pattern: Expected_current_pattern. Specify if and only if `db_path` is not None and you expect the database to contain any patterns. \"\"\" expected_pattern_names = list ( expected_pattern_names ) expected_status_messages = list ( expected_status_messages ) if app is None : raise AssertionError ( \"app is None but must be a FastAPI; \" \"you must set the app class property in your subclass\" ) with tempfile . TemporaryDirectory () as temp_dir : if db_path is None : db_path = pathlib . Path ( temp_dir ) / \"loom_server_database.sqlite\" argv = [ \"testutils\" , str ( num_shafts ), \"mock\" , \"--verbose\" ] + list ( cls . extra_args ) if reset_db : argv . append ( \"--reset-db\" ) argv += [ \"--db-path\" , str ( db_path )] sys . argv = argv with TestClient ( app ) as test_client : with test_client . websocket_connect ( \"/ws\" ) as websocket : loom_server : BaseLoomServer = test_client . app . state . loom_server # type: ignore assert loom_server . mock_loom is not None assert loom_server . settings . loom_name == loom_server . default_name assert loom_server . loom_info . num_shafts == num_shafts client = Client ( test_client = test_client , websocket = websocket , loom_server = loom_server , mock_loom = loom_server . mock_loom , ) if read_initial_state : seen_types : set [ str ] = set () expected_types = { \"JumpEndNumber\" , \"JumpPickNumber\" , \"LoomConnectionState\" , \"LoomInfo\" , \"Mode\" , \"PatternNames\" , \"Settings\" , \"ShaftState\" , \"Direction\" , } if expected_status_messages : expected_types |= { \"StatusMessage\" } if expected_current_pattern : expected_types |= { \"CurrentPickNumber\" , \"CurrentEndNumber\" , \"ReducedPattern\" , \"SeparateWeavingRepeats\" , \"SeparateThreadingRepeats\" , \"ThreadGroupSize\" , } good_connection_states = { ConnectionStateEnum . CONNECTING , ConnectionStateEnum . CONNECTED , } while True : reply_dict = client . receive_dict () reply = SimpleNamespace ( ** reply_dict ) num_status_messages_seen = 0 match reply . type : case \"CurrentEndNumber\" : assert expected_current_pattern is not None assert ( reply . end_number0 == expected_current_pattern . end_number0 ) assert ( reply . end_number1 == expected_current_pattern . end_number1 ) assert ( reply . end_repeat_number == expected_current_pattern . end_repeat_number ) assert reply . total_end_number0 == compute_total_num ( num_within = expected_current_pattern . end_number0 , repeat_number = expected_current_pattern . end_repeat_number , repeat_len = expected_current_pattern . num_ends , ) assert reply . total_end_number1 == compute_total_num ( num_within = expected_current_pattern . end_number1 , repeat_number = expected_current_pattern . end_repeat_number , repeat_len = expected_current_pattern . num_ends , ) case \"CurrentPickNumber\" : assert expected_current_pattern is not None assert ( reply . pick_number == expected_current_pattern . pick_number ) assert ( reply . pick_repeat_number == expected_current_pattern . pick_repeat_number ) assert reply . total_picks == compute_total_num ( num_within = expected_current_pattern . pick_number , repeat_number = expected_current_pattern . pick_repeat_number , repeat_len = len ( expected_current_pattern . picks ), ) case \"JumpEndNumber\" : for field_name , value in vars ( reply ) . items (): if field_name == \"type\" : continue assert value is None case \"JumpPickNumber\" : for field_name , value in vars ( reply ) . items (): if field_name == \"type\" : continue assert value is None case \"LoomConnectionState\" : if reply . state not in good_connection_states : raise AssertionError ( f \"Unexpected state in { reply =} ; \" f \"should be in { good_connection_states } \" ) elif reply . state != ConnectionStateEnum . CONNECTED : continue case \"LoomInfo\" : assert vars ( reply ) == dataclasses . asdict ( loom_server . loom_info ) case \"Mode\" : assert reply . mode == ModeEnum . WEAVE case \"PatternNames\" : assert reply . names == expected_pattern_names case \"ReducedPattern\" : if not expected_pattern_names : raise AssertionError ( f \"Unexpected message type { reply . type } \" \"because expected_current_pattern is None\" ) assert reply . name == expected_pattern_names [ - 1 ] case \"SeparateThreadingRepeats\" : assert expected_current_pattern is not None assert ( reply . separate == expected_current_pattern . separate_threading_repeats ) case \"SeparateWeavingRepeats\" : assert expected_current_pattern is not None assert ( reply . separate == expected_current_pattern . separate_weaving_repeats ) case \"Settings\" : assert vars ( reply ) == dataclasses . asdict ( loom_server . settings ) case \"ShaftState\" : assert reply . state == ShaftStateEnum . DONE assert reply . shaft_word == 0 case \"StatusMessage\" : num_status_messages_seen += 1 assert ( reply . message == expected_status_messages [ num_status_messages_seen - 1 ] ) assert reply . severity == MessageSeverityEnum . INFO case \"ThreadGroupSize\" : assert expected_current_pattern is not None assert ( reply . group_size == expected_current_pattern . thread_group_size ) case \"Direction\" : assert reply . forward case _ : raise AssertionError ( f \"Unexpected message type { reply . type } \" ) seen_types . add ( reply . type ) if ( seen_types == expected_types and num_status_messages_seen == len ( expected_status_messages ) ): break expected_names : list [ str ] = [] for filepath in upload_patterns : expected_names . append ( filepath . name ) upload_pattern ( client = client , filepath = filepath , expected_names = expected_names , ) yield client","title":"base_loom_server.testutils"},{"location":"api/base_loom_server/utils/","text":"base_loom_server.utils source module base_loom_server.utils Functions compute_num_within_and_repeats \u2014 Compute num_within and repeat_number from total_num and repeat_len such that total_num = (repeat_number - 1) * repeat_len + num_within. compute_total_num \u2014 Compute total_num from num_within, repeat_number, and repeat_len source compute_num_within_and_repeats ( total_num : int , repeat_len : int ) \u2192 tuple[int, int] Compute num_within and repeat_number from total_num and repeat_len such that total_num = (repeat_number - 1) * repeat_len + num_within. Parameters total_num : int \u2014 Total count (e.g. picks or ends). repeat_len : int \u2014 Number of counts in one repeat; must be positive. Returns A tuple consisting of \u2014 num_within: Number of counts in range [1, repeat_len], or 0 if total_num == 0 repeat_num: 1 + number of full repeats (the first repeat has value 1) Raises ValueError \u2014 If repeat_len \u2264 0. Notes If total_num is 0 return (0, 0) because that is the most sensible thing to show when we haven't started weaving or threading. Otherwise, if total_num is exactly N repeats of repeat_len, return (repeat_len, N) rather than (0, N+1), because I want to display a pick or end that is in the pattern, rather than the mythical pick or repeat 0. source compute_total_num ( num_within : int , repeat_number : int , repeat_len : int ) \u2192 int Compute total_num from num_within, repeat_number, and repeat_len This is basically the opposite of divmod, but handles None inputs and repeat_number is 1-based. Parameters num_within : int \u2014 A value in range [-repeat_len, repeat_len]. repeat_number : int \u2014 1 + number of full repeats. repeat_len : int \u2014 Length of one repeat; must be positive or None. Returns int \u2014 total_num = repeat_len * (repeat_number - 1) + num_within Raises ValueError","title":"base_loom_server.utils"},{"location":"src/base_loom_server/utils/","text":"base_loom_server.utils docs module base_loom_server.utils 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def compute_num_within_and_repeats ( total_num : int , repeat_len : int ) -> tuple [ int , int ]: docs \"\"\"Compute num_within and repeat_number from total_num and repeat_len such that total_num = (repeat_number - 1) * repeat_len + num_within. Args: total_num: Total count (e.g. picks or ends). repeat_len: Number of counts in one repeat; must be positive. Returns: A tuple consisting of: * num_within: Number of counts in range [1, repeat_len], or 0 if total_num == 0 * repeat_num: 1 + number of full repeats (the first repeat has value 1) Raises: ValueError: If `repeat_len` \u2264 0. Notes: If total_num is 0 return (0, 0) because that is the most sensible thing to show when we haven't started weaving or threading. Otherwise, if total_num is exactly N repeats of repeat_len, return (repeat_len, N) rather than (0, N+1), because I want to display a pick or end that is in the pattern, rather than the mythical pick or repeat 0. \"\"\" if repeat_len <= 0 : raise ValueError ( f \" { repeat_len =} must be positive (or None)\" ) zero_based_repeat_number , num_within = divmod ( total_num , repeat_len ) if num_within == 0 and total_num != 0 : # Avoid num_within 0 unless total_num is also 0 num_within = repeat_len zero_based_repeat_number -= 1 return ( num_within , zero_based_repeat_number + 1 ) docs def compute_total_num ( num_within : int , repeat_number : int , repeat_len : int ) -> int : \"\"\"Compute total_num from num_within, repeat_number, and repeat_len This is basically the opposite of divmod, but handles None inputs and repeat_number is 1-based. Args: num_within: A value in range [-repeat_len, repeat_len]. repeat_number: 1 + number of full repeats. repeat_len: Length of one repeat; must be positive or None. Returns: total_num = repeat_len * (repeat_number - 1) + num_within \"\"\" if repeat_len <= 0 : raise ValueError ( f \" { repeat_len =} must be positive (or None)\" ) return repeat_len * ( repeat_number - 1 ) + num_within","title":"base_loom_server.utils"},{"location":"api/base_loom_server/version/","text":"base_loom_server.version source module base_loom_server.version","title":"base_loom_server.version"},{"location":"src/base_loom_server/version/","text":"base_loom_server.version docs module base_loom_server.version 1 2 3 # Generated by setuptools_scm __all__ = [ \"__version__\" ] __version__ = \"0.19.3\"","title":"base_loom_server.version"}]}